
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-B10B048F-37FF-53E7-92B9-83F8C197566A.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 06:13:30 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2011" /><meta name="DC.rights.owner" content="(C) Copyright 2011" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Image Decoding" /><meta name="DC.Relation" scheme="URI" content="GUID-88091838-03FC-550F-9A3D-DA70907EF955" /><meta name="DC.Relation" scheme="URI" content="GUID-3D9C4B45-EEA0-581C-A9E5-8B2535014930" /><meta name="DC.Relation" scheme="URI" content="GUID-6DC34798-86CE-537D-B3B8-9A94FF77B283" /><meta name="DC.Relation" scheme="URI" content="GUID-A825B62E-B5F6-5FDD-B267-E47103D57FD8" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-1DE5CDAD-8D71-5384-9E98-5665D5A4C792" /><meta name="DC.Relation" scheme="URI" content="GUID-3E341F9F-2635-589B-A59A-B999FE7DF9BE" /><meta name="DC.Relation" scheme="URI" content="GUID-7DB86BF1-0485-5CBA-9554-4C474B0EC1FB" /><meta name="DC.Relation" scheme="URI" content="GUID-A68D1F27-FE7E-503E-B5B6-7BD555B88558" /><meta name="DC.Relation" scheme="URI" content="GUID-786A8188-AB4D-5C65-8BEF-50E45FDBE9A5" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-B10B048F-37FF-53E7-92B9-83F8C197566A" /><meta name="DC.Language" content="en" /><title>Image
Decoding </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_design.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-B10B048F-37FF-53E7-92B9-83F8C197566A">Image
Decoding</h1><div>
<p>This document gives you more information about the Image Decoding functionality. </p>
<div id="GUID-41872C2C-A6EB-446B-AA79-62BAA6B69437"><h3 class="section-title">Purpose</h3> <p>The image decoding class <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> provides
functions to decode images held in descriptors or files from standard formats
for use with devices such as screens, browsers and viewer applications. </p> <p><strong>Required Background</strong> </p> <p>Image decoding features are provided through
Imaging Frameworks and Imaging plugins. The standard formats supported by
the decode plugins are shown in the table in <a href="GUID-88091838-03FC-550F-9A3D-DA70907EF955.html">Imaging
Frameworks Overview</a>. </p> <p><strong>Introduction</strong> </p> <p>The decoding process comprises the following sections: </p> <ul>
<li id="GUID-BE3B993F-3793-55B4-9ADB-9456FE73CA19"><a name="GUID-BE3B993F-3793-55B4-9ADB-9456FE73CA19"><!-- --></a><p> <strong>Creation</strong> - The
creation of the <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> object and any requirements
necessary. </p> </li>
<li id="GUID-D5FE22F6-687F-560D-A336-4F01B5945273"><a name="GUID-D5FE22F6-687F-560D-A336-4F01B5945273"><!-- --></a><p> <strong>Conversion</strong> -
Covers the basic form of image decoding. More advanced features such as progressive
and buffered decoding are described separately. </p> </li>
<li id="GUID-9A4AD0DE-AFCF-5F33-AAC7-007FD9F8A291"><a name="GUID-9A4AD0DE-AFCF-5F33-AAC7-007FD9F8A291"><!-- --></a><p> <strong>Enquiry features</strong> -
Additional features that enable you to retrieve information stored in certain
types of images, for example frame information and comments. </p> </li>
<li id="GUID-643CE012-6C73-5068-A7AD-FDA810FBBFD8"><a name="GUID-643CE012-6C73-5068-A7AD-FDA810FBBFD8"><!-- --></a><p> <strong>Streamed and progressive
decoding</strong> - Reading partial image files and displaying image data before
the entire image is read. </p> </li>
<li id="GUID-E3D6BB50-DBE9-5967-9FAC-B56BCBCCADAC"><a name="GUID-E3D6BB50-DBE9-5967-9FAC-B56BCBCCADAC"><!-- --></a><p> <strong>Buffered decoding</strong> -
The decoding of an image using a buffered input rather than a file or descriptor. </p> </li>
</ul> <p><strong>Setup
and Configuration Requirements</strong> </p> <p>The <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> classes
use synchronous methods to open an image and asynchronous methods to perform
conversions or transformations. The asynchronous operations use the standard
system of taking a pointer to a <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-E0B34F3E-D4C4-3232-B8B1-7DB35B454646.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-E0B34F3E-D4C4-3232-B8B1-7DB35B454646.html"><code class="apiname">TRequestStatus</code></a> object that
is signalled on completion of the requested action. The assumption is that
the client application or the calling DLL holds the <code class="codeph">TRequestStatus</code> values
within active objects. The structure of the active objects is dependent on
the code that uses the Imaging Frameworks and its own requirements, particularly
its internal architecture and how many images are opened simultaneously. </p> <p>In
addition to the use of active objects in the interfacing, many of the Imaging
Frameworks internal functions make extensive use of them to provide asynchronous
behaviour. As with any use of an active object it is necessary to have an
active scheduler in the same thread as the application making use of the object.
The Decoders can also be created so the plugin and framework runs in a separate
thread. This is achieved by setting the <code class="codeph">EOptionAlwaysThread</code> option
when constructing the decoder objects. By running the object in its own thread,
the application is shielded from any latency that can occur during image conversion,
or possibly due to a badly written plugin. </p> </div>
<div id="GUID-6741516A-A0A7-4021-9A5A-6855E4AE9E8B"><h3 class="section-title">Using Image Decoding </h3> <p>The Following tasks are covered
in this tutorial: </p> <ul>
<li id="GUID-085EEC3C-C78B-5FDC-B630-C3A28DF0CA1F"><a name="GUID-085EEC3C-C78B-5FDC-B630-C3A28DF0CA1F"><!-- --></a><p><a href="#GUID-1F8A0DCC-CB95-5245-9ED0-FE4A775152D0">How to create the object during decoding</a> </p> </li>
<li id="GUID-A5E71C36-E811-509B-A547-04F174B7000B"><a name="GUID-A5E71C36-E811-509B-A547-04F174B7000B"><!-- --></a><p><a href="#GUID-7A3F98C2-C86B-5DC4-9F0E-EAE030341325">How to convert encoded data to decoded data</a> </p> </li>
<li id="GUID-D6EDE32F-F011-5191-AD15-AD8FAEFC5C75"><a name="GUID-D6EDE32F-F011-5191-AD15-AD8FAEFC5C75"><!-- --></a><p><a href="#GUID-FF418A2D-436B-515F-B9D1-E0A0C87E7394"> How to retrieve the information stored in certain types of images</a> </p> </li>
<li id="GUID-05966714-BB75-5DB1-86E5-4FE075507C2D"><a name="GUID-05966714-BB75-5DB1-86E5-4FE075507C2D"><!-- --></a><p><a href="#GUID-AA950124-42DE-5A65-B371-7D85F43D71A6">How to perform the streaming and the progressive during decoding</a> </p> </li>
<li id="GUID-3BBA8FBB-FB2E-5774-921E-8BBAC95DF55C"><a name="GUID-3BBA8FBB-FB2E-5774-921E-8BBAC95DF55C"><!-- --></a><p><a href="#GUID-C7FEA8F9-B367-52B1-9D26-84F9E225D17C">How to perform the buffered decoding</a> </p> </li>
</ul> <p id="GUID-1F8A0DCC-CB95-5245-9ED0-FE4A775152D0"><a name="GUID-1F8A0DCC-CB95-5245-9ED0-FE4A775152D0"><!-- --></a><strong>Basic Procedure For Creation</strong> </p> <p>The
high level steps to create the object during decoding are as follows: </p> <ol id="GUID-A8F73379-5277-5ACC-82A4-9199BE24142A">
<li id="GUID-166216C0-5CAA-5FF4-8B40-BB562EEF3C61"><a name="GUID-166216C0-5CAA-5FF4-8B40-BB562EEF3C61"><!-- --></a><p> <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> decodes
images stored in files or in descriptors. The decoder object is owned by the
client and must be deleted once decoding is finished. <code class="codeph">CImageDecoder</code> objects
cannot be reused to decode other images, each image requires its own instance
of the decoder. </p> </li>
<li id="GUID-BB617D39-8A46-5C7F-A28B-7C334F24594C"><a name="GUID-BB617D39-8A46-5C7F-A28B-7C334F24594C"><!-- --></a><p> <code class="codeph">CImageDecoder</code> objects
are created using the <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-00FB83E8-3759-32BE-B6E8-6F04EC60A909"><code class="apiname">CImageDecoder::DataNewL()</code></a> and <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DA07559-7DDC-32A9-9E09-D557348D46DE"><code class="apiname">CImageDecoder::FileNewL()</code></a> factory
functions for images held in descriptors or files respectively. </p> </li>
<li id="GUID-F1D28859-A28F-56EA-8755-25C8FF70BB50"><a name="GUID-F1D28859-A28F-56EA-8755-25C8FF70BB50"><!-- --></a><p>When you create a <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> object,
a suitable plugin must be associated with the image to be decoded. The Imaging
plugin depends on the factory function you use to create the object and what
parameters you specify. There are four alternatives: </p> <ul>
<li id="GUID-A40501AD-3679-5612-AA43-06DB6345C79D"><a name="GUID-A40501AD-3679-5612-AA43-06DB6345C79D"><!-- --></a><p> <strong>MIME type</strong> The
plugin is determined by looking up a specified MIME type against a list of
known MIME type/plugin implementations. Use the following "File" factory function
(or its "Data" equivalent). </p> <pre class="codeblock">static CImageDecoder* FileNewL(RFs&amp; aFs, const TDesC&amp; aSourceFilename, const TDesC8&amp; aMIMEType, const TOptions aOptions = EOptionNone);
</pre> </li>
<li id="GUID-9D96F47A-F784-5252-AAC9-3DDEF2E96764"><a name="GUID-9D96F47A-F784-5252-AAC9-3DDEF2E96764"><!-- --></a><p> <strong>Image type and sub-type</strong> The
plugin is determined by looking up the specified image type and sub-types
against a list of known type/sub-type plugin implementations. Use the following
"File" factory function (or its "Data" equivalent). </p> <pre class="codeblock">static CImageDecoder* FileNewL(RFs&amp; aFs, const TDesC&amp; aSourceFilename, const TOptions aOptions = EOptionNone, const TUid aImageType = KNullUid, const TUid aImageSubType = KNullUid, const TUid aDecoderUid = KNullUid);
</pre> <p> <strong>Note:</strong> For images types that do not have sub-types
use <code class="codeph">KNullUid</code>. </p> </li>
<li id="GUID-D80A799E-E49E-547C-9286-1AB38F8EB819"><a name="GUID-D80A799E-E49E-547C-9286-1AB38F8EB819"><!-- --></a><p> <strong>Implementation UID</strong> The
plugin is determined by looking up its specific UID and the image type and
sub-type. Use the same <code class="codeph">FileNewL()</code> factory function shown
in "Image type and sub-type", but in addition to the type and sub-type parameters,
also specify the plugin UID using <code class="codeph">aDecoderUid</code>. </p> <p> <strong>Note:</strong> Implementation
UID is supported because it is possible to have more than one plugin for a
particular image type. This method is recommended if the application or calling
DLL needs to exploit features of a particular plugin. </p> </li>
<li id="GUID-A08944FA-6BE6-574A-AE00-5F12F5A07F0B"><a name="GUID-A08944FA-6BE6-574A-AE00-5F12F5A07F0B"><!-- --></a><p> <strong>Automatic detection</strong> -
no MIME type, format type/sub-type or UIDs are specified. The plugin analyses
the header information of the specified image. Use the same <code class="codeph">FileNewL()</code> factory
function shown in "Image type and sub-type", but do not specify any values
for <code class="codeph">aImageType</code> <code class="codeph">aImageSubType</code> or <code class="codeph">aDecoderUid</code>. </p> <p>If
a suitable plugin cannot be found, the factory function leaves with <code class="codeph">KErrNotFound</code>.
If a suitable plugin is found, but that plugin cannot interpret the image
data the factory function leaves with <code class="codeph">KErrCorrupt</code>. </p> <p>Note:
Some image formats cannot be automatically detected because they do not contain
sufficient header information, for example, WBMP and OTA images. Under such
circumstances, use one of the other three alternative for opening the image. </p> </li>
</ul> </li>
</ol> <p>It is possible for more than one valid plugin decoder to be available
for a specific image format. If a plugin determined by MIME type or type/sub-type
fails to open an image due to <code class="codeph">KErrCorrupt</code>, it will continue
to try with subsequent valid plugins if available. This mechanism is carried
out in the system and is not visible to the application. If you require a
specific function available within a specific plugin, specify that plugin
using <code class="codeph">aDecoderUid</code>. </p> <p id="GUID-7A3F98C2-C86B-5DC4-9F0E-EAE030341325"><a name="GUID-7A3F98C2-C86B-5DC4-9F0E-EAE030341325"><!-- --></a><strong>Basic Procedure For Conversion </strong> </p> <p>The
high level steps to convert encoded data to decoded data are as follow: </p> <ol id="GUID-495365EB-B53D-5229-AD45-F9700A22F2AB">
<li id="GUID-4B6AEB44-3426-5B83-A12E-755230627D23"><a name="GUID-4B6AEB44-3426-5B83-A12E-755230627D23"><!-- --></a><p>As part of the <code class="codeph">CImageDecoder</code> creation
basic information about the image is pre-read from the image headers. This
information is used to support certain enquiry methods such as <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6506DA99-55E9-3524-BD64-528E145915F4"><code class="apiname">CImageDecoder::FrameCount()</code></a> and <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-7CE85F05-6D58-30F1-87D3-324BFB6131FB"><code class="apiname">CImageDecoder::FrameInfo()</code></a> (For more information about the retrieve information stored in certain types
of images is supplied in <a href="#GUID-FF418A2D-436B-515F-B9D1-E0A0C87E7394">Retrieve
Information features</a>). </p> </li>
<li id="GUID-18D5494C-BECC-52A5-9C51-60A9E560C816"><a name="GUID-18D5494C-BECC-52A5-9C51-60A9E560C816"><!-- --></a><p>You can decode any subset
of individual frames, in any order, and to repeat the decoding if necessary.
To decode an image frame use the asynchronous conversion method <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-8118AC37-471E-3CB6-9F71-4E93507DDE57"><code class="apiname">CImageDecoder::Convert()</code></a>,
as follows. </p> </li>
</ol> <pre class="codeblock">
void Convert(TRequestStatus* aRequestStatus, CFbsBitmap&amp; aDestination, TInt aFrameNumber = 0);

void ContinueConvert(TRequestStatus* aRequestStatus);</pre> <p> <strong> Note:</strong> The
use of <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-F4F5A5F6-03E5-3801-93CC-A023363F35F8"><code class="apiname">CImageDecoder::ContinueConvert()</code></a> is described in <a href="#GUID-AA950124-42DE-5A65-B371-7D85F43D71A6">Streamed
and progressive decoding</a>. </p> <p>There are different type of sub-procedures
which have to be followed before decode conversion, they are: </p> <ul>
<li id="GUID-1F27341A-4A6A-5269-AA61-CBB0FB620258"><a name="GUID-1F27341A-4A6A-5269-AA61-CBB0FB620258"><!-- --></a><p><a href="#GUID-52CAB4D2-BFA9-528C-ADB6-88515893F2B1">Bitmap Masks conversion</a> </p> </li>
<li id="GUID-3537322C-B7E7-502D-A773-294DEC45A6DC"><a name="GUID-3537322C-B7E7-502D-A773-294DEC45A6DC"><!-- --></a><p><a href="#GUID-03A3E6BD-8702-5C0D-8265-F956EC03CD73">Scaling and display modes</a> </p> </li>
<li id="GUID-D11765E3-CD93-5CF2-A530-B7725F742861"><a name="GUID-D11765E3-CD93-5CF2-A530-B7725F742861"><!-- --></a><p><a href="#GUID-9C2E0BFC-61FE-5F83-A78A-C9248C5D6FA3">Animations</a> </p> </li>
<li id="GUID-EA7899D9-F950-514D-9696-072C14116B44"><a name="GUID-EA7899D9-F950-514D-9696-072C14116B44"><!-- --></a><p><a href="#GUID-9BD9C48A-B582-5730-B03F-CF6CB00DF6D1">Background colours </a> </p> </li>
</ul> <p id="GUID-52CAB4D2-BFA9-528C-ADB6-88515893F2B1"><a name="GUID-52CAB4D2-BFA9-528C-ADB6-88515893F2B1"><!-- --></a><strong>Basic Procedure For Bitmap
Masks conversion</strong> </p> <p>The high level steps to Bitmap Masks conversion
are as follows: </p> <ol id="GUID-A330923C-DA1E-55CF-A01C-151CD203D37B">
<li id="GUID-E493B5B2-D8A2-5428-846B-0BA902EAF641"><a name="GUID-E493B5B2-D8A2-5428-846B-0BA902EAF641"><!-- --></a><p>There is a second variant
of the <code class="codeph">Convert()</code> function intended for use when decoding
images with bitmap masks. </p> <pre class="codeblock">
void Convert(TRequestStatus* aRequestStatus, CFbsBitmap&amp; aDestination, CFbsBitmap&amp; aDestinationMask, TInt aFrameNumber = 0);
</pre> </li>
<li id="GUID-1E7DC04E-A101-5C33-B6B5-BE5F83E95801"><a name="GUID-1E7DC04E-A101-5C33-B6B5-BE5F83E95801"><!-- --></a><p>Within the Symbian platform
it is normal to store the bitmap mask separately from the main image data.
Calls such as BitBltMasked() expect this data to be provided
separately. This separation is true for both <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><code class="apiname">CFbsBitmap</code></a> objects
and MBM files. </p> </li>
<li id="GUID-B9CE26DF-AE1C-592F-8C0E-DD0AAD69BF60"><a name="GUID-B9CE26DF-AE1C-592F-8C0E-DD0AAD69BF60"><!-- --></a><p>To determine whether
an image contains a bitmap mask use <code class="codeph">FrameInfo()</code>, the presence
or absence of a mask will be indicated the <code class="codeph">ETransparencyPossible</code> flag. </p> <p>The
following two types of mask are available: </p> <ul>
<li id="GUID-1A03053A-C797-57EF-978E-C25A1D32163A"><a name="GUID-1A03053A-C797-57EF-978E-C25A1D32163A"><!-- --></a><p> <strong>8-bit alpha blend</strong> -
indicated by the <code class="codeph">EAlphaChannel</code> flag of <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-7CE85F05-6D58-30F1-87D3-324BFB6131FB"><code class="apiname">CImageDecoder::FrameInfo()</code></a> <code class="codeph">iFlags</code>.
The destination mask bitmap must be of type <code class="codeph">EGray256</code>. </p> </li>
<li id="GUID-9B51A424-66ED-584F-A3CD-55D575B38FEA"><a name="GUID-9B51A424-66ED-584F-A3CD-55D575B38FEA"><!-- --></a><p> <strong>Simple on/off mask</strong> -
if no <code class="codeph">EAlphaChannel</code> flag is set. The destination bitmap mask
can be either <code class="codeph">EGray2</code> or <code class="codeph">EGray256</code>. </p> </li>
</ul> </li>
</ol> <p> <strong>Note:</strong> Images that contain bitmap masks do not have to have
those masks decoded if they are not required. </p> <p id="GUID-03A3E6BD-8702-5C0D-8265-F956EC03CD73"><a name="GUID-03A3E6BD-8702-5C0D-8265-F956EC03CD73"><!-- --></a><strong>Basic Procedure For Scaling
and display modes</strong> </p> <p>The high level steps to Scale and display are
shown here: </p> <ol id="GUID-DE0D4041-CBBF-5841-BE53-A8F6EA2CDE38">
<li id="GUID-921CCDF6-7346-577E-AEC2-217C82329D44"><a name="GUID-921CCDF6-7346-577E-AEC2-217C82329D44"><!-- --></a><p>Before <code class="codeph">Convert()</code> is
used, the destination <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><code class="apiname">CFbsBitmap</code></a> objects for image data
and bitmap masks are created. The simplest way to do this is to use a 1 to
1 approach, that is, create the <code class="codeph">CFbsBitmap</code> object with the
same properties as the source image. This is achieved by using something similar
to: </p> <pre class="codeblock">iFrameInfo = &amp;imageDecoder-&gt;FrameInfo(FrameNum);

iBitmap-&gt;Create(iFrameInfo-&gt;iOverallSizeInPixels, iFrameInfo-&gt;iFrameDisplayMode );
</pre> </li>
<li id="GUID-B3559310-560A-5671-9560-509F14B729ED"><a name="GUID-B3559310-560A-5671-9560-509F14B729ED"><!-- --></a><p>If the <code class="codeph">ECanDither</code> flag
of <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-7CE85F05-6D58-30F1-87D3-324BFB6131FB"><code class="apiname">CImageDecoder::FrameInfo()</code></a> <code class="codeph">iFlags</code> is
set then the destination display mode can be adjusted. It is recommended that
the window display mode is used as it is more efficient. </p> <p> <strong>Note:</strong> The
mask bitmap must have the same size in pixels as the main image, even though
the display mode is generally different. </p> </li>
<li id="GUID-B517656C-3294-5D3A-92E3-442CAE099FE1"><a name="GUID-B517656C-3294-5D3A-92E3-442CAE099FE1"><!-- --></a><p>The size of the image
bitmap is available via <code class="codeph">FrameInfo()</code> (<code class="codeph">iOverallSizeInPixels</code>).
However, in addition to a direct mapping of the size of an image, ReducedSize() function
can be used to calculate the reduced size of the decoded bitmap based on the
input parameters. </p> </li>
<li id="GUID-52299AC9-377C-5DEB-B16A-BDA0538D91A7"><a name="GUID-52299AC9-377C-5DEB-B16A-BDA0538D91A7"><!-- --></a><p>If the <code class="codeph">EFullyScaleable</code> flag
of <code class="codeph">FrameInfo()</code> <code class="codeph">iFlags</code> is set, you can specify
any size for the <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><code class="apiname">CFbsBitmap</code></a> and the image will be resized
accordingly. </p> </li>
</ol> <p id="GUID-9C2E0BFC-61FE-5F83-A78A-C9248C5D6FA3"><a name="GUID-9C2E0BFC-61FE-5F83-A78A-C9248C5D6FA3"><!-- --></a><strong>Basic Procedure For Animations</strong> </p> <p>The
high level steps to decode a GIF multi-frame image are as follow: </p> <ol id="GUID-C7E99D55-48C9-5329-B07B-28A65AB102D6">
<li id="GUID-53364690-F9D3-5A80-9FAA-2046F8DB80AB"><a name="GUID-53364690-F9D3-5A80-9FAA-2046F8DB80AB"><!-- --></a><p>Included in the <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-7CE85F05-6D58-30F1-87D3-324BFB6131FB"><code class="apiname">CImageDecoder::FrameInfo()</code></a> result
are flags that enable the support of GIF animation. These flags are <code class="codeph">iDelay</code>, <code class="codeph">ELeaveInPlace</code>, <code class="codeph">ERestoreToBackground</code> and <code class="codeph">ERestoreToPrevious</code>. ICL provides these flags to enable
the application to implement the animation; ICL does not provide functions
to display the animation directly. </p> </li>
<li id="GUID-3BAC1045-E210-5B1A-93E9-BB15C9FC1871"><a name="GUID-3BAC1045-E210-5B1A-93E9-BB15C9FC1871"><!-- --></a><p>Processing the information
from these flags will inevitably require a state machine, and additional timers,
within the application. Requirements will vary depending on the architecture
of the client application itself. </p> </li>
</ol> <p id="GUID-9BD9C48A-B582-5730-B03F-CF6CB00DF6D1"><a name="GUID-9BD9C48A-B582-5730-B03F-CF6CB00DF6D1"><!-- --></a><strong>Basic Procedure For Background
colours</strong> </p> <ol id="GUID-2D46054E-1344-5B17-B353-8A68A0C97DB0">
<li id="GUID-41959955-766E-5AAD-AA6D-65C4F99E5581"><a name="GUID-41959955-766E-5AAD-AA6D-65C4F99E5581"><!-- --></a><p>Some image formats contain
background colour information. This is information is presented through <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-7CE85F05-6D58-30F1-87D3-324BFB6131FB"><code class="apiname">CImageDecoder::FrameInfo()</code></a> <code class="codeph">iBackgroundColor</code>. </p> </li>
<li id="GUID-B3419EC0-109F-5A37-9A4F-CD0F7A96FCDC"><a name="GUID-B3419EC0-109F-5A37-9A4F-CD0F7A96FCDC"><!-- --></a><p>If a non-masked image
with background colour is decoded, the colour is included in the image data.
If the decoded image also contains a bitmap mask, then the background colour
will be a component of the mask <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><code class="apiname">CFbsBitmap</code></a> object. Depending
on your application, you may want to choose your own background colour rather
than use the one provided by the source image. </p> </li>
</ol> <p id="GUID-FF418A2D-436B-515F-B9D1-E0A0C87E7394"><a name="GUID-FF418A2D-436B-515F-B9D1-E0A0C87E7394"><!-- --></a><strong>Basic Procedure To Retrieve
Information From An Image</strong> </p> <p>The high level steps to retrieve the
information stored in certain types of images are shown here: </p> <ol id="GUID-2D40722B-5BEA-52ED-B143-A4E85CE8EB22">
<li id="GUID-B40D32A1-CC43-50B8-A873-A6E14C27D165"><a name="GUID-B40D32A1-CC43-50B8-A873-A6E14C27D165"><!-- --></a><p> <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-01F212DD-0A35-3702-948B-1CBFB6675456"><code class="apiname">CImageDecoder::FrameData()</code></a> Provides
access to additional chunks of data within the images, for example, palette
and similar lookup tables, copyright information and other strings. This information
should be used with care, the returned data is merely a reference to the original
data within the <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> object, and is only valid
for the lifetime of the object. </p> </li>
<li id="GUID-875B1CFA-CE86-50D7-BD8A-4E7453EEF35F"><a name="GUID-875B1CFA-CE86-50D7-BD8A-4E7453EEF35F"><!-- --></a><p> <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B237AB64-0A03-3356-AA51-FCFD59E1A513"><code class="apiname">CImageDecoder::NumberOfImageComments()</code></a> and <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-F7CADA2E-4B76-3B23-B5CA-92CD652E9A97"><code class="apiname">CImageDecoder::ImageCommentL()</code></a> Images can have comments embedded in them. These comments are usually either
embedded as a single repository which can be retrieved on an image level,
or multiple repositories attached to individual frames within the image. The
two functions above return the number of comments attached to the entire image
and provide a mechanism for retrieving any of those comments. </p> </li>
<li id="GUID-6854DEC9-4348-56DD-B5E2-47DEE3DC43AE"><a name="GUID-6854DEC9-4348-56DD-B5E2-47DEE3DC43AE"><!-- --></a><p> <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-3057B1A5-9F03-363B-9E84-9CFE2A2892EB"><code class="apiname">CImageDecoder::NumberOfFrameComments()</code></a> and <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-28A8EF22-C0C8-32BB-B9F3-96588F63A321"><code class="apiname">CImageDecoder::FrameCommentL()</code></a> Similar functionality to above, but these functions return the number of
comments attached to individually specified frames and provide a mechanism
for retrieving any of those comments. </p> </li>
<li id="GUID-F51D81A1-61A7-5C1C-B0FB-99B18C1203DC"><a name="GUID-F51D81A1-61A7-5C1C-B0FB-99B18C1203DC"><!-- --></a><p> <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-78BF07BC-5338-3A60-B8BF-47DAFE2CA82C"><code class="apiname">CImageDecoder::FrameInfoStringsLC</code></a> and <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-7B3BDF3B-43BA-3206-AF62-174B7C3AF516"><code class="apiname">CImageDecoder::FrameInfoStringsL()</code></a> Provide a list of data for a specified frame, including data items such
as format, plugin description, size and so on, in a readable format. Although
the property strings can be accessed by name, it is recommended that they
be generally treated as a list of strings. </p> </li>
</ol> <p id="GUID-AA950124-42DE-5A65-B371-7D85F43D71A6"><a name="GUID-AA950124-42DE-5A65-B371-7D85F43D71A6"><!-- --></a><strong>Basic Procedure Streamed
and Progressive Decoding</strong> </p> <p> <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> includes
facilities to support the simultaneous decoding and display of images as they
are being loaded. The decoder does not wait for the entire image to be loaded
before processing it, rather it begins as soon as possible, stops when it
runs out of data and then carries on when more data is available. </p> <p>The
high level steps to perform the streaming and the progressive during decoding
are shown here: </p> <ol id="GUID-0E29E833-4435-5E55-908F-938A13473B79">
<li id="GUID-CE64D3C8-8923-5BAF-AF29-9BA6470008F8"><a name="GUID-CE64D3C8-8923-5BAF-AF29-9BA6470008F8"><!-- --></a><p>If there is insufficient
data to work out the image format (plugin decoder to use) <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DA07559-7DDC-32A9-9E09-D557348D46DE"><code class="apiname">CImageDecoder::FileNewL()</code></a> (or
its "Data" equivalent) leaves with <code class="codeph">KErrUnderflow</code>. This is
only applicable to instances where automatic detection of the plugin decoder
is used. For more information see, "Automatic detection" in <a href="#GUID-1F8A0DCC-CB95-5245-9ED0-FE4A775152D0">Creation</a>. </p> </li>
<li id="GUID-23175979-940A-507D-B478-0C4ACB5F9071"><a name="GUID-23175979-940A-507D-B478-0C4ACB5F9071"><!-- --></a><p>As soon as the correct
plugin decoder has been determined it is opened and whatever addition image
data available is scanned. The plugin decoder continues to decode image data
as it arrives, updating <code class="codeph">FrameCount()</code> whenever it becomes
aware of a new frame within the data. The internal flag <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-26084926-42C1-38FC-9F30-E1801AE5167D"><code class="apiname">CImageDecoder::IsHeaderProcessingComplete()</code></a> is
maintained at <code class="codeph">EFalse</code> until the entire image has been loaded. </p> </li>
<li id="GUID-75959B88-7CE2-598E-9F83-EC0189BD2F6C"><a name="GUID-75959B88-7CE2-598E-9F83-EC0189BD2F6C"><!-- --></a><p>Frames can be decoded
before the entire image is loaded, but the frame to be decoded must be at
least partially loaded. If <code class="codeph">IsHeaderProcessingComplete()</code> is
set to <code class="codeph">EFalse</code> and <code class="codeph">FrameCount()</code> is equal
to or less than the frame to decode, the application must wait for the relevant
frame to load. In such circumstances a call to <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-A74CEA6D-ED47-3EA4-8917-FEE4B51B7639"><code class="apiname">CImageDecoder::ContinueProcessingHeadersL()</code></a> should
be made that scans for any further headers. <code class="codeph">FrameCount()</code> and <code class="codeph">IsHeaderProcessingComplete()</code> should
then be recalled to determine if the frame has arrived. </p> </li>
<li id="GUID-C390495B-840E-541B-A0C5-061D3706AD8A"><a name="GUID-C390495B-840E-541B-A0C5-061D3706AD8A"><!-- --></a><p>Once <code class="codeph">FrameCount()</code> is
greater than the frame the application wants to decode, it is possible to
start to decoding the frame using <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-8118AC37-471E-3CB6-9F71-4E93507DDE57"><code class="apiname">CImageDecoder::Convert()</code></a>.
Frame headers and their associated data do not always follow each other in
some image formats. This has the implication that although <code class="codeph">FrameCount()</code> has
indicated that the frame is available, it may not yet be fully loaded. Under
such circumstances as much decoding as possible is undertaken, and <code class="codeph">Convert()</code> then
completes with the error code <code class="codeph">KErrUnderflow</code>. If the <code class="codeph">EPartialDecodeInvalid</code> flag
(from <code class="codeph">FrameInfo()</code>) is not set, the partially decoded image
can be displayed - for some image formats, a partially decoded image is not
generally usable, but this facility is supported by most known formats. Obviously,
if all of the image is present, <code class="codeph">Convert()</code> completes with <code class="codeph">KErrNone</code> as
normal. </p> </li>
<li id="GUID-44864401-5DB5-56A5-BE6D-5B8B4570CCBF"><a name="GUID-44864401-5DB5-56A5-BE6D-5B8B4570CCBF"><!-- --></a><p>Where only a partial
conversion has been completed, <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-F4F5A5F6-03E5-3801-93CC-A023363F35F8"><code class="apiname">CImageDecoder::ContinueConvert()</code></a> should
be used to continue converting when new data arrives. <code class="codeph">ContinueConvert()</code> continues
to convert the frame data where the previous call left off. This function
should continue to be called until it returns the error code <code class="codeph">KErrNone</code> rather
than <code class="codeph">KErrUnderflow</code>. </p> <p>Note: The <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><code class="apiname">CFbsBitmap</code></a> must
never be resized during a conversion session using <code class="codeph">ContinueConvert()</code>,
if resizing does occur, a panic will be raised by the function. If resizing
or any other parameter changes need to be made to the <code class="codeph">CFbsBitmap</code>,
frame decoding should be restarted by using <code class="codeph">Convert()</code> rather
than trying to continue an existing conversion session. </p> </li>
</ol> <p>There is no explicit decoder call to say "all of the data is now
present". This could be done via inference, continuously checking <code class="codeph">IsHeaderProcessingComplete()</code> until
it returns <code class="codeph">ETrue</code>. However, this is not advisable as it is
possible that <code class="codeph">IsHeaderProcessingComplete()</code> could continue
to return <code class="codeph">EFalse</code> even after the application has finished
sending image data. Your state machine should be written so that it takes
this possibility into account. </p> <p id="GUID-C7FEA8F9-B367-52B1-9D26-84F9E225D17C"><a name="GUID-C7FEA8F9-B367-52B1-9D26-84F9E225D17C"><!-- --></a><strong>Basic Procedure For Buffered
Decoding</strong> </p> <p> CBufferedImageDecoder is a wrapper
that encapsulates not only a <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> but also the
descriptor used to store the image, and in some circumstances can replace
the use of <code class="codeph">CImageDecoder</code> itself. CBufferedImageDecoder can
always be created, even if there is no data available at the time of creation.
Another key feature of <code class="codeph">CBufferedImageDecoder</code> is that it can
be reused to decode multiple images. </p> <p>The high level steps to perform
the buffered decoding are shown here: </p> <ol id="GUID-0EEA3303-59C3-5326-8E10-3C54BE69B336">
<li id="GUID-8749D5E2-2E9D-578B-A02C-C4C1309E2AC5"><a name="GUID-8749D5E2-2E9D-578B-A02C-C4C1309E2AC5"><!-- --></a><p>The decoder is created
using the CBufferedImageDecoder::NewL() factory function,
and the decoding process is started with one of the two CBufferedImageDecoder::OpenL() calls,
specifying either MIME-type or image type/sub-type and UID, which are similar
to <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-00FB83E8-3759-32BE-B6E8-6F04EC60A909"><code class="apiname">CImageDecoder::DataNewL()</code></a>. If not enough data is available
to create an internal decoder a call to CBufferedImageDecoder::ValidDecoder() returns <code class="codeph">EFalse</code>.
The decoder keeps an internal copy of the data provided so the client can
discard its own copy. </p> <p> <strong>Warning:</strong> The decoding and enquiry functions
must not be used until an internal decoder has been created, otherwise calls
will panic with <code class="codeph">EDecoderNotCreated</code>. </p> </li>
<li id="GUID-A1DD251D-D1B2-57EE-9A2D-94AE75DBA35B"><a name="GUID-A1DD251D-D1B2-57EE-9A2D-94AE75DBA35B"><!-- --></a><p>Additional data can
be supplied to the decoder, when it becomes available, by using CBufferedImageDecoder::AppendDataL() and CBufferedImageDecoder::ContinueOpenL(), which will copy the data and try to find an appropriate plugin. This step
should be repeated until enough data is available to create the internal decoder,
indicated by <code class="codeph">ValidDecoder()</code> returning <code class="codeph">ETrue</code>. <code class="codeph">OpenL()</code> and <code class="codeph">ContinueOpenL()</code> will
leave with <code class="codeph">KErrCorrupt</code> if a suitable decoder is found, but
that decoder was unable to interpret the supplied image data. </p> <p>Note:
As with <code class="codeph">OpenL()</code>, data provided by <code class="codeph">AppendDataL()</code> is
kept in an internal buffer by the decoder so the client can discard its own
copy. </p> </li>
<li id="GUID-E4E67E99-0D9A-5CA9-8FE3-6A32A36C3F42"><a name="GUID-E4E67E99-0D9A-5CA9-8FE3-6A32A36C3F42"><!-- --></a><p>The process for decoding
the image header and frames are the same as for <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html"><code class="apiname">CImageDecoder</code></a> with <code class="codeph">IsHeaderProcessingComplete()</code>, <code class="codeph">FrameCount()</code>, <code class="codeph">Convert()</code> and <code class="codeph">ContinueConvert()</code> calls
except that the data is not appended to a descriptor, but supplied to the
decoder with <code class="codeph">AppendDataL()</code>. </p> </li>
<li id="GUID-E40CF367-2601-5B9F-9E20-34CD8F2754EB"><a name="GUID-E40CF367-2601-5B9F-9E20-34CD8F2754EB"><!-- --></a><p>The decoder can be reused
by calling a CBufferedImageDecoder::Reset(), which destroys
the internal data buffer and decoder. A new decoder plugin can then be started
using <code class="codeph">OpenL()</code>. </p> </li>
</ol> </div>
</div><h3>Related concepts</h3><ul><li><a href="GUID-88091838-03FC-550F-9A3D-DA70907EF955.html">Imaging Frameworks
overview</a></li><li><a href="GUID-3D9C4B45-EEA0-581C-A9E5-8B2535014930.html">Image Conversion
Overview</a></li><li><a href="GUID-6DC34798-86CE-537D-B3B8-9A94FF77B283.html">Image Encoding
Tutorial</a></li><li><a href="GUID-A825B62E-B5F6-5FDD-B267-E47103D57FD8.html">Guide to
Symbian supplied Codecs </a></li></ul></div></div><div class="footer"><p class="metadata">Last updated April 14th, 2010</p><hr /><div class="copy">© Nokia 2011.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-B10B048F-37FF-53E7-92B9-83F8C197566A.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 06:13:30 GMT -->
</html>