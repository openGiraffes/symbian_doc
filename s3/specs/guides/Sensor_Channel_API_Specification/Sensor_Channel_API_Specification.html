<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <!-- Generated by Xbuild version: 5.0.22 -->
 
<!-- Mirrored from devlib.symbian.slions.net/s3/specs/guides/Sensor_Channel_API_Specification/Sensor_Channel_API_Specification.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:33:08 GMT -->
<head>
  <title>
   Sensor Channel API Specification in devicesrv package
  </title>
  <link href="../../../a_stock/css/arch_sdl.css" rel="stylesheet" type="text/css" />
  <?php
	include_once ($_SERVER["DOCUMENT_ROOT"]. '/includes/skin_constants.php');
	include_once (CURRENT_SKIN_PATH.'/sdl_head.html');
	???>
 </head>
 <body id="swad">
  <?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ???>
  <div id="main_content">
   <table width="100%" cellpadding="0" cellspacing="0" border="0">
    <tr>
     <td valign="top" width="100%">
      <div id="main_content_txt">
       <div class="main_content_padding">
        <div id="main">
         <div id="authoredContent">
          <div class="section">
           <a name="Sensor_Channel_API_Specification">
           </a>
           <h1>
            Sensor API Specification Document
           </h1>
           <p>
            <em>
             Changes in Sensor API documentation
            </em>
           </p>
           <table class="TableWrap" border="1" cellpadding="1" cellspacing="0">
            <tr valign="top">
             <th>
              1.0
             </th>
             <th>
              29.06.2007
             </th>
             <th>
              Approved
             </th>
             <th>
             </th>
            </tr>
           </table>
           <p>
            <em>
             Changes in Sensor Channel API documentation
            </em>
           </p>
           <table class="TableWrap" border="1" cellpadding="1" cellspacing="0">
            <tr valign="top">
             <th>
              1.0
             </th>
             <th>
              First version
             </th>
            </tr>
           </table>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2eContents">
            </a>
            <h2>
             Contents
            </h2>
            <ul>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2eChanges">
               Changes
              </a>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic1" title="Sensor API provides the clients with the access to the data provided by various sensors of the device.">
               Purpose
              </a>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic1%2e1" title="This API is valid for all platforms running on Symbian OS v9.3 or later.">
               Constraints
              </a>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic1%2e2" title="This API is an SDK API and was first published in S60 5th Edition.">
               Classification and release information
              </a>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic2">
               API description
              </a>
              <ul>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic2%2e1" title="Sensor channel data listening related use cases: Finding, opening and closing a channel Listening channel data Listening channel changes">
                 Use cases
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic2%2e2" title="Channel finder CSensrvChannelFinder provides interfaces to search and find sensor channels that the system provides. The client can listen if new channels are installed to the system via the MSensrvChannelListener callback interface.">
                 API class structure
                </a>
               </li>
              </ul>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3" title="To use a sensor channel, the client must find a channel and open it. The CSensrvChannelFinder class provides functionality to find channels. The CSensrvChannel class provides functionality to open and control channels.">
               Using Sensor API
              </a>
              <ul>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e1" title="The following example shows how to find, open and close a double tapping channel. An instance of CSensrvChannelFinder is created to be able to find channels. The found channels are stored to the RSensrvChannelInfoList type of object. All double tapping channels provided by the device are queried by setting the channel type as KSensrvChannelTypeIdAccelerometerDoubleTappingData to the TSensrvChannelInfo object which is used as search criteria. After calling the FindChannelsL() method channelInfoList contains all the found double tapping channels. If there are several found channels the client can select the correct one by examining the content of channel information objects inside channelInfoList.">
                 Finding, opening and closing a channel
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e2" title="The channel must be opened before starting to listen to channel data. The following example shows how to start listening to a double tapping channel and receive data from it. Channel data is received into the receiving buffer and it can be read using the GetData() method. When new data is available in the receiving buffer, a DataReceived() notification is delivered via the data listener callback interface MSensrvDataListener.">
                 Listening channel data
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e3" title="The channel finder CSensrvChannelFinder provides functionality to listen if new channels are installed to the system or old channels are removed. Listening is started and stopped with the SetChannelListenerL() method. When channel change occurs, a ChannelChangeDetected() notification is delivered via the channel listener callback interface MSensrvChannelListener. There is one restriction on the ChannelChangeDetected() notification: If sensor changes the existing channel registration there must be an open channel to that sensor to prevent sensor driver unloading. In practise, this means that at least one channel from this sensor must have a client to keep the channel open and sensor driver loaded. If the sensor driver is unloaded while new channels become available it cannot notify new channels until some existing channel opening causes sensor driver to be reloaded.">
                 Listening channel changes
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e4" title="The channel must be opened before accessing its properties. The channel properties are capsulated to the TSensrvProperty class and can be queried with the GetPropertyL() method. The following example shows how to check accuracy of the channel. GetPropertyL() leaves if the channel does not support the Accuracy property. Leave also occurs if the Accuracy property is defined as channel item property, i.e. item index must point to valid channel item index e.g. TSensrvAccelerometerAxisData::iAxisX.">
                 Getting channel properties
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e5" title="The channel must be opened before accessing its properties. Channel properties can be changed with the SetProperty() method. In the following example the x-axis of accelerometer channel is deactivated. The axis active property KSensrvPropIdAxisActive with item index is first got with the GetPropertyL() method. If the axis is active it is deactivated by setting a new value to the previously got property. Updated property is set with the SetProperty() method.">
                 Setting channel properties
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e51" title="A property which defines multiple discrete values inside one property ID is called an array property. Array properties can be identified with array index which can be queried from property with the GetArrayIndex() method. For array properties the array index is something else than ESensrvSingleProperty. An example of array property is illustrated in the KSensrvPropIdDataRate property documentation in the sensorgeneralproperties.h file.">
                 Array properties
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e52" title="Value of channel data item can represent the actual value of the measured quantity, or the channel data item can represent relative value which is scaled to between maximum and minimum value of the measured quantity. The KSensrvPropIdChannelDataFormat property defines if channel data items are in scaled format. For scaled data items the KSensrvPropIdScaledRange property defines range for the data item value and the KSensrvPropIdMeasureRange property defines range for the measured quantity.">
                 Scaling channel data
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e6" title="The channel must be opened before listening to channel property changes. The client can use the property listener to get notifications about changed properties. If the client itself changes a property value, no notification is received. Property changes listening is started and stopped with the SetPropertyListenerL() method. When property change occurs, a PropertyChanged() notification is delivered via the property listener callback interface MSensrvPropertyListener.">
                 Listening channel property changes
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e7" title="The channel must be opened before listening to channel data with condition. The following example shows how to start listening to double taps coming from the x-axis direction. When the condition is met, a ConditionMet() notification is delivered via the data listener callback interface MSensrvChannelConditionListener.">
                 Listening channel data with condition
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e8" title="The leave mechanism and return values are used to indicate errors. Normal Symbian error handling practises should be used, including e.g. using cleanup stack and the TRAP harness. Listener callback interfaces (MSensrvDataListener, MSensrvPropertyListener, MSensrvChannelConditionListener and MSensrvChannelListener) offer a callback method for informing error during listening.">
                 Error handling
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e9" title="The Sensor Channel API memory overhead depends on the channel's data rate and/or size of the data in the receiving buffer. High data rate with small data receiving buffer causes increased interprocess communication. On the other hand, big data receiving buffer reserves more memory. See example from Section Listening channel data.">
                 Memory overhead
                </a>
               </li>
              </ul>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic4">
               Glossary
              </a>
              <ul>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic4%2e1" title="None.">
                 Abbreviations
                </a>
               </li>
               <li>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic4%2e2">
                 Definitions
                </a>
               </li>
              </ul>
             </li>
             <li>
              <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic" title="None.">
               References
              </a>
             </li>
            </ul>
           </div>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2eChanges">
           </a>
           <h1>
            Changes
           </h1>
           <p>
            <em>
            </em>
           </p>
           <table class="TableWrap" border="1" cellpadding="1" cellspacing="0">
            <tr valign="top">
             <th>
              First release.
             </th>
             <th>
             </th>
             <th>
             </th>
            </tr>
           </table>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic1">
           </a>
           <h1>
            Purpose
           </h1>
           <p>
            Sensor API provides the clients with the access to the data provided
by various sensors of the device.
           </p>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic1%2e1">
           </a>
           <h1>
            Constraints
           </h1>
           <p>
            This API is valid for all platforms running on Symbian OS v9.3
or later.
           </p>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic1%2e2">
           </a>
           <h1>
            Classification and release information
           </h1>
           <p>
            This API is an SDK API and was first published in S60 5th Edition.
           </p>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic2">
           </a>
           <h1>
            API description
           </h1>
           <p>
           </p>
           <p>
            Sensor API consist of two parts: sensor channel API and sensor
definitions API. Sensor channel API defines the basic functionality
of and utilities of sensor API. Sensor definitions API defines the
features of different sensors. Sensor API is a library API providing
methods to listen data provided by sensor channels. Sensor channels
may also support condition listening to get notified when some limit
is met for a channel. Sensor channels are configured with properties
such as data rate.
           </p>
           <p>
            Sensor channel measuring the acceleration of the device, three
dimensional Cartesian coordinate system is used to illustrate direction
of the acceleration, see the figure below. The x- and y- axes defines
a plane where z-axis direction is perpendicular to the xy plane. When
a phone is moving along an axis, the acceleration is positive if movement
is towards positive direction and negative if movement is on negative
direction. E.g. when a phone is moving along x-axis to the direction
of -x, the acceleration is negative.
           </p>
           <p>
            <div class="Figure">
             <p class="Image">
              <a name="Three-dimensional Cartesian coordinate s...">
               <img src="images/Sensor_API_coordinate_system.png" alt="Three-dimensional Cartesian coordinate s..." border="0" />
              </a>
             </p>
             <br clear="all" />
             <p class="Caption">
              Three-dimensional Cartesian coordinate system with z-axis pointing
away from the phone display.
             </p>
            </div>
           </p>
           <p>
            The orientation of a phone is illustrated with six basic orientations,
see the figure below. In display up and display down orientation the
gravitation is along the y-axis. In phone left side up and phone right
side up orientation the gravitation is along the x-axis. In display
upwards and display downwards orientation the gravitation is along
the z-axis.
           </p>
           <p>
            <div class="Figure">
             <p class="Image">
              <a name="Six basic orientations of a phone">
               <img src="images/Sensor_API_orientation.png" alt="Six basic orientations of a phone" border="0" />
              </a>
             </p>
             <br clear="all" />
             <p class="Caption">
              Six basic orientations of a phone
             </p>
            </div>
           </p>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic2%2e1">
            </a>
            <h2>
             Use cases
            </h2>
            <p>
             Sensor channel data listening related use cases:
             <ul>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e1" title="The following example shows how to find, open and close a double tapping channel. An instance of CSensrvChannelFinder is created to be able to find channels. The found channels are stored to the RSensrvChannelInfoList type of object. All double tapping channels provided by the device are queried by setting the channel type as KSensrvChannelTypeIdAccelerometerDoubleTappingData to the TSensrvChannelInfo object which is used as search criteria. After calling the FindChannelsL() method channelInfoList contains all the found double tapping channels. If there are several found channels the client can select the correct one by examining the content of channel information objects inside channelInfoList.">
                 Finding, opening and closing a channel
                </a>
               </p>
              </li>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e2" title="The channel must be opened before starting to listen to channel data. The following example shows how to start listening to a double tapping channel and receive data from it. Channel data is received into the receiving buffer and it can be read using the GetData() method. When new data is available in the receiving buffer, a DataReceived() notification is delivered via the data listener callback interface MSensrvDataListener.">
                 Listening channel data
                </a>
               </p>
              </li>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e3" title="The channel finder CSensrvChannelFinder provides functionality to listen if new channels are installed to the system or old channels are removed. Listening is started and stopped with the SetChannelListenerL() method. When channel change occurs, a ChannelChangeDetected() notification is delivered via the channel listener callback interface MSensrvChannelListener. There is one restriction on the ChannelChangeDetected() notification: If sensor changes the existing channel registration there must be an open channel to that sensor to prevent sensor driver unloading. In practise, this means that at least one channel from this sensor must have a client to keep the channel open and sensor driver loaded. If the sensor driver is unloaded while new channels become available it cannot notify new channels until some existing channel opening causes sensor driver to be reloaded.">
                 Listening channel changes
                </a>
               </p>
              </li>
             </ul>
            </p>
            <p>
             Sensor channel properties related use cases:
             <ul>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e4" title="The channel must be opened before accessing its properties. The channel properties are capsulated to the TSensrvProperty class and can be queried with the GetPropertyL() method. The following example shows how to check accuracy of the channel. GetPropertyL() leaves if the channel does not support the Accuracy property. Leave also occurs if the Accuracy property is defined as channel item property, i.e. item index must point to valid channel item index e.g. TSensrvAccelerometerAxisData::iAxisX.">
                 Getting channel properties
                </a>
               </p>
              </li>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e5" title="The channel must be opened before accessing its properties. Channel properties can be changed with the SetProperty() method. In the following example the x-axis of accelerometer channel is deactivated. The axis active property KSensrvPropIdAxisActive with item index is first got with the GetPropertyL() method. If the axis is active it is deactivated by setting a new value to the previously got property. Updated property is set with the SetProperty() method.">
                 Setting channel properties
                </a>
               </p>
              </li>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e51" title="A property which defines multiple discrete values inside one property ID is called an array property. Array properties can be identified with array index which can be queried from property with the GetArrayIndex() method. For array properties the array index is something else than ESensrvSingleProperty. An example of array property is illustrated in the KSensrvPropIdDataRate property documentation in the sensorgeneralproperties.h file.">
                 Array properties
                </a>
               </p>
              </li>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e52" title="Value of channel data item can represent the actual value of the measured quantity, or the channel data item can represent relative value which is scaled to between maximum and minimum value of the measured quantity. The KSensrvPropIdChannelDataFormat property defines if channel data items are in scaled format. For scaled data items the KSensrvPropIdScaledRange property defines range for the data item value and the KSensrvPropIdMeasureRange property defines range for the measured quantity.">
                 Scaling channel data
                </a>
               </p>
              </li>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e6" title="The channel must be opened before listening to channel property changes. The client can use the property listener to get notifications about changed properties. If the client itself changes a property value, no notification is received. Property changes listening is started and stopped with the SetPropertyListenerL() method. When property change occurs, a PropertyChanged() notification is delivered via the property listener callback interface MSensrvPropertyListener.">
                 Listening channel property changes
                </a>
               </p>
              </li>
             </ul>
            </p>
            <p>
             Sensor channel conditions related use cases:
             <ul>
              <li>
               <p>
                <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e7" title="The channel must be opened before listening to channel data with condition. The following example shows how to start listening to double taps coming from the x-axis direction. When the condition is met, a ConditionMet() notification is delivered via the data listener callback interface MSensrvChannelConditionListener.">
                 Listening channel data with condition
                </a>
               </p>
              </li>
             </ul>
            </p>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic2%2e2">
            </a>
            <h2>
             API class structure
            </h2>
            <p>
             Channel finder
             <code class="ApiItem">
              CSensrvChannelFinder
             </code>
             provides interfaces
to search and find sensor channels that the system provides. The client
can listen if new channels are installed to the system via the
             <code class="ApiItem">
              MSensrvChannelListener
             </code>
             callback interface.
            </p>
            <p>
            </p>
            <p>
             Sensor channel
             <code class="ApiItem">
              CSensrvChannel
             </code>
             provides methods
to open and control a sensor channel. The class provides operations
to:
            </p>
            <ul>
             <li>
              <p>
              </p>
              <p>
               Start and stop channel data listening. Operation for getting
the new data is also provided. New data availability is informed via
the
               <code class="ApiItem">
                MSensrvDataListener
               </code>
               callback interface.
              </p>
             </li>
             <li>
              <p>
               Start and stop channel condition listening. The condition reached
is informed via the
               <code class="ApiItem">
                MSensrvChannelConditionListener
               </code>
               callback interface. Conditions are encapsulated to the classes
               <code class="ApiItem">
                CSensrvChannelConditionSet
               </code>
               and
               <code class="ApiItem">
                CSensrvChannelCondition
               </code>
               .
              </p>
             </li>
             <li>
              <p>
               Set and get channel properties. Property changes can be listened
via the
               <code class="ApiItem">
                MSensrvPropertyListener
               </code>
               callback interface.
              </p>
             </li>
            </ul>
            <p>
            </p>
            <p>
             <div class="Figure">
              <p class="Image">
               <a name="Sensor API class structure">
                <img src="images/Sensor_API_class_structure.png" alt="Sensor API class structure" border="0" />
               </a>
              </p>
              <br clear="all" />
              <p class="Caption">
               Sensor API class structure
              </p>
             </div>
            </p>
            <p>
             The client creates an instance of C classes using the standard
             <code class="ApiItem">
              NewL
             </code>
             two phase construction. If a callback interface is
required the client must implement the appropriate M class and provide
its pointer when required.
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               CSensrvChannel
              </code>
             </li>
             <li>
              <code class="ApiItem">
               CSensrvChannelCondition
              </code>
             </li>
             <li>
              <code class="ApiItem">
               CSensrvChannelConditionSet
              </code>
             </li>
             <li>
              <code class="ApiItem">
               CSensrvChannelFinder
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvChannelConditionListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvChannelListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvDataListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvPropertyListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               NewL
              </code>
             </li>
            </ul>
           </div>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic3">
           </a>
           <h1>
            Using Sensor API
           </h1>
           <p>
            To use a sensor channel, the client must find a channel and open
it. The
            <code class="ApiItem">
             CSensrvChannelFinder
            </code>
            class provides functionality
to find channels. The
            <code class="ApiItem">
             CSensrvChannel
            </code>
            class provides
functionality to open and control channels.
           </p>
           <p>
            The supported sensor channels are declared in the sensor definitions
API. The amount of implemented channels may vary between products.
For each channel a channel type ID constant and a short description
is provided. Double tapping channel declaration is shown below as
an example. There are two types of channels: raw data channels and
event channels. Raw data channels provide data continuously and event
channels provide data when an appropriate event occurs. Data type
describes what type of data the channel provides.
           </p>
           <p>
            <pre>
             <code class="cpp">
              &nbsp;&nbsp;&nbsp;&nbsp;/**
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Double&nbsp;tapping&nbsp;event&nbsp;channel&nbsp;type
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Event
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Datatype:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSensrvTappingData
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Description:&nbsp;&nbsp;&nbsp;Double&nbsp;tapping&nbsp;events&nbsp;
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*/
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;TSensrvChannelTypeId&nbsp;KSensrvChannelTypeIdAccelerometerDoubleTappingData&nbsp;=&nbsp;0x10205081;
             </code>
            </pre>
           </p>
           <p>
            Channel data types are declared in each sensors header file. Channel
data type is the type of an object which a sensor channel provides.
Double tapping channel data type declaration is shown below.
           </p>
           <p>
            <pre>
             <code class="cpp">
              &nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;TSensrvTappingData&nbsp;
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;public:
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Channel&nbsp;data&nbsp;type&nbsp;Id&nbsp;number
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;const&nbsp;TSensrvChannelDataTypeId&nbsp;KDataTypeId&nbsp;=&nbsp;0x1020507F;
              <br />
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Channel&nbsp;data&nbsp;type&nbsp;enumerations
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum&nbsp;TSensrvAccelerometerAxisDataIndexes
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iTimeStamp&nbsp;=&nbsp;0,
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDirection
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
              <br />
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;public:
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Item&nbsp;name:&nbsp;&nbsp;&nbsp;Sampling&nbsp;time.
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Item&nbsp;Index:&nbsp;&nbsp;0
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Conditions:&nbsp;&nbsp;None
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Description:&nbsp;Timestamp&nbsp;for&nbsp;a&nbsp;sample.
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTime&nbsp;iTimeStamp;&nbsp;&nbsp;&nbsp;&nbsp;
              <br />
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Item&nbsp;name:&nbsp;&nbsp;&nbsp;Tapping&nbsp;direction&nbsp;bitmask
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Item&nbsp;Index:&nbsp;&nbsp;1
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Conditions:&nbsp;&nbsp;Binary
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Description:&nbsp;Direction&nbsp;bitmask&nbsp;of&nbsp;the&nbsp;tapping&nbsp;event.
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See&nbsp;constant&nbsp;definitions&nbsp;above.
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TUint32&nbsp;iDirection;
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
             </code>
            </pre>
           </p>
           <p>
            Channel data type ID (e.g.
            <code class="ApiItem">
             TSensrvTappingData::KDataTypeId
            </code>
            ) is a unique ID for each data type to be able to separate data types
from each other. Data type ID is used in
            <code class="ApiItem">
             TSensrvChannelInfo
            </code>
            to define data type used in a channel.
           </p>
           <p>
            Channel data type index (e.g.
            <code class="ApiItem">
             TSensrvTappingData::iDirection
            </code>
            ) is used to point to an attribute inside a data type. Attributes
of the
            <code class="ApiItem">
             TSensrvTappingData
            </code>
            class are
            <code class="ApiItem">
             iTimeStamp
            </code>
            and
            <code class="ApiItem">
             iDirection
            </code>
            . Channel data type index is used
in:
           </p>
           <ul>
            <li>
             <p>
              properties (
              <code class="ApiItem">
               TSensrvProperty
              </code>
              ) if a property scope
is a channel item
             </p>
            </li>
            <li>
             <p>
              conditions (
              <code class="ApiItem">
               CSensrvChannelCondition
              </code>
              ) to identify
which attribute is used as a condition
             </p>
            </li>
           </ul>
           <p>
            Channel properties are declared in the
            <i>
             sensrvgeneralproperties.h
            </i>
            and sensor specific files. General properties for all channel types
are declared in the
            <i>
             sensrvgeneralproperties.h
            </i>
            file and accelerometer
specific properties are declared in the
            <i>
             sensrvaccelerometersensor.h
            </i>
            file. For each property, a property ID constant and a short description
are provided. Property type specifies the type of the value the property
contains, it can be
            <code class="ApiItem">
             TInt
            </code>
            ,
            <code class="ApiItem">
             TReal
            </code>
            or
            <code class="ApiItem">
             TBuf
            </code>
            . Property scope can be defined for:
           </p>
           <ul>
            <li>
             <p>
              a channel
             </p>
            </li>
            <li>
             <p>
              a specific attribute inside channel data
             </p>
            </li>
            <li>
             <p>
              a sensor related to a channel.
             </p>
            </li>
           </ul>
           <p>
            A mandatory section specifies if the property is required for all
channels. Capability section specifies the required capabilities to
change value of the property. Accuracy property is shown below as
an example.
           </p>
           <p>
            <pre>
             <code class="cpp">
              &nbsp;&nbsp;&nbsp;&nbsp;/**
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accuracy&nbsp;of&nbsp;the&nbsp;channel&nbsp;data
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TReal
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Scope:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel&nbsp;item&nbsp;property
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Mandatory:&nbsp;&nbsp;&nbsp;&nbsp;No
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Capability:&nbsp;&nbsp;&nbsp;None
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;-&nbsp;Description:&nbsp;&nbsp;Returns&nbsp;the&nbsp;accuracy&nbsp;of&nbsp;this&nbsp;channel&nbsp;of&nbsp;the&nbsp;sensor&nbsp;as&nbsp;a
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;percentage&nbsp;of&nbsp;reading&nbsp;(=data&nbsp;value).
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;*/
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;TSensrvPropertyId&nbsp;KSensrvPropIdChannelAccuracy&nbsp;=&nbsp;0x000000008;
             </code>
            </pre>
           </p>
           <p>
            Example content of the Accuracy property is shown below. Properties
which are defined as channel data item specific, item index defines
the data item which the property is related to. If the property is
sensor or channel property, item index is
            <code class="ApiItem">
             KSensrvItemIndexNone
            </code>
            . Array index is explained in chapter
            <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e51" title="A property which defines multiple discrete values inside one property ID is called an array property. Array properties can be identified with array index which can be queried from property with the GetArrayIndex() method. For array properties the array index is something else than ESensrvSingleProperty. An example of array property is illustrated in the KSensrvPropIdDataRate property documentation in the sensorgeneralproperties.h file.">
             Array properties
            </a>
            .
           </p>
           <p>
            <pre>
             <code class="cpp">
              &nbsp;&nbsp;&nbsp;&nbsp;iPropertyId&nbsp;&nbsp;&nbsp;=&nbsp;KSensrvPropIdChannelAccuracy
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iItemIndex&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;KSensrvItemIndexNone
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iArrayIndex&nbsp;&nbsp;&nbsp;=&nbsp;ESensrvSingleProperty
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iRealValue&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;10.0
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iReadOnly&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;ETrue
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iRealValueMax&nbsp;=&nbsp;n/a
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iRealValueMin&nbsp;=&nbsp;n/a
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iPropertyType&nbsp;=&nbsp;ESensrvRealProperty
              <br />
              &nbsp;&nbsp;&nbsp;&nbsp;iSecurityInfo&nbsp;=&nbsp;n/a
             </code>
            </pre>
           </p>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e1">
            </a>
            <h2>
             Finding, opening and closing a channel
            </h2>
            <p>
             The following example shows how to find, open and close a double
tapping channel. An instance of
             <code class="ApiItem">
              CSensrvChannelFinder
             </code>
             is created to be able to find channels. The found channels are stored
to the
             <code class="ApiItem">
              RSensrvChannelInfoList
             </code>
             type of object. All
double tapping channels provided by the device are queried by setting
the channel type as
             <code class="ApiItem">
              KSensrvChannelTypeIdAccelerometerDoubleTappingData
             </code>
             to the
             <code class="ApiItem">
              TSensrvChannelInfo
             </code>
             object which is used
as search criteria. After calling the
             <code class="ApiItem">
              FindChannelsL()
             </code>
             method
             <code class="ApiItem">
              channelInfoList
             </code>
             contains all the found double
tapping channels. If there are several found channels the client can
select the correct one by examining the content of channel information
objects inside
             <code class="ApiItem">
              channelInfoList
             </code>
             .
            </p>
            <p>
             To construct the
             <code class="ApiItem">
              CSensrvChannel
             </code>
             object properly,
a channel information object from
             <code class="ApiItem">
              channelInfoList
             </code>
             must be used as a parameter for the
             <code class="ApiItem">
              NewL()
             </code>
             constructor.
After successful construction the channel can be opened with the
             <code class="ApiItem">
              OpenChannelL()
             </code>
             method. For open channel the client can set
and get channel properties, add channel conditions and listen for
sensor data. When the channel is not needed anymore it must be closed
with the
             <code class="ApiItem">
              CloseChannel()
             </code>
             method.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;//Construct&nbsp;a&nbsp;channel&nbsp;finder.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CSensrvChannelFinder*&nbsp;channelFinder;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;channelFinder&nbsp;=&nbsp;CSensrvChannelFinder::NewL();
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupStack::PushL(&nbsp;channelFinder&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//List&nbsp;of&nbsp;found&nbsp;channels.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;RSensrvChannelInfoList&nbsp;channelInfoList;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupClosePushL(&nbsp;channelInfoList&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Create&nbsp;and&nbsp;fill&nbsp;channel&nbsp;search&nbsp;criteria.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//In&nbsp;this&nbsp;example&nbsp;double&nbsp;tapping&nbsp;channel&nbsp;is&nbsp;searched.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TSensrvChannelInfo&nbsp;channelInfo;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;channelInfo.iChannelType&nbsp;=&nbsp;KSensrvChannelTypeIdAccelerometerDoubleTappingData;
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Find&nbsp;the&nbsp;double&nbsp;tapping&nbsp;channel
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;channelFinder-&gt;FindChannelsL(&nbsp;channelInfoList,&nbsp;channelInfo&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;channelInfoList.Count()&nbsp;!=&nbsp;1&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//The&nbsp;device&nbsp;doesn't&nbsp;support&nbsp;double&nbsp;tapping&nbsp;channel&nbsp;or
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//there&nbsp;are&nbsp;several&nbsp;double&nbsp;tapping&nbsp;channels.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//double&nbsp;tapping&nbsp;channel&nbsp;found&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Open&nbsp;the&nbsp;double&nbsp;tapping&nbsp;channel.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//When&nbsp;the&nbsp;channel&nbsp;object&nbsp;is&nbsp;created&nbsp;the&nbsp;channel&nbsp;info&nbsp;object&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//must&nbsp;be&nbsp;an&nbsp;object&nbsp;returned&nbsp;by&nbsp;CSensrvChannelFinder::FindChannelsL().
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CSensrvChannel*&nbsp;sensorChannel;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;sensorChannel&nbsp;=&nbsp;CSensrvChannel::NewL(&nbsp;channelInfoList[&nbsp;0&nbsp;]&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupStack::PushL(&nbsp;sensorChannel&nbsp;);&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;sensorChannel-&gt;OpenChannelL();
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Double&nbsp;tapping&nbsp;channel&nbsp;is&nbsp;now&nbsp;open.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Close&nbsp;the&nbsp;double&nbsp;tapping&nbsp;channel.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;sensorChannel-&gt;CloseChannel();
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupStack::PopAndDestroy(&nbsp;sensorChannel&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupStack::PopAndDestroy(&nbsp;&amp;channelInfoList&nbsp;);&nbsp;//Close()&nbsp;is&nbsp;being&nbsp;called&nbsp;on&nbsp;&quot;channelInfoList&quot;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupStack::PopAndDestroy(&nbsp;channelFinder&nbsp;);
              </code>
             </pre>
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               CSensrvChannel
              </code>
             </li>
             <li>
              <code class="ApiItem">
               CSensrvChannelFinder
              </code>
             </li>
             <li>
              <code class="ApiItem">
               CloseChannel()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               FindChannelsL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvChannelTypeIdAccelerometerDoubleTappingData
              </code>
             </li>
             <li>
              <code class="ApiItem">
               NewL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               OpenChannelL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               RSensrvChannelInfoList
              </code>
             </li>
             <li>
              <code class="ApiItem">
               TSensrvChannelInfo
              </code>
             </li>
             <li>
              <code class="ApiItem">
               channelInfoList
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e2">
            </a>
            <h2>
             Listening channel data
            </h2>
            <p>
             The channel must be opened before starting to listen to channel
data. The following example shows how to start listening to a double
tapping channel and receive data from it. Channel data is received
into the receiving buffer and it can be read using the
             <code class="ApiItem">
              GetData()
             </code>
             method. When new data is available in the receiving buffer, a
             <code class="ApiItem">
              DataReceived()
             </code>
             notification is delivered via the data listener
callback interface
             <code class="ApiItem">
              MSensrvDataListener
             </code>
             .
            </p>
            <p>
             In case of double tapping channel, the desired count and maximum
count parameters are set to one to get a
             <code class="ApiItem">
              DataReceived()
             </code>
             notification per one double tapping. The buffering period is set
to zero to get the
             <code class="ApiItem">
              DataReceived()
             </code>
             notification only
when double tapping is done. Channel data can be read from the receiving
buffer using the
             <code class="ApiItem">
              GetData()
             </code>
             method. The receiving
buffer is allocated from heap in the client's thread and its size
is the channel data item size multiplied by maximum number of data
items. There are two receiving buffers for one client, for example
in case of the channel data item size is 20 bytes and the maximum
count is 10 results to 400 bytes memory consumption (20bytes*10*2=400
bytes). On the other hand, small desired data count increases interprocess
communication. The client needs to provide a pointer to the data listener
for the channel to be able to receive
             <code class="ApiItem">
              DataReceived()
             </code>
             notifications.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;StartDataListeningL(&nbsp;this,&nbsp;//this&nbsp;object&nbsp;is&nbsp;data&nbsp;listener&nbsp;for&nbsp;this&nbsp;channel
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;//aDesiredCount&nbsp;is&nbsp;one,&nbsp;i.e.&nbsp;each&nbsp;double&nbsp;tapping&nbsp;is&nbsp;notified&nbsp;separately
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;//aMaximumCount&nbsp;is&nbsp;one,&nbsp;i.e.&nbsp;object&nbsp;count&nbsp;in&nbsp;receiving&nbsp;data&nbsp;buffer&nbsp;is&nbsp;one
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;);//buffering&nbsp;period&nbsp;is&nbsp;not&nbsp;used
              </code>
             </pre>
            </p>
            <p>
             To implement data listener the client needs to inherit from the
             <code class="ApiItem">
              MSensrvDataListener
             </code>
             interface class and implement declared
pure virtual methods. When a new data is available in the sensor channel
and data listening is started, the
             <code class="ApiItem">
              DataReceived()
             </code>
             method is called by Sensor API. The following example shows how
to handle double tapping data received notification. First the channel
type of the received data is checked and then data object is get with
the
             <code class="ApiItem">
              GetData()
             </code>
             method. The
             <code class="ApiItem">
              aCount
             </code>
             parameter tells the number of data objects in the channels receiving
buffer and it can be zero if the buffering period was used when data
listening was started. The
             <code class="ApiItem">
              aDataLost
             </code>
             parameter tells
the number of the lost data objects e.g. in heavy load situations.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;CTestClass::DataReceived(&nbsp;CSensrvChannel&amp;&nbsp;aChannel,&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;aCount,&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;aDataLost&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;aChannel.GetChannelInfo().iChannelType&nbsp;==&nbsp;KSensrvChannelTypeIdAccelerometerDoubleTappingData&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSensrvTappingData&nbsp;tappingData;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPckg&lt;TSensrvTappingData&gt;&nbsp;tappingPackage(&nbsp;tappingData&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aChannel.GetData(&nbsp;tappingPackage&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;}
              </code>
             </pre>
            </p>
            <p>
             When data listening is not needed anymore it must be stopped with
the
             <code class="ApiItem">
              StopDataListening()
             </code>
             method.
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               DataReceived()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               GetData()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvDataListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               StopDataListening()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               aCount
              </code>
             </li>
             <li>
              <code class="ApiItem">
               aDataLost
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e3">
            </a>
            <h2>
             Listening channel changes
            </h2>
            <p>
             The channel finder
             <code class="ApiItem">
              CSensrvChannelFinder
             </code>
             provides
functionality to listen if new channels are installed to the system
or old channels are removed. Listening is started and stopped with
the
             <code class="ApiItem">
              SetChannelListenerL()
             </code>
             method. When channel change
occurs, a
             <code class="ApiItem">
              ChannelChangeDetected()
             </code>
             notification is
delivered via the channel listener callback interface
             <code class="ApiItem">
              MSensrvChannelListener
             </code>
             . There is one restriction on the
             <code class="ApiItem">
              ChannelChangeDetected()
             </code>
             notification:  If sensor changes the existing channel registration
there must be an open channel to that sensor to prevent sensor driver
unloading. In practise, this means that at least one channel from
this sensor must have a client to keep the channel open and sensor
driver loaded. If the sensor driver is unloaded while new channels
become available it cannot notify new channels until some existing
channel opening causes sensor driver to be reloaded.
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               CSensrvChannelFinder
              </code>
             </li>
             <li>
              <code class="ApiItem">
               ChannelChangeDetected()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvChannelListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               SetChannelListenerL()
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e4">
            </a>
            <h2>
             Getting channel properties
            </h2>
            <p>
             The channel must be opened before accessing its properties. The
channel properties are capsulated to the
             <code class="ApiItem">
              TSensrvProperty
             </code>
             class and can be queried with the
             <code class="ApiItem">
              GetPropertyL()
             </code>
             method. The following example shows how to check accuracy of the
channel.
             <code class="ApiItem">
              GetPropertyL()
             </code>
             leaves if the channel does
not support the Accuracy property. Leave also occurs if the Accuracy
property is defined as channel item property, i.e. item index must
point to valid channel item index e.g.
             <code class="ApiItem">
              TSensrvAccelerometerAxisData::iAxisX
             </code>
             .
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;TSensrvProperty&nbsp;property;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TReal&nbsp;propertyValue(&nbsp;0&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdChannelAccuracy,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KSensrvItemIndexNone,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;KSensrvPropIdDataType&nbsp;is&nbsp;specified&nbsp;as&nbsp;TReal&nbsp;of&nbsp;type&nbsp;in&nbsp;sensrvgeneralproperties.h.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Type&nbsp;of&nbsp;the&nbsp;property&nbsp;can&nbsp;also&nbsp;be&nbsp;checked&nbsp;at&nbsp;runtime&nbsp;with&nbsp;PropertyType()&nbsp;method.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;property.PropertyType()&nbsp;==&nbsp;ESensrvRealProperty&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;propertyValue&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
              </code>
             </pre>
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               GetPropertyL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               TSensrvAccelerometerAxisData::iAxisX
              </code>
             </li>
             <li>
              <code class="ApiItem">
               TSensrvProperty
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e5">
            </a>
            <h2>
             Setting channel properties
            </h2>
            <p>
             The channel must be opened before accessing its properties. Channel
properties can be changed with the
             <code class="ApiItem">
              SetProperty()
             </code>
             method.
In the following example the x-axis of accelerometer channel is deactivated.
The axis active property
             <code class="ApiItem">
              KSensrvPropIdAxisActive
             </code>
             with
item index is first got with the
             <code class="ApiItem">
              GetPropertyL()
             </code>
             method.
If the axis is active it is deactivated by setting a new value to
the previously got property. Updated property is set with the
             <code class="ApiItem">
              SetProperty()
             </code>
             method.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;TSensrvProperty&nbsp;property;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;err(&nbsp;KErrNone&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;axisActive(&nbsp;0&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdAxisActive,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSensrvAccelerometerAxisData::Index::iAxisX,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;axisActive&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;1&nbsp;==&nbsp;axisActive&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.SetValue(&nbsp;0&nbsp;);//Other&nbsp;value&nbsp;than&nbsp;one&nbsp;means&nbsp;that&nbsp;sensor&nbsp;axis&nbsp;is&nbsp;deactivated.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;iSensorChannel-&gt;SetProperty(&nbsp;property&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;KErrNone&nbsp;==&nbsp;err&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Accelerometer&nbsp;x-axis&nbsp;was&nbsp;succesfully&nbsp;deactivated
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Accelerometer&nbsp;x-axis&nbsp;is&nbsp;allready&nbsp;deactive
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
              </code>
             </pre>
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               GetPropertyL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdAxisActive
              </code>
             </li>
             <li>
              <code class="ApiItem">
               SetProperty()
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e51">
            </a>
            <h2>
             Array properties
            </h2>
            <p>
             A property which defines multiple discrete values inside one property
ID is called an array property. Array properties can be identified
with array index which can be queried from property with the
             <code class="ApiItem">
              GetArrayIndex()
             </code>
             method. For array properties the array index
is something else than
             <code class="ApiItem">
              ESensrvSingleProperty
             </code>
             . An
example of array property is illustrated in the
             <code class="ApiItem">
              KSensrvPropIdDataRate
             </code>
             property documentation in the
             <i>
              sensorgeneralproperties.h
             </i>
             file.
            </p>
            <p>
             The following example shows how to get current data rate of the
channel which data rate is declared as an array property. First, the
             <code class="ApiItem">
              KSensrvPropIdDataRate
             </code>
             property is read with the
             <code class="ApiItem">
              GetPropertyL()
             </code>
             method. If the property is an array property
the result of the
             <code class="ApiItem">
              GetPropertyL()
             </code>
             call is a property
with array index
             <code class="ApiItem">
              ESensrvArrayPropertyInfo
             </code>
             , otherwise
the array information index is
             <code class="ApiItem">
              ESensrvSingleProperty
             </code>
             . In case of an array property, the value of the current data rate
is in the
             <code class="ApiItem">
              KSensrvPropIdDataRate
             </code>
             property which array
index is same as the array property's value.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;TSensrvProperty&nbsp;property;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;err(&nbsp;KErrNone&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;datarate(&nbsp;0&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdDataRate,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KSensrvItemIndexNone,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;ESensrvArrayPropertyInfo&nbsp;==&nbsp;property.GetArrayIndex()&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Current&nbsp;data&nbsp;rate&nbsp;in&nbsp;use&nbsp;is&nbsp;in&nbsp;KSensrvPropIdDataRate&nbsp;property
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//which&nbsp;array&nbsp;index&nbsp;is&nbsp;declared&nbsp;in&nbsp;array&nbsp;propertys&nbsp;value.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;arrayIndex(&nbsp;0&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;arrayIndex&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdDataRate,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KSensrvItemIndexNone,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayIndex,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;datarate&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//KSensrvPropIdDataRate&nbsp;is&nbsp;a&nbsp;single&nbsp;property&nbsp;and&nbsp;current&nbsp;data&nbsp;rate&nbsp;can&nbsp;be&nbsp;read&nbsp;diretly&nbsp;from&nbsp;it.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;datarate&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;
              </code>
             </pre>
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               ESensrvArrayPropertyInfo
              </code>
             </li>
             <li>
              <code class="ApiItem">
               ESensrvSingleProperty
              </code>
             </li>
             <li>
              <code class="ApiItem">
               GetArrayIndex()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               GetPropertyL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdDataRate
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e52">
            </a>
            <h2>
             Scaling channel data
            </h2>
            <p>
             Value of channel data item can represent the actual value of the
measured quantity, or the channel data item can represent relative
value which is scaled to between maximum and minimum value of the
measured quantity. The
             <code class="ApiItem">
              KSensrvPropIdChannelDataFormat
             </code>
             property defines if channel data items are in scaled format. For
scaled data items the
             <code class="ApiItem">
              KSensrvPropIdScaledRange
             </code>
             property
defines range for the data item value and the
             <code class="ApiItem">
              KSensrvPropIdMeasureRange
             </code>
             property defines range for the measured quantity.
            </p>
            <p>
             The following example reads the maximum value of measure range
for data items
             <code class="ApiItem">
              (KSensrvPropIdScaledRange)
             </code>
             and the
maximum value of the measured quantity
             <code class="ApiItem">
              (KSensrvPropIdMeasureRange)
             </code>
             . The example takes into account that the
             <code class="ApiItem">
              KSensrvPropIdMeasureRange
             </code>
             property can be defined as an array property.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;TSensrvProperty&nbsp;property;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;&nbsp;channelDataFormat(&nbsp;ESensrvFormatAbsolute&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;&nbsp;channelDataScaledRange(&nbsp;1&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TReal&nbsp;channelDataMeasureRangeMaxValue(&nbsp;1&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Read&nbsp;channel&nbsp;data&nbsp;format
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdChannelDataFormat,&nbsp;KSensrvItemIndexNone,&nbsp;property&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;channelDataFormat&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;ESensrvFormatScaled&nbsp;==&nbsp;channelDataFormat&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Read&nbsp;data&nbsp;item&nbsp;scaled&nbsp;range
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdScaledRange,&nbsp;KSensrvItemIndexNone,&nbsp;property&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetMaxValue(&nbsp;channelDataScaledRange&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Read&nbsp;data&nbsp;item&nbsp;measure&nbsp;range
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdMeasureRange,&nbsp;KSensrvItemIndexNone,&nbsp;property&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;ESensrvArrayPropertyInfo&nbsp;==&nbsp;property.GetArrayIndex()&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TInt&nbsp;arrayIndex(&nbsp;0&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetValue(&nbsp;arrayIndex&nbsp;);//Value&nbsp;points&nbsp;to&nbsp;array&nbsp;index&nbsp;currently&nbsp;in&nbsp;use
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iSensorChannel-&gt;GetPropertyL(&nbsp;KSensrvPropIdMeasureRange,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KSensrvItemIndexNone,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayIndex,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Single&nbsp;property
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property.GetMaxValue(&nbsp;channelDataMeasureRangeMaxValue&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//No&nbsp;scaling&nbsp;needed.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Value&nbsp;of&nbsp;the&nbsp;data&nbsp;item&nbsp;represents&nbsp;actual&nbsp;value&nbsp;of&nbsp;the&nbsp;measured&nbsp;quantity.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
              </code>
             </pre>
            </p>
            <p>
             Scaled channel data item value can be converted to absolute value
by dividing the channel data item value with the maximum value of
scaled range of the channel and multiplying it with the maximum value
of the measured quantity. E.g. accelerometer channel provides the
following properties:
            </p>
            <ul>
             <li>
              <p>
               <code class="ApiItem">
                KSensrvPropIdChannelDataFormat
               </code>
               with value
               <code class="ApiItem">
                ESensrvFormatScaled
               </code>
              </p>
             </li>
             <li>
              <p>
              </p>
              <p>
               <code class="ApiItem">
                KSensrvPropIdScaledRange
               </code>
               with maximum value
of 127
              </p>
             </li>
             <li>
              <p>
               <code class="ApiItem">
                KSensrvPropIdMeasureRange
               </code>
               with maximum value
of 2 g
              </p>
             </li>
             <li>
              <p>
               <code class="ApiItem">
                KSensrvPropIdChannelUnit
               </code>
               with value
               <code class="ApiItem">
                ESensrvUnitGravityConstant
               </code>
              </p>
             </li>
            </ul>
            <p>
             In the above example accelerometer channel data item value 64 means
1,01g absolute value (64 / 127 * 2g = 1.01g). Value of the channel
data item can also be scaled and the scaling factor is published in
the
             <code class="ApiItem">
              KSensrvPropIdChannelScale
             </code>
             property.
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               (KSensrvPropIdMeasureRange)
              </code>
             </li>
             <li>
              <code class="ApiItem">
               (KSensrvPropIdScaledRange)
              </code>
             </li>
             <li>
              <code class="ApiItem">
               ESensrvFormatScaled
              </code>
             </li>
             <li>
              <code class="ApiItem">
               ESensrvUnitGravityConstant
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdChannelDataFormat
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdChannelScale
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdChannelUnit
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdMeasureRange
              </code>
             </li>
             <li>
              <code class="ApiItem">
               KSensrvPropIdScaledRange
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e6">
            </a>
            <h2>
             Listening channel property changes
            </h2>
            <p>
             The channel must be opened before listening to channel property
changes. The client can use the property listener to get notifications
about changed properties. If the client itself changes a property
value, no notification is received. Property changes listening is
started and stopped with the
             <code class="ApiItem">
              SetPropertyListenerL()
             </code>
             method. When property change occurs, a
             <code class="ApiItem">
              PropertyChanged()
             </code>
             notification is delivered via the property listener callback interface
             <code class="ApiItem">
              MSensrvPropertyListener
             </code>
             .
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               MSensrvPropertyListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               PropertyChanged()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               SetPropertyListenerL()
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e7">
            </a>
            <h2>
             Listening channel data with condition
            </h2>
            <p>
             The channel must be opened before listening to channel data with
condition. The following example shows how to start listening to double
taps coming from the x-axis direction. When the condition is met,
a
             <code class="ApiItem">
              ConditionMet()
             </code>
             notification is delivered via the
data listener callback interface
             <code class="ApiItem">
              MSensrvChannelConditionListener
             </code>
             .
            </p>
            <p>
             Direction from tapping data (
             <code class="ApiItem">
              TSensrvTappingData
             </code>
             ) is used as a condition in this example. The direction value is
set to the x-axis plus and minus to get notification from double tap
in both x-axis directions. A condition set is created for a container
for one or more conditions. A condition is created to hold a channel
condition item, see detailed comments from the example below. The
condition is added to the condition set and the condition set is added
to the channel. The client has ownership to this condition set and
it has to ensure that the condition set object is valid until the
condition set is removed from the channel or the channel is destroyed.
After the condition set is added to the channel the condition listening
is started with the
             <code class="ApiItem">
              StartConditionListeningL()
             </code>
             method.
The client needs to provide a pointer to the condition listener for
the channel to be able to receive the
             <code class="ApiItem">
              ConditionMet()
             </code>
             notification.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;CSensrvChannelCondition*&nbsp;condition&nbsp;=&nbsp;NULL;
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Condition&nbsp;for&nbsp;double&nbsp;tapping&nbsp;channel&nbsp;is&nbsp;set&nbsp;so&nbsp;that
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;double&nbsp;tap&nbsp;to&nbsp;X-axis&nbsp;triggers&nbsp;condition&nbsp;met&nbsp;notification
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TSensrvTappingData&nbsp;doubleTappingCondition;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;TPckgC&lt;TSensrvTappingData&gt;&nbsp;doubleTappingConditionPckg(&nbsp;doubleTappingCondition&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;doubleTappingCondition.iTimeStamp&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;doubleTappingCondition.iDirection&nbsp;=&nbsp;KSensrvAccelerometerDirectionXplus&nbsp;|&nbsp;KSensrvAccelerometerDirectionXminus;
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;In&nbsp;this&nbsp;example&nbsp;logical&nbsp;operator&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;condition&nbsp;set
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;does&nbsp;not&nbsp;have&nbsp;any&nbsp;effect&nbsp;because&nbsp;only&nbsp;one&nbsp;condition&nbsp;is&nbsp;added
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;to&nbsp;the&nbsp;condition&nbsp;set
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iConditionSet&nbsp;=&nbsp;CSensrvChannelConditionSet::NewL(&nbsp;ESensrvOrConditionSet&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Binary&nbsp;condition&nbsp;(ESensrvBinaryCondition)&nbsp;is&nbsp;used&nbsp;because&nbsp;double&nbsp;tapping&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;channel&nbsp;provides&nbsp;bitmask&nbsp;values.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Binary&nbsp;and&nbsp;(ESensrvOperatorBinaryAnd)&nbsp;operator&nbsp;is&nbsp;used&nbsp;because&nbsp;operator&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;checks&nbsp;if&nbsp;a&nbsp;bitmask&nbsp;data&nbsp;value&nbsp;got&nbsp;from&nbsp;double&nbsp;tapping&nbsp;channel&nbsp;has&nbsp;set&nbsp;at&nbsp;least
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;one&nbsp;of&nbsp;the&nbsp;bits&nbsp;set&nbsp;in&nbsp;the&nbsp;condition&nbsp;value.&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;In&nbsp;other&nbsp;words&nbsp;double&nbsp;tapping&nbsp;direction&nbsp;can&nbsp;be&nbsp;positive&nbsp;or&nbsp;negative.&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Item&nbsp;index&nbsp;(3rd&nbsp;parameter)&nbsp;defines&nbsp;which&nbsp;attribute&nbsp;in&nbsp;data&nbsp;item&nbsp;is&nbsp;used&nbsp;for&nbsp;condition&nbsp;evaluation.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TSensrvTappingData::Index::iDirection&nbsp;means&nbsp;that&nbsp;iDirection&nbsp;is&nbsp;used&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;for&nbsp;condition&nbsp;from&nbsp;TSensrvTappingData&nbsp;class.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Last&nbsp;parameter&nbsp;(doubleTappingConditionPckg)&nbsp;contains&nbsp;value&nbsp;for&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;condition&nbsp;evaluation&nbsp;encapsulated&nbsp;in&nbsp;the&nbsp;package&nbsp;descriptor.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;condition&nbsp;=&nbsp;CSensrvChannelCondition::NewLC(&nbsp;ESensrvBinaryCondition,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ESensrvOperatorBinaryAnd,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TSensrvTappingData::Index::iDirection,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doubleTappingConditionPckg&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Add&nbsp;condition&nbsp;to&nbsp;condition&nbsp;set
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iConditionSet-&gt;AddChannelConditionL(&nbsp;condition&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//Don't&nbsp;delete&nbsp;condition&nbsp;since&nbsp;ownership&nbsp;is&nbsp;transferred&nbsp;to&nbsp;condition&nbsp;set
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;CleanupStack::Pop(&nbsp;condition&nbsp;);&nbsp;
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Add&nbsp;condition&nbsp;set&nbsp;for&nbsp;the&nbsp;double&nbsp;tapping&nbsp;channel
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iDoubleTappingConditionChannel-&gt;AddConditionL(&nbsp;*iConditionSet&nbsp;);
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Start&nbsp;condition&nbsp;listening
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;aObjectCount&nbsp;is&nbsp;one,&nbsp;i.e.&nbsp;each&nbsp;double&nbsp;tapping&nbsp;condition&nbsp;is&nbsp;notified&nbsp;separately
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;buffering&nbsp;period&nbsp;is&nbsp;not&nbsp;used,&nbsp;i.e.&nbsp;it&nbsp;is&nbsp;set&nbsp;to&nbsp;zero
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;iDoubleTappingConditionChannel-&gt;StartConditionListeningL(&nbsp;iDataListener2,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;);
              </code>
             </pre>
            </p>
            <p>
             To implement condition listener the client needs to inherit from
the
             <code class="ApiItem">
              MSensrvChannelConditionListener
             </code>
             interface class
and implement declared pure virtual methods. When a channel condition
set is met and condition listening is started, the
             <code class="ApiItem">
              ConditionMet()
             </code>
             method is called by Sensor Channel API. The following example shows
how to handle condition met notification for double tapping channel.
First the channel type of the received data and correct data buffer
size is checked. The received data object is encapsulated in package
descriptor thus channel data value which met the condition is copied
to a new package buffer. If the client wants to use the same condition
set after notification, the client has to add the condition set again
to the channel object.
            </p>
            <p>
             <pre>
              <code class="cpp">
               &nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;CTestClass::ConditionMet(&nbsp;CSensrvChannel&amp;&nbsp;aChannel,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSensrvChannelConditionSet&amp;&nbsp;aChannelConditionSet,
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TDesC8&amp;&nbsp;aValue&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;aChannel.GetChannelInfo().iChannelType&nbsp;==&nbsp;KSensrvChannelTypeIdAccelerometerDoubleTappingData&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;sizeof(TSensrvTappingData)&nbsp;==&nbsp;aValue.Size()&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TPckgBuf&lt;TSensrvTappingData&gt;&nbsp;dataBuf;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataBuf.Copy(&nbsp;aValue&nbsp;);&nbsp;
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//dataBuf()&nbsp;contains&nbsp;channel&nbsp;data&nbsp;value&nbsp;which&nbsp;met&nbsp;the&nbsp;condition
               <br />
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Use&nbsp;the&nbsp;same&nbsp;condition&nbsp;set&nbsp;again
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;iDoubleTappingConditionChannel&nbsp;)
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Add&nbsp;condition&nbsp;set&nbsp;for&nbsp;the&nbsp;double&nbsp;tapping&nbsp;channel.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Condition&nbsp;listening&nbsp;is&nbsp;not&nbsp;stopped&nbsp;thus
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;only&nbsp;new&nbsp;condition&nbsp;set&nbsp;is&nbsp;needed&nbsp;to&nbsp;be&nbsp;added.
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDoubleTappingConditionChannel-&gt;AddConditionL(&nbsp;*iConditionSet&nbsp;);
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Size&nbsp;of&nbsp;the&nbsp;aValue&nbsp;was&nbsp;unexpected
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;else
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Condition&nbsp;was&nbsp;not&nbsp;met&nbsp;for&nbsp;double&nbsp;tapping&nbsp;channel
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
               <br />
               &nbsp;&nbsp;&nbsp;&nbsp;}
              </code>
             </pre>
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               ConditionMet()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvChannelConditionListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               StartConditionListeningL()
              </code>
             </li>
             <li>
              <code class="ApiItem">
               TSensrvTappingData
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e8">
            </a>
            <h2>
             Error handling
            </h2>
            <p>
             The leave mechanism and return values are used to indicate errors.
Normal Symbian error handling practises should be used, including
e.g. using cleanup stack and the
             <code class="ApiItem">
              TRAP
             </code>
             harness. Listener
callback interfaces (
             <code class="ApiItem">
              MSensrvDataListener
             </code>
             ,
             <code class="ApiItem">
              MSensrvPropertyListener
             </code>
             ,
             <code class="ApiItem">
              MSensrvChannelConditionListener
             </code>
             and
             <code class="ApiItem">
              MSensrvChannelListener
             </code>
             ) offer a callback method
for informing error during listening.
            </p>
            <div class="RelatedItems">
             Related APIs
            </div>
            <ul>
             <li>
              <code class="ApiItem">
               MSensrvChannelConditionListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvChannelListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvDataListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               MSensrvPropertyListener
              </code>
             </li>
             <li>
              <code class="ApiItem">
               TRAP
              </code>
             </li>
            </ul>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic3%2e9">
            </a>
            <h2>
             Memory overhead
            </h2>
            <p>
             The Sensor Channel API memory overhead depends on the channel's
data rate and/or size of the data in the receiving buffer. High data
rate with small data receiving buffer causes increased interprocess
communication. On the other hand, big data receiving buffer reserves
more memory. See example from Section
             <a href="Sensor_Channel_API_Specification.html#Sensor_Channel_API_Specification%2etopic3%2e2" title="The channel must be opened before starting to listen to channel data. The following example shows how to start listening to a double tapping channel and receive data from it. Channel data is received into the receiving buffer and it can be read using the GetData() method. When new data is available in the receiving buffer, a DataReceived() notification is delivered via the data listener callback interface MSensrvDataListener.">
              Listening channel data
             </a>
             .
            </p>
           </div>
           <div class="RelatedItems">
            Related APIs
           </div>
           <ul>
            <li>
             <code class="ApiItem">
              CSensrvChannel
             </code>
            </li>
            <li>
             <code class="ApiItem">
              CSensrvChannelCondition
             </code>
            </li>
            <li>
             <code class="ApiItem">
              CSensrvChannelFinder
             </code>
            </li>
            <li>
             <code class="ApiItem">
              KSensrvItemIndexNone
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TBuf
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TInt
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TReal
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TSensrvChannelInfo
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TSensrvProperty
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TSensrvTappingData
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TSensrvTappingData::KDataTypeId
             </code>
            </li>
            <li>
             <code class="ApiItem">
              TSensrvTappingData::iDirection
             </code>
            </li>
            <li>
             <code class="ApiItem">
              iDirection
             </code>
            </li>
            <li>
             <code class="ApiItem">
              iTimeStamp
             </code>
            </li>
           </ul>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic4">
           </a>
           <h1>
            Glossary
           </h1>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic4%2e1">
            </a>
            <h2>
             Abbreviations
            </h2>
            <p>
             None.
            </p>
           </div>
           <div class="section">
            <a name="Sensor_Channel_API_Specification%2etopic4%2e2">
            </a>
            <h2>
             Definitions
            </h2>
            <p>
             <em>
              Definitions
             </em>
            </p>
            <table class="TableWrap" border="1" cellpadding="1" cellspacing="0">
             <tr valign="top">
              <th>
              </th>
              <th>
              </th>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Channel
               </p>
              </td>
              <td class="Cell">
               <p>
                Abstraction of a sensor. Data from one physical sensor may
be mapped to several channels.
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Channel condition
               </p>
              </td>
              <td class="Cell">
               <p>
                A value-operator pair targeting a single value inside a data
item, indicated by an index. A condition is met when the channel data
value comparison with the condition value using condition operator
is true. The conditions are gathered in condition sets. There are
two condition types: single limit conditions and range conditions.
Range conditions are actually made up from two separate conditions
representing lower and upper limits of the range.
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Channel item property
               </p>
              </td>
              <td class="Cell">
               <p>
                A single property inside channel data item.
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Channel property
               </p>
              </td>
              <td class="Cell">
               <p>
                A single channel property.
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Data Item
               </p>
              </td>
              <td class="Cell">
               <p>
                A discrete data package that contains sensor data or an event
parsed from sensor data and possibly some related values, such as
timestamp. Each channel provides single type of data items only.
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Property
               </p>
              </td>
              <td class="Cell">
               <p>
                Properties are configuration values of sensors and channels.
Changing a property affects all clients listening to affected channel(s).
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Sensor
               </p>
              </td>
              <td class="Cell">
               <p>
                Physical sensor. Single sensor can provide multiple channels,
such as raw data channel and event channels, or multiple sensor readings
can be incorporated into a single channel.
               </p>
              </td>
             </tr>
             <tr valign="top">
              <td class="Cell">
               <p>
                Sensor property
               </p>
              </td>
              <td class="Cell">
               <p>
                These properties affect all channels which draw
data from one physical sensor.
               </p>
              </td>
             </tr>
            </table>
           </div>
          </div>
          <div class="section">
           <a name="Sensor_Channel_API_Specification%2etopic">
           </a>
           <h1>
            References
           </h1>
           <p>
            None.
           </p>
          </div>
         </div>
        </div>
       </div>
      </div>
     </td>
    </tr>
   </table>
   <div style="clear: both">
   </div>
  </div>
  <div id="includedFooter">
   <div id="devnet_footer">
    Copyright &copy;2010&nbsp; Nokia Corporation and/or its subsidiary(-ies). All rights reserved.
    <a href="http://www.eclipse.org/legal/epl-v10.html">
    </a>
   </div>
  </div>
  <?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ???>
 </body>

<!-- Mirrored from devlib.symbian.slions.net/s3/specs/guides/Sensor_Channel_API_Specification/Sensor_Channel_API_Specification.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:33:13 GMT -->
</html>
