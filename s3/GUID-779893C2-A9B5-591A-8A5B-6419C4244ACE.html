
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-779893C2-A9B5-591A-8A5B-6419C4244ACE.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 05:52:31 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2011" /><meta name="DC.rights.owner" content="(C) Copyright 2011" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="How to - Multiple screens" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-94005A46-B4C6-4A30-A8E8-1B9C2D583D50" /><meta name="DC.Relation" scheme="URI" content="GUID-E079315A-E5B6-4D33-B7E3-88697A3F11A4" /><meta name="DC.Relation" scheme="URI" content="GUID-6C16417B-5B37-5310-B59A-750D971AA6D4" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-779893C2-A9B5-591A-8A5B-6419C4244ACE" /><meta name="DC.Language" content="en" /><title>How to
- Multiple screens </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_design.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-779893C2-A9B5-591A-8A5B-6419C4244ACE">How to
- Multiple screens</h1><div>
<div id="GUID-FD58790A-FD0B-563A-80AD-562222865636"><h3 class="section-title">Contents</h3> <ul>
<li id="GUID-75FA7683-5209-5FA6-A10F-F7597498C6CD"><a name="GUID-75FA7683-5209-5FA6-A10F-F7597498C6CD"><!-- --></a><p> <a href="#GUID-00999729-88B9-557B-B999-B2058D63AAB9">Introduction</a> </p> </li>
<li id="GUID-68F833FD-7519-5FE0-AEAA-FDB7B1FCBA0C"><a name="GUID-68F833FD-7519-5FE0-AEAA-FDB7B1FCBA0C"><!-- --></a><p> <a href="#GUID-903F3A00-48C8-583A-92E8-B66F08998DBF">Configuration</a> </p> </li>
<li id="GUID-ED3A4756-E173-587B-838C-9289C1471DF9"><a name="GUID-ED3A4756-E173-587B-838C-9289C1471DF9"><!-- --></a><p> <a href="#GUID-DA870E94-50CA-5175-B69E-39248E57EFFA">Building the ROM image</a> </p> </li>
<li id="GUID-C84723E9-97D6-5E74-A74B-14E4566C824C"><a name="GUID-C84723E9-97D6-5E74-A74B-14E4566C824C"><!-- --></a><p> <a href="#GUID-7B313E77-1089-5FF2-A228-9F82C1C25796">Example Code</a> </p> </li>
<li id="GUID-3609B180-CD0D-501B-9A45-405530FAC78F"><a name="GUID-3609B180-CD0D-501B-9A45-405530FAC78F"><!-- --></a><p> <a href="#GUID-C9E09ADA-07D9-551C-A3D6-46CE3F70269D">Limitations</a> </p> </li>
</ul> </div>
<div id="GUID-00999729-88B9-557B-B999-B2058D63AAB9"><h3 class="section-title">Introduction</h3> <p id="GUID-01F1BC97-47DD-5281-A73B-A0281BF826FB"><a name="GUID-01F1BC97-47DD-5281-A73B-A0281BF826FB"><!-- --></a><strong>Purpose and scope</strong> </p> <p>This
document explains how an application can draw to multiple screens. It is aimed
at a developer who is already familiar with creating a simple application
GUI. In this document, the CONE and WSERV interfaces that support multiple
screens are referred to.</p> </div>
<div id="GUID-094C6D9D-317C-50E2-8440-2217082B89AC"><h3 class="section-title">How to create
multiple screens</h3> <p id="GUID-903F3A00-48C8-583A-92E8-B66F08998DBF"><a name="GUID-903F3A00-48C8-583A-92E8-B66F08998DBF"><!-- --></a><strong>Configuration</strong> </p> <p>The
first screen is indexed as zero and the nth screen is indexed as n-1. The
changes below should be made to the <code class="codeph">wsini.ini</code> file which
resides under <code class="codeph">\epoc32\data\z\system\data</code>. </p> <pre class="codeblock">[screen 0]
[screen 1]
[screen n-1]</pre> <p id="GUID-DA870E94-50CA-5175-B69E-39248E57EFFA"><a name="GUID-DA870E94-50CA-5175-B69E-39248E57EFFA"><!-- --></a><strong>Building
the ROM image</strong> </p> <p>The secondary screen is supported through TV-OUT
on H4 board. The H4 base port only supports landscape mode with 16 bpp resolution.
The ROM image must be built with <code class="codeph">-DWITH_TVOUT</code> as a parameter.</p> <p id="GUID-7B313E77-1089-5FF2-A228-9F82C1C25796"><a name="GUID-7B313E77-1089-5FF2-A228-9F82C1C25796"><!-- --></a><strong>Example Code</strong> </p> <p id="GUID-3431BCF4-D0C2-5DB3-A0D2-6A245C558A9A"><a name="GUID-3431BCF4-D0C2-5DB3-A0D2-6A245C558A9A"><!-- --></a><strong>Setup example code</strong> </p> <p>The
following code is the basis for the examples that follow.</p> <p>This is a <code class="codeph">wsini.ini</code> file
used to create two fixed screens:</p> <pre class="codeblock">AUTOCLEAR 1
STARTUP \SYS\BIN\Start
WINDOWMODE COLOR64K
KEYCLICKPLUGIN KeyClickRef
TRANSPARENCY
MULTIFOCUSPOLICY
[screen 0]
[screen 1]</pre> <p>This is a class <code class="codeph">CTRedControl</code>, which
draws a rectangle on the second screen:</p> <pre class="codeblock">const TInt KSndScreenNo = 1;

class CTRedControl : public CCoeControl
     {
public:
    CTRedControl(){};
    ~CTRedControl(){};
    void ConstructL(RWindowGroup* aWinGp);

private: // From CCoeControl
    void Draw(const TRect&amp; aRect) const;
    };

void CTRedControl::ConstructL(RWindowGroup* aWinGp)
    {    
    CreateWindowL(aWinGp);
    SetExtent(TPoint(20,20),TSize(100,100));
    SetFocus(ETrue);
    ActivateL();        
    }

void CTRedControl::Draw(const TRect&amp; aRect) const
    {
    CWindowGc&amp; gc=SystemGc();
    if (IsFocused())
        {
        gc.SetPenColor(KRgbRed);
        }
          
    gc.DrawRect(aRect);     
    }</pre> <p id="GUID-D8F54A7C-3F22-59A2-9C6C-A1ACAA22AFBC"><a name="GUID-D8F54A7C-3F22-59A2-9C6C-A1ACAA22AFBC"><!-- --></a><strong>Windows
on multiple screens</strong> </p> <p>Using the above example code as a basis, the
following methods can be used to facilitate access to multiple screens:</p> <p>Class <code class="codeph">RWsSession</code> provides
the interface to query WSERV about window groups on a particular screen and
the number of screens in the system. The application calls the function below
to get the number of screens supported on the phone:</p> <pre class="codeblock">iCoeEnv-&gt;WsSession().NumberOfScreens();</pre> <p>The class <code class="codeph">CWsScreenDevice</code> provides the interface to
query the physical limitations of the screen and set the parameters of the
corresponding logical screen. The class <code class="codeph">RWindowGroup</code> is the
client side handle to the server side window group. A pair of screen device
and window group is required to draw on a screen. </p> <p>CONE maintains an
array of screen devices and window groups. The screen number is used to index
this array to retrieve a particular window group and its corresponding screen
device.</p> <p>The application calls <code class="codeph">ScreenDevice()</code> to get
the second screen device:</p> <pre class="codeblock">iCoeEnv-&gt;ScreenDevice(KSndScreenNo);</pre> <p>The
application calls <code class="codeph">RootWin()</code> to get the window group on the
second screen:</p> <pre class="codeblock">iCoeEnv-&gt;RootWin(KSndScreenNo);</pre> <p>The
application calls <code class="codeph">NumWindowGroups(</code> <code class="codeph">)</code> to
get the number of window groups with <code class="codeph">EAllPriorities</code> on the
second screen:</p> <pre class="codeblock">iCoeEnv-&gt;WsSession().NumWindowGroups(KSndScreenNo,EAllPriorities);</pre> <p>The application creates a new list and then populates it with <code class="codeph">WindowGroupList()</code> <code class="codeph"> </code> to
get the list of window groups with <code class="codeph">EAllPriorities</code> on the
second screen:</p> <pre class="codeblock">CArrayFixFlat&lt;TInt&gt;* list = new(ELeave) CArrayFixFlat&lt;TInt&gt;(1);
iCoeEnv-&gt;WsSession().WindowGroupList(list,KSndScreenNo,EAllPriorities);</pre> <p>The
application calls <code class="codeph">GetFocusWindowGroup()</code> to get the window
group that has the keyboard focus on the second screen:</p> <pre class="codeblock">iCoeEnv-&gt;WsSession().GetFocusWindowGroup(KSndScreenNo);</pre> <p>Each screen has a default owning window group. The application calls <code class="codeph">GetDefaultOwningWindow()</code> to
get the default owning window group on the second screen:</p> <pre class="codeblock">iCoeEnv -&gt;WsSession().GetDefaultOwningWindow(KSndScreenNo);</pre> <p>The application calls <code class="codeph">GetDefModeMaxNumColors()</code> to get
the maximum colour and display mode supported on the second screen:</p> <pre class="codeblock">TInt colour, grey;
iCoeEnv-&gt;WsSession().GetDefModeMaxNumColors(KSndScreenNo,colour,grey);</pre> <p>The
application calls <code class="codeph">GetColorModeList()</code> to get the list of colour
modes supported on the second screen:</p> <pre class="codeblock">CArrayFixFlat&lt;TInt&gt;* list = new(Eleave) CArrayFixFlat&lt;TInt&gt;(1);
iCoeEnv -&gt;WsSession().GetColorModeList(KSndScreenNo, list);</pre> <p id="GUID-B6CD7117-E316-5C57-A22F-B5B63D708851"><a name="GUID-B6CD7117-E316-5C57-A22F-B5B63D708851"><!-- --></a><strong>Creating a control on a
particular screen</strong> </p> <p>A window group is associated with a screen device,
which in turn is associated to a screen. A control is associated with a window
group. Therefore a control is constructed on the second screen using the function
below, in the control’s <code class="codeph">ConstructL()</code>:</p> <pre class="codeblock">CTRedControl  redControl=new(Eleave) CTRedControl();
redControl-&gt;ConstructL(CCoeEnv::Static()-&gt;RootWin(KSndScreenNo));</pre> <p id="GUID-0F5FDB1D-EF43-572F-B68F-47E47025AB45"><a name="GUID-0F5FDB1D-EF43-572F-B68F-47E47025AB45"><!-- --></a><strong>Graphics Context</strong> </p> <p>The
class <code class="codeph">CWindowGc</code> provides the interface for the application’s
window graphics context and can be activated on any window in the application.
This means that it can be used on any screen on the phone. The function call
below is used to find the screen device on which the graphics context was
last activated.</p> <pre class="codeblock">CCoeEnv::Static()-&gt;SystemGc().Device();</pre> <p id="GUID-D7EFBD5D-1AF3-526A-A1FF-5FC9F75E68CF"><a name="GUID-D7EFBD5D-1AF3-526A-A1FF-5FC9F75E68CF"><!-- --></a><strong>Window Group Focus Policy</strong> </p> <p>There
are two focus policies supported by WSERV. The default focus policy is that
there is only the focused window group on the focused screen receives key
events. The new policy is that any window group can receive key events and
can be switched on by defining the keyword <code class="codeph">MULTIFOCUSPOLICY</code> in
the <code class="codeph">wsini.ini</code> file.</p> <p id="GUID-C9E09ADA-07D9-551C-A3D6-46CE3F70269D"><a name="GUID-C9E09ADA-07D9-551C-A3D6-46CE3F70269D"><!-- --></a><strong>Limitations</strong> </p> <p id="GUID-C16D1C3E-0326-58CB-8220-F02F2A57321E"><a name="GUID-C16D1C3E-0326-58CB-8220-F02F2A57321E"><!-- --></a><strong>Pointer Events </strong> </p> <p>The
first screen created is also the primary screen in the system. It is important
to note that only the primary screen can respond to pointer events. This is
due to the fact that the kernel supports only one screen digitiser.</p> <p id="GUID-E4D55BC0-9D6A-5D6D-BCA1-8724DCB920D1"><a name="GUID-E4D55BC0-9D6A-5D6D-BCA1-8724DCB920D1"><!-- --></a><strong>Cone-Based UI</strong> </p> <p>Due
to limitations in the legacy implementation of Cone and the control sets implemented
on top of it (for example, Eikon, Avkon or Qikon), it is nearly impossible
to make the same application draw Cone-based UI on two different screens at
the same time. However, a secondary screen can be used to draw non-Cone-based
graphics (for example, a picture or PowerPoint slide-show, or a UI not using
Cone for its widgets). If it must appear as if an application supports displaying
itself on the secondary screen, then this can be done by moving that UI into
a second application instance. This second instance could be a server application
that only acts as a slave UI of the main application. In any case, that secondary
application instance would have to set the secondary screen as its default
screen. There are two main problems: </p> <ol id="GUID-85EC1750-E58A-5BA3-839E-D07AC1958CE0">
<li id="GUID-67511BE4-B68A-5958-9D87-7413E2244327"><a name="GUID-67511BE4-B68A-5958-9D87-7413E2244327"><!-- --></a><p> All controls have to
be associated with a window, and window owning controls do not currently try
to make sure that the window they create is associated with the screen that
they should appear on. This means, for example, that a pop-out window created
by a choice list widget will always appear on the application's primary screen,
rather than on the screen on which the choice list itself is located. </p> </li>
<li id="GUID-BB68FC89-0AA7-5AEC-8CAC-7959CB79C6B2"><a name="GUID-BB68FC89-0AA7-5AEC-8CAC-7959CB79C6B2"><!-- --></a><p> None of the legacy
widget implementations referencing the screen device take into consideration
that there might be more than one screen on the device. These include <code class="codeph">CCoeControl</code>'s <code class="codeph">SetExtentToWholeScreen()</code>, <code class="codeph">SetCornerAndSize()</code>, <code class="codeph">AccumulatedZoom()</code>, <code class="codeph">PositionRelativeToScreen()</code>,
and <code class="codeph">CEikAppUi's ClientRect()</code> and <code class="codeph">ApplicationRect()</code>). </p> </li>
</ol> <p>Neither of these problems can be solved currently.</p> </div>
</div></div></div><div class="footer"><p class="metadata">Last updated March 1st, 2010</p><hr /><div class="copy">© Nokia 2011.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-779893C2-A9B5-591A-8A5B-6419C4244ACE.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 05:52:31 GMT -->
</html>