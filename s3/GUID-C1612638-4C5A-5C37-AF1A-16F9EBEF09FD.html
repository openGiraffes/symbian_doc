
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-C1612638-4C5A-5C37-AF1A-16F9EBEF09FD.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 06:07:34 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2011" /><meta name="DC.rights.owner" content="(C) Copyright 2011" /><meta name="DC.Type" content="reference" /><meta name="DC.Title" content="transient: transient server example" /><meta name="abstract" content="This example demonstrates the use of transient servers that are started on demand when a client needs to use the server, and exit after the last client has disconnected, sometimes after a short delay. It demonstrates how to handle startup and shutdown situations correctly." /><meta name="description" content="This example demonstrates the use of transient servers that are started on demand when a client needs to use the server, and exit after the last client has disconnected, sometimes after a short delay. It demonstrates how to handle startup and shutdown situations correctly." /><meta name="DC.Relation" scheme="URI" content="GUID-4BFEDD79-9502-526A-BA7B-97550A6F0601" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-E3D2A6ED-8192-563D-8966-DD96B3AF1783" /><meta name="DC.Relation" scheme="URI" content="GUID-0DF9E318-BE97-531E-AB39-A7B5E8787C87" /><meta name="DC.Relation" scheme="URI" content="GUID-A63025D1-7FD4-5120-8A1F-537D6B70103D" /><meta name="DC.Relation" scheme="URI" content="GUID-3786D8E6-17A9-52E4-A8DF-CFCDC3039854" /><meta name="DC.Relation" scheme="URI" content="GUID-6047DB3F-DC92-51DF-9EEB-00E79E890B54" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-C1612638-4C5A-5C37-AF1A-16F9EBEF09FD" /><meta name="DC.Language" content="en" /><title>transient: transient server example </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_design.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-C1612638-4C5A-5C37-AF1A-16F9EBEF09FD">transient: transient server example</h1><div><p>This example demonstrates the use of transient servers
that are started on demand when a client needs to use the server,
and exit after the last client has disconnected, sometimes after a
short delay. It demonstrates how to handle startup and shutdown situations
correctly. </p>
<div id="GUID-BF4C4CB4-D495-49D6-8035-F8BA724851B7"><h3 class="section-title">Class
summary</h3><ul>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html"><code class="apiname">RSessionBase</code></a> - Client-side handle to a session
with a server.</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-5733DF34-5B54-3044-BBED-3BFECB7ACE7A.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-5733DF34-5B54-3044-BBED-3BFECB7ACE7A.html"><code class="apiname">CTimer</code></a> - Base class for a timer active object.</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8E316AC4-4676-301A-9A23-659E83AA1D1C.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8E316AC4-4676-301A-9A23-659E83AA1D1C.html"><code class="apiname">CServer2</code></a> - Abstract base class for servers
(version 2).</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-D5A30C75-E22C-34E8-913B-7D2CA6AD5C51.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-D5A30C75-E22C-34E8-913B-7D2CA6AD5C51.html"><code class="apiname">CSession2</code></a> - Represents a session (version
2) for a client thread on the server-side.</p></li>
</ul></div>
<div id="GUID-E688F8C0-0A4A-4D25-B7B4-779CB6A08157"><h3 class="section-title">Download</h3> <p>Click on the following link to download the example: <a href="guid-6013a680-57f9-415b-8851-c4fa63356636/zips/guid-cbf7e18e-3788-4ec1-a225-268ce1a22c51.zip" target="_blank">transient.zip</a></p><p>click: <a href="guid-6013a680-57f9-415b-8851-c4fa63356636/guid-cbf7e18e-3788-4ec1-a225-268ce1a22c51.html#guid-6013a680-57f9-415b-8851-c4fa63356636/guid-cbf7e18e-3788-4ec1-a225-268ce1a22c51.html">browse</a> to view the example code.</p> </div>
<div id="GUID-87B18963-ACE8-464B-9863-A37ADA57379C"><h3 class="section-title">Background</h3> <p>The client-server framework is an important part of the Symbian
platform. There is a level of complexity in implementing a server
for an application, but this example provides client interface code
and server code that can be re-used in your own implementations. </p> <p>Symbian platform servers are of three basic types: </p> <ul>
<li id="GUID-6D0F8C69-CFEA-5BB1-A0CB-C4D178DFAE25"><a name="GUID-6D0F8C69-CFEA-5BB1-A0CB-C4D178DFAE25"><!-- --></a><p> <strong>Transient
servers:</strong> these are started on demand when a client needs the server,
and exit after the last client has disconnected - sometimes after
a short delay, for example, the socket server. </p> </li>
<li id="GUID-5B824584-C8E6-57F7-A83C-564DA256F622"><a name="GUID-5B824584-C8E6-57F7-A83C-564DA256F622"><!-- --></a><p> <strong>System servers:</strong> these are started as part of the system boot process, for example,
the kernel, the file server, the window server etc. </p> </li>
<li id="GUID-9BE0FD09-B112-5AF6-A5D1-FBDD6A4EC00B"><a name="GUID-9BE0FD09-B112-5AF6-A5D1-FBDD6A4EC00B"><!-- --></a><p> <strong>Local servers:</strong> these are "local" to a process to provide multi-threaded access
to thread-specific resources, for example, the posix server (in the
C Standard Library). </p> </li>
</ul> </div>
<div id="GUID-EEA0A38B-F8A6-4308-A50D-B3E74B12420A"><h3 class="section-title">Description</h3> <p>The transient server supplied here runs in a thread in its own
process. This gives the server independence from its clients. This
is important because if the client were to create the server as a
separate thread within its own process, then the server would exit,
i.e. terminate, if its owning process terminated. This would be true
even if clients in other processes were still connected to it. </p> <p>Equally as important: </p> <ul>
<li id="GUID-432FCF7B-2393-5E59-BDE5-0A5B4BAFD155"><a name="GUID-432FCF7B-2393-5E59-BDE5-0A5B4BAFD155"><!-- --></a><p>a client does
not explicitly need to start the server prior to connecting; this
is done by the client interface. </p> </li>
<li id="GUID-D89C8F48-2CA2-5769-8DB9-42FD8FFA5879"><a name="GUID-D89C8F48-2CA2-5769-8DB9-42FD8FFA5879"><!-- --></a><p>the server terminates
when not in use shortly after the last client disconnects. </p> </li>
<li id="GUID-968AB243-908B-5709-BB82-4213860CBC8A"><a name="GUID-968AB243-908B-5709-BB82-4213860CBC8A"><!-- --></a><p>the code handles
concurrency issues, the most common of which is handling the case
where the server is closing down or exiting at the same time that
another client is trying to connect. </p> </li>
</ul> <p>The example consists of four main parts: </p> <ul>
<li id="GUID-BC6A15E0-07CB-562C-99E8-0AAF39B0ED26"><a name="GUID-BC6A15E0-07CB-562C-99E8-0AAF39B0ED26"><!-- --></a><p>Client interface:
a DLL (<code>t-client.dll</code>) that is used by clients. </p> <p>The client interface effectively forms the gateway to the server.
All requests to the server, including requests to connect to it are
routed through this. </p> <p>The client interface defines just one
class: <code class="codeph">RMySession</code>, derived from <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html"><code class="apiname">RSessionBase</code></a>. An <code class="codeph">RSessionBase</code> (derived) object represents the
client side session and forms a channel of communication between the
client and the server. Requests to the server, and information received
from the server are channelled through this object. Note that the
client side session object is mirrored by a server side session object;
an instance of a class derived from <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-D5A30C75-E22C-34E8-913B-7D2CA6AD5C51.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-D5A30C75-E22C-34E8-913B-7D2CA6AD5C51.html"><code class="apiname">CSession2</code></a>,
which in this server is called <code class="codeph">CMySession</code>. </p> <p>The client calls <code class="codeph">Connect()</code> to set up a connection
to the server. This function attempts to start the server if necessary
and then issues a request to create a session with the server. If
the server fails to start, or a session cannot be created then this
is reported back.Simultaneous launching of two server processes is
also detected, with the second attempt failing with KErrAlreadyExists. On successful completion the connection is established, and a session
is created with the server. </p> <p>The client uses the <code class="codeph">Send()</code> method to send messages to the server and the <code class="codeph">Receive()</code> method to request information from the server. <code class="codeph">Send()</code> is implemented by calling down to the synchronous variant of <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-479FE087-DD9F-31D7-98F7-9F96535F0584"><code class="apiname">RSessionBase::SendReceive()</code></a> in the base class. Synchronous
means that it does not return until the server has dealt with the
request. </p> <p> <code class="codeph">Send()</code> passes an operation code
(or function number) identifying the request and a descriptor containing
information to the server. The descriptor is wrapped into a <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-4AD02F14-1142-372F-9D11-224595932034.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-4AD02F14-1142-372F-9D11-224595932034.html"><code class="apiname">TIpcArgs</code></a> object. In practice, your client interface would
probably be richer, having variants of the <code class="codeph">Send()</code> function that take more than one parameter. You might also choose
to have asynchronous variants of <code class="codeph">Send()</code>; your client
code (not the client interface) would then need to use active objects
to deal with this. </p> <p> <code class="codeph">Receive()</code> is implemented
by calling down to the asynchronous variant of <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-479FE087-DD9F-31D7-98F7-9F96535F0584"><code class="apiname">RSessionBase::SendReceive()</code></a> in the base class. Asynchronous means that the call returns immediately,
but the request itself may not complete until some time later. </p> <p> <code class="codeph">Receive()</code> passes an operation code (or function
number) identifying the request, a descriptor into which the server
will place the information, and a <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-E0B34F3E-D4C4-3232-B8B1-7DB35B454646.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-E0B34F3E-D4C4-3232-B8B1-7DB35B454646.html"><code class="apiname">TRequestStatus</code></a> object, which the server will use to report how the request completes.
The descriptor is wrapped into a <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-4AD02F14-1142-372F-9D11-224595932034.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-4AD02F14-1142-372F-9D11-224595932034.html"><code class="apiname">TIpcArgs</code></a> object.
Again, you might want a richer client interface; perhaps different
function names to represent different request types. </p> <p> <code class="codeph">CancelReceive()</code> allows the client to cancel a pending <code class="codeph">Receive()</code> request. It is usual to provide some mechanism
to cancel asynchronous requests. This is implemented by calling down
into the asynchronous variant of <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-479FE087-DD9F-31D7-98F7-9F96535F0584"><code class="apiname">RSessionBase::SendReceive()</code></a> in the base class. Note: the <code class="codeph">Receive()</code> method simply
passes an operation code (or function number) and no data. </p> <p>The operation codes (or function numbers) are defined by an enum
in the header file <code>clientserver.h</code>. This file
is included in both the client interface code and server code as both
need access to these common symbols. </p> </li>
<li id="GUID-A76A5A09-CB86-5D58-8771-3DE4131E51B9"><a name="GUID-A76A5A09-CB86-5D58-8771-3DE4131E51B9"><!-- --></a><p>Server: an EXE
(<code>t-server.exe</code>) that runs in its own process,
and E32Main() is the entry point. After setting up heap checking (in
debug builds only) the implementation creates a cleanup stack and
then executes the main body of the code inside a trap harness. </p> <p>The server code implements several classes: </p> <p> <code class="codeph">CMyServer</code>: this class derives from the class <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8E316AC4-4676-301A-9A23-659E83AA1D1C.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8E316AC4-4676-301A-9A23-659E83AA1D1C.html"><code class="apiname">CServer2</code></a>. The main role of this class is to handle messages sent by client
threads; this includes requests from clients for connection to the
server. The connection is established by starting a session with the
server. The session is represented by a session object, in this case
the CMySession object. </p> <p>Once the <code class="codeph">CMyServer</code> object has been created, the active scheduler
can be started by the call to <a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-B4C76104-EA1B-3FC3-A31E-86A976598171.html#GUID-3281C85C-1A45-3049-B711-64CA8BFBC452"><code class="apiname">CActiveScheduler::Start()</code></a>. This call will not return until the active scheduler is stopped
by the <code class="codeph">CShutdown</code> timer, which is primed after the
last client has disconnected. In simple terms, the active scheduler
is a wait loop. It sits inactive until it receives a message from
(potential) clients (or until the timer completes and stops the active
scheduler). Messages that represent requests for connection result
in the creation of a session. Other messages are passed to the relevant <code class="codeph">CMySession</code> active object. </p> <p> <code class="codeph"> CMySession</code>: one of these objects is created for each session, i.e. as a result
of a request by a client for connection to the server. Once sessions
have been created, requests received by <code class="codeph">CMyServer</code> are then forwarded to the corresponding session, and specifically
to the virtual function <code class="codeph">ServiceL()</code>, which handles <code class="codeph">Send()</code>, <code class="codeph">Receive()</code> and <code class="codeph">CancelReceive()</code> requests. </p> <p> <code class="codeph">CShutdown</code>: this class represents
a timer that is started before the first client has connected, and
after the last client has disconnected. The timer is stopped once
the server has at least one client attached to it. If the server has
no clients, then there is 2 second interval before the server terminates.
This is implemented as an active object. </p> </li>
<li id="GUID-07B2ACEC-C457-547D-B1FE-78FCF980AEEF"><a name="GUID-07B2ACEC-C457-547D-B1FE-78FCF980AEEF"><!-- --></a><p>Test code: corresponds
to the client, and uses the client interface to communicate with the
server - application developers should make use of the principles
applied here and include them into their own client code. </p> </li>
<li id="GUID-91B89143-B380-524D-89CF-918FAE5CE055"><a name="GUID-91B89143-B380-524D-89CF-918FAE5CE055"><!-- --></a><p>bld.inf: a component
description file. </p> </li>
</ul><p><strong>Related APIs</strong></p><ul>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-B4C76104-EA1B-3FC3-A31E-86A976598171.html#GUID-3281C85C-1A45-3049-B711-64CA8BFBC452"><code class="apiname">CActiveScheduler::Start()</code></a></p></li>
<li><p>CMySession</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8E316AC4-4676-301A-9A23-659E83AA1D1C.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-8E316AC4-4676-301A-9A23-659E83AA1D1C.html"><code class="apiname">CServer2</code></a> - Abstract base class for servers
(version 2).</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-D5A30C75-E22C-34E8-913B-7D2CA6AD5C51.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-D5A30C75-E22C-34E8-913B-7D2CA6AD5C51.html"><code class="apiname">CSession2</code></a> - Represents a session (version
2) for a client thread on the server-side.</p></li>
<li><p>KErrAlreadyExists - System wide error code
-11 : an object already exists.</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html"><code class="apiname">RSessionBase</code></a> - Client-side handle to a session
with a server.</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-6D8A458C-9A39-3000-A3BC-060A2A3663E6.html#GUID-479FE087-DD9F-31D7-98F7-9F96535F0584"><code class="apiname">RSessionBase::SendReceive()</code></a></p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-4AD02F14-1142-372F-9D11-224595932034.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-4AD02F14-1142-372F-9D11-224595932034.html"><code class="apiname">TIpcArgs</code></a> - A Version 2 client/server class
that clients use to package the arguments to be sent to a server.</p></li>
<li><p><a href="GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-E0B34F3E-D4C4-3232-B8B1-7DB35B454646.html#GUID-251A35C1-CC66-4DE4-9EBE-964026E89E7F/GUID-E0B34F3E-D4C4-3232-B8B1-7DB35B454646.html"><code class="apiname">TRequestStatus</code></a> - Indicates the completion
status of a request made to a service provider.</p></li>
</ul> </div>
<div id="GUID-86D3479E-216B-4D5D-AF57-C4C9963CD9F0"><h3 class="section-title">Building
and configuring</h3> <p>To build the example: </p> <ul>
<li id="GUID-FDC690A6-D68B-58E5-A10D-89220DB9B89E"><a name="GUID-FDC690A6-D68B-58E5-A10D-89220DB9B89E"><!-- --></a><p>You can build
the example from your IDE or the command line. </p> <p>If you use
an IDE, import the <code>bld.inf</code> file of the example
into your IDE, and use the build command of the IDE. </p> <p>If you
use the command line, open a command prompt, and set the current directory
to the source code directory of the example. You can then build the
example with the SBSv1 build tools with the following commands: </p> <p><kbd class="userinput">bldmake bldfiles</kbd> </p> <p><kbd class="userinput">abld
build</kbd> </p> </li>
<li id="GUID-DD18F4AF-6AB1-5E0F-95C3-9EB899BA99C9"><a name="GUID-DD18F4AF-6AB1-5E0F-95C3-9EB899BA99C9"><!-- --></a><p>For the emulator,
the example builds the following executables : </p> <p> <code>t-client.dll</code> </p> <p> <code>t-server.exe</code> </p> <p> <code>t-test.exe</code> (test executable) </p> <p> <code>t-testc.dll</code> (test client) </p> <p>in the <code>epoc32\release\winscw\&lt;udeb or urel&gt;\</code> folder. </p> </li>
</ul> </div>
</div><h3>Related concepts</h3><ul><li><a href="GUID-4BFEDD79-9502-526A-BA7B-97550A6F0601.html">Platform
security</a></li></ul></div></div><div class="footer"><p class="metadata">Last updated August 24th, 2010</p><hr /><div class="copy">© Nokia 2011.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-C1612638-4C5A-5C37-AF1A-16F9EBEF09FD.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 06:07:35 GMT -->
</html>