<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from devlib.symbian.slions.net/s3/guid-6013a680-57f9-415b-8851-c4fa63356636/02-bitpacking_8xml_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:33:32 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Example Applications: examples/sfexamples/oggvorbiscodec/src/libvorbis/doc/xml/02-bitpacking.xml Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<h1>examples/sfexamples/oggvorbiscodec/src/libvorbis/doc/xml/02-bitpacking.xml</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> standalone=<span class="stringliteral">&quot;no&quot;</span>?&gt;
<a name="l00002"></a>00002 &lt;!DOCTYPE section PUBLIC <span class="stringliteral">&quot;-//OASIS//DTD DocBook XML V4.2//EN&quot;</span>
<a name="l00003"></a>00003                 <span class="stringliteral">&quot;http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd&quot;</span> [
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 ]&gt;
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 &lt;section <span class="keywordtype">id</span>=<span class="stringliteral">&quot;vorbis-spec-bitpacking&quot;</span>&gt;
<a name="l00008"></a>00008 &lt;sectioninfo&gt;
<a name="l00009"></a>00009 &lt;releaseinfo&gt;
<a name="l00010"></a>00010  $Id: 02-bitpacking.xml 7186 2004-07-20 07:19:25Z xiphmont $
<a name="l00011"></a>00011 &lt;/releaseinfo&gt;
<a name="l00012"></a>00012 &lt;/sectioninfo&gt;
<a name="l00013"></a>00013 &lt;title&gt;Bitpacking Convention&lt;/title&gt;
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 &lt;section&gt;
<a name="l00017"></a>00017 &lt;title&gt;Overview&lt;/title&gt;
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 &lt;para&gt;
<a name="l00020"></a>00020 The Vorbis codec uses relatively unstructured raw packets containing
<a name="l00021"></a>00021 arbitrary-width binary integer fields.  Logically, these packets are a
<a name="l00022"></a>00022 bitstream in which bits are coded one-by-one by the encoder and then
<a name="l00023"></a>00023 read one-by-one in the same monotonically increasing order by the
<a name="l00024"></a>00024 decoder.  Most current binary storage arrangements group bits into a
<a name="l00025"></a>00025 native word size of eight bits (octets), sixteen bits, thirty-two bits
<a name="l00026"></a>00026 or, less commonly other fixed word sizes.  The Vorbis bitpacking
<a name="l00027"></a>00027 convention specifies the correct mapping of the logical packet
<a name="l00028"></a>00028 bitstream into an actual representation in fixed-width words.
<a name="l00029"></a>00029 &lt;/para&gt;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 &lt;section&gt;&lt;title&gt;octets, bytes and words&lt;/title&gt;
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 &lt;para&gt;
<a name="l00034"></a>00034 In most contemporary architectures, a <span class="stringliteral">&#39;byte&#39;</span> is synonymous with an
<a name="l00035"></a>00035 <span class="stringliteral">&#39;octet&#39;</span>, that is, eight bits.  This has not always been the <span class="keywordflow">case</span>;
<a name="l00036"></a>00036 seven, ten, eleven and sixteen bit <span class="stringliteral">&#39;bytes&#39;</span> have been used.  For
<a name="l00037"></a>00037 purposes of the bitpacking convention, a byte implies the native,
<a name="l00038"></a>00038 smallest integer storage representation offered by a platform.  On
<a name="l00039"></a>00039 modern platforms, <span class="keyword">this</span> is generally assumed to be eight bits (not
<a name="l00040"></a>00040 necessarily because of the processor but because of the
<a name="l00041"></a>00041 filesystem/memory architecture.  Modern filesystems invariably offer
<a name="l00042"></a>00042 bytes as the fundamental atom of storage).  A <span class="stringliteral">&#39;word&#39;</span> is an integer
<a name="l00043"></a>00043 size that is a grouped multiple of <span class="keyword">this</span> smallest size.&lt;/para&gt;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 &lt;para&gt;
<a name="l00046"></a>00046 The most ubiquitous architectures today consider a <span class="stringliteral">&#39;byte&#39;</span> to be an
<a name="l00047"></a>00047 octet (eight bits) and a word to be a group of two, four or eight
<a name="l00048"></a>00048 bytes (16, 32 or 64 bits).  Note however that the Vorbis bitpacking
<a name="l00049"></a>00049 convention is still well defined <span class="keywordflow">for</span> any native byte size; Vorbis uses
<a name="l00050"></a>00050 the native bit-width of a given storage system. This document assumes
<a name="l00051"></a>00051 that a byte is one octet <span class="keywordflow">for</span> purposes of example.&lt;/para&gt;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 &lt;/section&gt;&lt;section&gt;&lt;title&gt;bit order&lt;/title&gt;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 &lt;para&gt;
<a name="l00056"></a>00056 A byte has a well-defined <span class="stringliteral">&#39;least significant&#39;</span> bit (LSb), which is the
<a name="l00057"></a>00057 only bit <span class="keyword">set</span> when the byte is storing the two<span class="stringliteral">&#39;s complement integer</span>
<a name="l00058"></a>00058 <span class="stringliteral">value +1.  A byte&#39;</span>s <span class="stringliteral">&#39;most significant&#39;</span> bit (MSb) is at the opposite
<a name="l00059"></a>00059 end of the byte. Bits in a byte are numbered from zero at the LSb to
<a name="l00060"></a>00060 &lt;emphasis&gt;n&lt;/emphasis&gt; (&lt;emphasis&gt;n&lt;/emphasis&gt;=7 in an octet) <a class="code" href="interfacefor.html">for</a> the
<a name="l00061"></a>00061 MSb.&lt;/para&gt;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 &lt;/section&gt;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 &lt;section&gt;&lt;title&gt;byte order&lt;/title&gt;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 &lt;para&gt;
<a name="l00068"></a>00068 Words are native groupings of multiple bytes.  Several byte orderings
<a name="l00069"></a>00069 are possible in a word; the common ones are 3-2-1-0 (&#39;big endian&#39; or
<a name="l00070"></a>00070 &#39;most significant byte first&#39; in which the highest-valued byte comes
<a name="l00071"></a>00071 first), 0-1-2-3 (&#39;little endian&#39; or &#39;least significant byte first&#39; in
<a name="l00072"></a>00072 which the lowest value byte comes first) and less commonly 3-1-2-0 and
<a name="l00073"></a>00073 0-2-1-3 (&#39;mixed endian&#39;).&lt;/para&gt;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 &lt;para&gt;
<a name="l00076"></a>00076 The Vorbis bitpacking convention specifies storage and bitstream
<a name="l00077"></a>00077 manipulation at the byte, not word, level, thus host word ordering is
<a name="l00078"></a>00078 of a concern only during optimization when writing high performance
<a name="l00079"></a>00079 code that operates on a word of storage at a time rather than by byte.
<a name="l00080"></a>00080 Logically, bytes are always coded and decoded in order from byte zero
<a name="l00081"></a>00081 through byte &lt;emphasis&gt;n&lt;/emphasis&gt;.&lt;/para&gt;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 &lt;/section&gt;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 &lt;section&gt;&lt;title&gt;coding bits into byte sequences&lt;/title&gt;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 &lt;para&gt;
<a name="l00088"></a>00088 The Vorbis codec has need to code arbitrary bit-width integers, from
<a name="l00089"></a>00089 zero to 32 bits wide, into packets.  These integer fields are not
<a name="l00090"></a>00090 aligned to the boundaries of the byte representation; the next field
<a name="l00091"></a>00091 is written at the bit position at which the previous field ends.&lt;/para&gt;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 &lt;para&gt;
<a name="l00094"></a>00094 The encoder logically packs integers by writing the LSb of a binary
<a name="l00095"></a>00095 integer to the logical bitstream first, followed by next least
<a name="l00096"></a>00096 significant bit, etc, until the requested number of bits have been
<a name="l00097"></a>00097 coded.  When packing the bits into bytes, the encoder begins by
<a name="l00098"></a>00098 placing the LSb of the integer to be written into the least
<a name="l00099"></a>00099 significant unused bit position of the destination byte, followed by
<a name="l00100"></a>00100 the next-least significant bit of the source integer and so on up to
<a name="l00101"></a>00101 the requested number of bits.  When all bits of the destination byte
<a name="l00102"></a>00102 have been filled, encoding continues by zeroing all bits of the next
<a name="l00103"></a>00103 byte and writing the next bit into the bit position 0 of that byte.
<a name="l00104"></a>00104 Decoding follows the same process as encoding, but by reading bits
<a name="l00105"></a>00105 from the byte stream and reassembling them into integers.&lt;/para&gt;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 &lt;/section&gt;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 &lt;section&gt;&lt;title&gt;signedness&lt;/title&gt;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 &lt;para&gt;
<a name="l00112"></a>00112 The signedness of a specific number resulting from decode is to be
<a name="l00113"></a>00113 interpreted by the decoder given decode context.  That is, the three
<a name="l00114"></a>00114 bit binary pattern &#39;b111&#39; can be taken to represent either &#39;seven&#39; as
<a name="l00115"></a>00115 an <span class="keywordtype">unsigned</span> integer, or &#39;-1&#39; as a <span class="keywordtype">signed</span>, two&#39;s complement integer.
<a name="l00116"></a>00116 The encoder and decoder are responsible <a class="code" href="interfacefor.html">for</a> knowing if fields are to
<a name="l00117"></a>00117 be treated as <span class="keywordtype">signed</span> or <span class="keywordtype">unsigned</span>.&lt;/para&gt;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 &lt;/section&gt;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 &lt;section&gt;&lt;title&gt;coding example&lt;/title&gt;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 &lt;para&gt;
<a name="l00124"></a>00124 Code the 4 bit integer value &#39;12&#39; [b1100] into an empty bytestream.
<a name="l00125"></a>00125 Bytestream result:
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 &lt;screen&gt;  
<a name="l00128"></a>00128               |
<a name="l00129"></a>00129               V
<a name="l00130"></a>00130 
<a name="l00131"></a>00131         7 6 5 4 3 2 1 0
<a name="l00132"></a>00132 byte 0 [0 0 0 0 1 1 0 0]  &amp;lt;-
<a name="l00133"></a>00133 byte 1 [               ]
<a name="l00134"></a>00134 byte 2 [               ]
<a name="l00135"></a>00135 byte 3 [               ]
<a name="l00136"></a>00136              ...
<a name="l00137"></a>00137 byte n [               ]  bytestream length == 1 byte
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 &lt;/screen&gt;
<a name="l00140"></a>00140 &lt;/para&gt;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 &lt;para&gt;
<a name="l00143"></a>00143 Continue by coding the 3 bit integer value &#39;-1&#39; [b111]:
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 &lt;screen&gt;
<a name="l00146"></a>00146         |
<a name="l00147"></a>00147         V
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         7 6 5 4 3 2 1 0
<a name="l00150"></a>00150 byte 0 [0 1 1 1 1 1 0 0]  &amp;lt;-
<a name="l00151"></a>00151 byte 1 [               ]
<a name="l00152"></a>00152 byte 2 [               ]
<a name="l00153"></a>00153 byte 3 [               ]
<a name="l00154"></a>00154              ... 
<a name="l00155"></a>00155 byte n [               ]  bytestream length == 1 byte
<a name="l00156"></a>00156 &lt;/screen&gt;
<a name="l00157"></a>00157 &lt;/para&gt;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 &lt;para&gt;
<a name="l00160"></a>00160 Continue by coding the 7 bit integer value &#39;17&#39; [b0010001]:
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 &lt;screen&gt;
<a name="l00163"></a>00163           |
<a name="l00164"></a>00164           V    
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         7 6 5 4 3 2 1 0
<a name="l00167"></a>00167 byte 0 [1 1 1 1 1 1 0 0]
<a name="l00168"></a>00168 byte 1 [0 0 0 0 1 0 0 0]  &amp;lt;-
<a name="l00169"></a>00169 byte 2 [               ]
<a name="l00170"></a>00170 byte 3 [               ]
<a name="l00171"></a>00171              ...
<a name="l00172"></a>00172 byte n [               ]  bytestream length == 2 bytes
<a name="l00173"></a>00173                           bit cursor == 6
<a name="l00174"></a>00174 &lt;/screen&gt;
<a name="l00175"></a>00175 &lt;/para&gt;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 &lt;para&gt;
<a name="l00178"></a>00178 Continue by coding the 13 bit integer value &#39;6969&#39; [b110 11001110 01]:
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 &lt;screen&gt;
<a name="l00181"></a>00181                 |
<a name="l00182"></a>00182                 V
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         7 6 5 4 3 2 1 0
<a name="l00185"></a>00185 byte 0 [1 1 1 1 1 1 0 0]
<a name="l00186"></a>00186 byte 1 [0 1 0 0 1 0 0 0]
<a name="l00187"></a>00187 byte 2 [1 1 0 0 1 1 1 0]
<a name="l00188"></a>00188 byte 3 [0 0 0 0 0 1 1 0]  &amp;lt;-
<a name="l00189"></a>00189              ...
<a name="l00190"></a>00190 byte n [               ]  bytestream length == 4 bytes
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 &lt;/screen&gt;
<a name="l00193"></a>00193 &lt;/para&gt;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 &lt;/section&gt;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 &lt;section&gt;&lt;title&gt;decoding example&lt;/title&gt;
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 &lt;para&gt;
<a name="l00200"></a>00200 Reading from the beginning of the bytestream encoded in the above example:
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 &lt;screen&gt;
<a name="l00203"></a>00203                       |
<a name="l00204"></a>00204                       V
<a name="l00205"></a>00205                       
<a name="l00206"></a>00206         7 6 5 4 3 2 1 0
<a name="l00207"></a>00207 byte 0 [1 1 1 1 1 1 0 0]  &amp;lt;-
<a name="l00208"></a>00208 byte 1 [0 1 0 0 1 0 0 0]
<a name="l00209"></a>00209 byte 2 [1 1 0 0 1 1 1 0]
<a name="l00210"></a>00210 byte 3 [0 0 0 0 0 1 1 0]  bytestream length == 4 bytes
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 &lt;/screen&gt;
<a name="l00213"></a>00213 &lt;/para&gt;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 &lt;para&gt;
<a name="l00216"></a>00216 We read two, two-bit integer fields, resulting in the returned numbers
<a name="l00217"></a>00217 &#39;b00&#39; and &#39;b11&#39;.  Two things are worth noting here:
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 &lt;itemizedlist&gt;
<a name="l00220"></a>00220 &lt;listitem&gt;
<a name="l00221"></a>00221 &lt;para&gt;Although these four bits were originally written as a single
<a name="l00222"></a>00222 four-bit integer, reading some other combination of bit-widths from the
<a name="l00223"></a>00223 bitstream is well defined.  There are no artificial alignment
<a name="l00224"></a>00224 boundaries maintained in the bitstream.&lt;/para&gt;
<a name="l00225"></a>00225 &lt;/listitem&gt;
<a name="l00226"></a>00226 &lt;listitem&gt;
<a name="l00227"></a>00227 &lt;para&gt;The second value is the
<a name="l00228"></a>00228 two-bit-wide integer &#39;b11&#39;.  This value may be interpreted either as
<a name="l00229"></a>00229 the <span class="keywordtype">unsigned</span> value &#39;3&#39;, or the <span class="keywordtype">signed</span> value &#39;-1&#39;.  Signedness is
<a name="l00230"></a>00230 dependent on decode context.&lt;/para&gt;
<a name="l00231"></a>00231 &lt;/listitem&gt;
<a name="l00232"></a>00232 &lt;/itemizedlist&gt;
<a name="l00233"></a>00233 &lt;/para&gt;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 &lt;/section&gt;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 &lt;section&gt;&lt;title&gt;end-of-packet alignment&lt;/title&gt;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 &lt;para&gt;
<a name="l00240"></a>00240 The typical use of bitpacking is to produce many independent
<a name="l00241"></a>00241 byte-aligned packets which are embedded into a larger byte-aligned
<a name="l00242"></a>00242 container structure, such as an Ogg transport bitstream.  Externally,
<a name="l00243"></a>00243 each bytestream (encoded bitstream) must begin and end on a byte
<a name="l00244"></a>00244 boundary.  Often, the encoded bitstream is not an integer number of
<a name="l00245"></a>00245 bytes, and so there is unused (uncoded) space in the last byte of a
<a name="l00246"></a>00246 packet.&lt;/para&gt;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 &lt;para&gt;
<a name="l00249"></a>00249 Unused space in the last byte of a bytestream is always zeroed during
<a name="l00250"></a>00250 the coding process.  Thus, should this unused space be read, it will
<a name="l00251"></a>00251 return binary zeroes.&lt;/para&gt;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 &lt;para&gt;
<a name="l00254"></a>00254 Attempting to read past the end of an encoded packet results in an
<a name="l00255"></a>00255 &#39;end-of-packet&#39; condition.  End-of-packet is not to be considered an
<a name="l00256"></a>00256 error; it is merely a state indicating that there is insufficient
<a name="l00257"></a>00257 remaining data to fulfill the desired read size.  Vorbis uses truncated
<a name="l00258"></a>00258 packets as a normal mode of operation, and as such, decoders must
<a name="l00259"></a>00259 handle reading past the end of a packet as a typical mode of
<a name="l00260"></a>00260 operation. Any further read operations after an &#39;end-of-packet&#39;
<a name="l00261"></a>00261 condition shall also return &#39;end-of-packet&#39;.&lt;/para&gt;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 &lt;/section&gt;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 &lt;section&gt;&lt;title&gt; reading zero bits&lt;/title&gt;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 &lt;para&gt;
<a name="l00268"></a>00268 Reading a zero-bit-wide integer returns the value &#39;0&#39; and does not
<a name="l00269"></a>00269 increment the stream cursor.  Reading to the end of the packet (but
<a name="l00270"></a>00270 not past, such that an &#39;end-of-packet&#39; condition has not triggered)
<a name="l00271"></a>00271 and then reading a zero bit integer shall succeed, returning 0, and
<a name="l00272"></a>00272 not trigger an end-of-packet condition.  Reading a zero-bit-wide
<a name="l00273"></a>00273 integer after a previous read sets &#39;end-of-packet&#39; shall also fail
<a name="l00274"></a>00274 with &#39;end-of-packet&#39;.&lt;/para&gt;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 &lt;/section&gt;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 &lt;/section&gt;
<a name="l00279"></a>00279 &lt;/section&gt;
<a name="l00280"></a>00280 
</pre></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>

<!-- Mirrored from devlib.symbian.slions.net/s3/guid-6013a680-57f9-415b-8851-c4fa63356636/02-bitpacking_8xml_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:33:32 GMT -->
</html>
