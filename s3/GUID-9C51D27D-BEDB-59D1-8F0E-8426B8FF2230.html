
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-9C51D27D-BEDB-59D1-8F0E-8426B8FF2230.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 05:50:07 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2011" /><meta name="DC.rights.owner" content="(C) Copyright 2011" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Descriptors" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-35D7EEFC-B2E4-5444-8875-2A24790E08C2" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-9C51D27D-BEDB-59D1-8F0E-8426B8FF2230" /><meta name="DC.Language" content="en" /><title>Descriptors </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_design.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-9C51D27D-BEDB-59D1-8F0E-8426B8FF2230">Descriptors</h1><div><p>Descriptors are the classes that Symbian platform C++ uses to manage strings. They are fundamental to the Symbian platform, and an excellent example of the difference of approach between non-OO and OO designs. </p> <div><h3 class="section-title">Overview</h3> <p>In C, a string such as </p> <pre class="codeblock">char* hello="hello";</pre> <p>causes some memory to be set aside containing the six characters 'h', 'e', 'l', 'l', 'o', '\0'. A function such as <code class="codeph">strlen()</code> works by scanning the bytes starting from the beginning, and counting until it reaches the trailing null character. If you wish to extend the string, you need to know how much memory is allocated to it. </p> <p>In Symbian platform C++ however, strings are managed using a family of classes called descriptors. The abstract descriptor classes define common interfaces for all descriptor classes. Buffer, pointer, and heap descriptor classes provide implementations of the abstract descriptor interfaces, and provide different methods of storing the data. </p> </div> <div><h3 class="section-title">Abstract descriptors</h3> <p>We can represent the basic requirements for strings by two abstract classes: <code class="codeph">TDesC</code> and <code class="codeph">TDes</code>. </p> <p> <code class="codeph">TDesC</code> is a constant, or non-modifiable, descriptor. It has an address and a length. Using a class like this, you can do any manipulations to a string, provided they do not alter the data. As a consequence, the <code class="codeph">TDesC</code> class has many non-modifying functions. </p> <p> <code class="codeph">TDes</code> is a modifiable descriptor: it has, in addition, a maximum length. This allows the data to be manipulated, extended or contracted, provided it does not exceed the maximum length. As a consequence, <code class="codeph">TDes</code> has many modifying functions which allow string manipulation. </p> <p>It is a fundamental aspect of descriptors that they do not allow modification to exceed the allocated length. Other classes are provided to allow this, for instance <code class="codeph">CBufBase</code> and derived classes. If a <code class="codeph">TDes</code> function causes overflow, a panic will occur. </p> <p>Because <code class="codeph">TDesC</code> and <code class="codeph">TDes</code> define all the functions needed to access and manipulate string and memory data, many functions take a <code class="codeph">const TDesC&amp;</code> parameter if they need to access data, or a <code class="codeph">TDes&amp;</code> parameter if they need to modify it. </p> </div> <div><h3 class="section-title">Pointer descriptor</h3> <p>The abstract descriptor classes have several implementations. The simplest are pointer descriptors. </p> <p> <code class="codeph">TPtrC</code> just has length and address: its representation needs just two machine words. A <code class="codeph">TPtrC</code> may be set up to describe any existing data. A <code class="codeph">TPtr</code> adds a maximum length, and so may be used to describe a buffer which is perhaps only partially allocated. </p> <div class="figure" id="GUID-07AAB2BD-6645-5E19-A69D-C7BDD770FBF6"><img src="GUID-0268102D-D238-5C5E-818F-6ACC4A85B022_d0e7878_href.png" /></div> <p> <code class="codeph">TPtrC</code> and <code class="codeph">TPtr</code> are somewhat like C <code class="codeph">char*</code> pointers. But because the length is contained in the descriptor itself, there is no need to scan for trailing null characters, or to allocate room for them. </p> </div> <div><h3 class="section-title">Buffer descriptors</h3> <p>Buffer descriptors, <code class="codeph">TBufC</code> and <code class="codeph">TBuf</code>, contain their data as part of themselves, like <code class="codeph">char[]</code> arrays in C. </p> <div class="figure" id="GUID-2D00C669-3E47-5352-9730-73035D059B15"><img src="GUID-356B54BB-E389-5562-A2D9-80A472EAC9A3_d0e7910_href.png" /></div> <p>These descriptor classes exploit C++'s template mechanism, using an integer parameter to specify the length. </p> </div> <div><h3 class="section-title">Heap descriptors</h3> <p>Heap descriptors contain their data in heap cell. These are used when you do not know the length required for a buffer at build time, but decide it at run-time. This is like <code class="codeph">(char*) malloc(length+1)</code> in C. </p> <p>The non-modifiable heap descriptor type, <code class="codeph">HBufC</code>, is allocated on the heap. They are always referred to through an <code class="codeph">HBufC*</code>, rather than an <code class="codeph">HBufC</code> directly: </p> <div class="figure" id="GUID-C2909A73-C585-5A0B-B0B8-15BBB05EBCAE"><img src="GUID-C8D5B104-3F34-513B-BA08-5F2FEE60265C_d0e7939_href.png" /></div> <p>The modifiable heap descriptor type, <code class="codeph">RBuf</code>, can be created on the stack, but contains a pointer to data on the heap. This is similar to a <code class="codeph">TPtr</code> pointer descriptor, but an <code class="codeph">RBuf</code> owns the data that it points to, and is responsible for freeing the memory when it is closed. An <code class="codeph">RBuf</code> object can allocate its own buffer, take ownership of a pre-existing section of allocated memory, or take ownership of a pre-existing heap descriptor. </p> <div class="figure" id="GUID-084AC324-8928-53FE-8CF5-75A544522AD8"><img src="GUID-DC37C3A9-B03F-5699-9E05-8ADD62C2FF04_d0e7957_href.png" /></div> <p> <code class="codeph">RBuf</code> is easier to use than <code class="codeph">HBufC</code>, so should generally be preferred. <code class="codeph">RBuf</code> was only introduced in version 8.0, however, so older code and APIs use <code class="codeph">HBufC</code>. </p> </div> <div><h3 class="section-title">Descriptor classes</h3> <p>The complete descriptor class hierarchy is </p> <div class="figure" id="GUID-9FA30B6B-12C7-58CB-92B6-684053EE9FCD"><img src="GUID-7E7BCC57-E14F-56A4-B948-B9FB9E7AB598_d0e7983_href.png" /></div> <p>It represents an elegant use of OO. The <code class="codeph">TBufCBase</code> class is used as an implementation convenience, which is also a frequent OO idiom (though it should be used with caution). </p> <p>Versions of the descriptors classes are available that store 16-bit or 8-bit wide items. When using descriptors for strings, you should always use classes such as <code class="codeph">TDes</code> etc. These classes are <code class="codeph">typedef</code> ed to use the 16-bit implementations, such as <code class="codeph">TDes16</code> etc. </p> <p>Because descriptors may contain any data, including nulls, they may also be used to refer to byte data and general buffers. In these contexts, you should use the 8-bit implementations, such as <code class="codeph">TDes8</code>, directly. </p> </div> </div></div></div><div class="footer"><p class="metadata">Last updated October 8th, 2009</p><hr /><div class="copy">Â© Nokia 2011.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/s3/GUID-9C51D27D-BEDB-59D1-8F0E-8426B8FF2230.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 05:50:09 GMT -->
</html>