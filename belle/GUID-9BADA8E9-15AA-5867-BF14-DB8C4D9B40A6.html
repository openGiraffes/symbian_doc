
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-9BADA8E9-15AA-5867-BF14-DB8C4D9B40A6.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:49:09 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Naming Conventions" /><meta name="abstract" content="Applications on the Symbian platform use a standard set of conventions to name their classes, structs, variables, functions, macros, enumerations, and constants. This topic explains the meaning of these conventions." /><meta name="description" content="Applications on the Symbian platform use a standard set of conventions to name their classes, structs, variables, functions, macros, enumerations, and constants. This topic explains the meaning of these conventions." /><meta name="DC.Relation" scheme="URI" content="GUID-86C9DACB-DCCF-43F6-BCEE-91144F4EADC8_overview-GUID-2CA5C27E-A526-4B26-941B-85F0B32E1FFA" /><meta name="DC.Relation" scheme="URI" content="GUID-C3206E31-251C-4AFC-90C2-04B38CCF8E18" /><meta name="DC.Relation" scheme="URI" content="GUID-C50A3F22-FF47-4074-9A8B-E1E8EFDF65EA" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-9BADA8E9-15AA-5867-BF14-DB8C4D9B40A6" /><meta name="DC.Language" content="en" /><title>Naming Conventions </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-9BADA8E9-15AA-5867-BF14-DB8C4D9B40A6">Naming Conventions</h1><div><p>Applications on the Symbian platform use a standard set
of conventions to name their classes, structs, variables, functions,
macros, enumerations, and constants. This topic explains the meaning
of these conventions. </p>
<div id="GUID-ECF86D11-7E78-42E3-89EC-C692E158B8B6"><h3 class="section-title">Class
names</h3> <p>Most class names are formed with a prefix letter <code class="codeph">C</code>, <code class="codeph">T</code>, <code class="codeph">R</code>, or <code class="codeph">M</code>. Briefly, the meaning of these is as follows: </p> <ul>
<li id="GUID-2F4845E7-26DF-585A-A04B-5FA92C602D5D"><a name="GUID-2F4845E7-26DF-585A-A04B-5FA92C602D5D"><!-- --></a><p> <code class="codeph">C</code>: heap-allocated classes, that are derived from a base class <code class="codeph">CBase</code> </p> </li>
<li id="GUID-1769E8BD-E386-59EE-A631-CB2B998812DB"><a name="GUID-1769E8BD-E386-59EE-A631-CB2B998812DB"><!-- --></a><p> <code class="codeph">T</code>: value classes, that do not own any external object </p> </li>
<li id="GUID-69F2347E-9CF6-5E56-9124-4D4D2B6B1620"><a name="GUID-69F2347E-9CF6-5E56-9124-4D4D2B6B1620"><!-- --></a><p> <code class="codeph">R</code>: resource classes, that contain handles to a real resource which
is maintained elsewhere </p> </li>
<li id="GUID-81D42168-744A-55EF-BFD5-13A2E2609CD9"><a name="GUID-81D42168-744A-55EF-BFD5-13A2E2609CD9"><!-- --></a><p> <code class="codeph">M</code>: interface classes, that define abstract protocol definitions that
are implemented by derived classes </p> </li>
</ul> <p>For a detailed discussion on the meaning of these prefixes,
see <a href="GUID-2458916B-55B2-5E08-A825-4EBDB3503E67.html">Class types</a>. </p> <p>Classes that consist solely of static member functions
have no prefix letter. Beyond the prefix, the class name is usually
a noun that indicates the purpose of the class. </p> </div>
<div id="GUID-0CD200CF-2B14-4DE1-90EF-89A0548865E8"><h3 class="section-title">Struct
names</h3> <p>Structure types are considered as similar to <code class="codeph">T</code> classes, as they should not own external objects, and
are normally given names beginning with <code class="codeph">T</code> (although
some begin with <code class="codeph">S</code>). </p> </div>
<div id="GUID-100949DD-D150-4CED-87DE-04CD25B4F01A"><h3 class="section-title">Variable
names</h3> <p>Member variables’ names begin with <code class="codeph">i</code>, e.g. <code class="codeph">iMember</code>. This makes it easy to check that
certain cleanup-related rules are being obeyed. Arguments’ names begin
with <code class="codeph">a</code>, e.g. <code class="codeph">aControl</code> or <code class="codeph">aIndex</code>. Local variables’ names have no initial letter. Global
variables are usually avoided, but when used, their names begin with
a capital letter. </p> <p>The Symbian platform does not use Hungarian
or any notation which attempts to include the variable type in its
name: such notations are ugly, and become impossible to manage when
there are several hundred classes in the system. They are irrelevant
anyway: functions are usually so short that it is easy to see the
types of variables defined in them, and class browsers provide a quick
way to find the types of class members. </p> </div>
<div id="GUID-26C73D5F-CF3A-4F71-BF17-53059D3ABF56"><h3 class="section-title">Function
names</h3> <p>Functions’ names indicate what they do. They are
usually verbs. One exception is “getter” functions: for a function
which returns the value of a member variable, the function name is
usually the name of the variable, without the leading <code class="codeph">i</code>: </p> <pre class="codeblock">inline RWindow&amp; Window() const { return iWindow; };</pre> <p>A corresponding “setter” function would include the word <code class="codeph">Set</code>, e.g. <code class="codeph">SetWindow()</code>. </p> <p>To terminate
functions because of error conditions, the Symbian platform does not
use standard C++ exception handling, but its own system called leaving.
Any function that might leave has a name ending in <code class="codeph">...L()</code>. This makes the fundamental process of checking for errors easier.
The <code class="codeph">new (ELeave)</code> function might also leave. The fundamental
leaving function is <code class="codeph">User::Leave()</code>. Any function that
contains any of these, and does not trap them, might itself leave,
and should be coded with a trailing <code class="codeph">L</code> in its name.
If a function calls another which might leave, then its name should
have the <code class="codeph">L</code> suffix also. </p> <p>Associated with the
leaving mechanism, is the cleanup stack, which allows memory allocated
on the heap to be recovered when a leave occurs. An allocation or
construction function which places data on the cleanup stack ends
with <code class="codeph">...LC()</code>. For instance, many <code class="codeph">new</code>, <code class="codeph">PushL()</code>, <code class="codeph">ConstructL()</code> sequences
are encapsulated in a <code class="codeph">NewLC()</code> function: </p> <pre class="codeblock">CS* s= CS::NewLC(p1, p2);</pre> <p>This allocates the object, initialises it, and leaves it on the
cleanup stack. This process may leave (if only through the <code class="codeph">PushL()</code> !), so such functions always include an <code class="codeph">L</code>, and are therefore <code class="codeph">...LC()</code>. </p> <p>A
function which takes ownership of its object and destroys it has a
name ending in <code class="codeph">...D()</code>. An example is the UI framework
dialog protocol: </p> <pre class="codeblock">CEikDialog* dialog=new (ELeave) CBossSettingsDialog;
if (dialog-&gt;ExecuteLD(R_BOSS_SETTINGS_DIALOG))
    {
    // handle successful settings
    }</pre> <p>The <code class="codeph">ExecuteLD()</code> function includes
second-phase construction, execution of the dialog and then destruction. </p> </div>
<div id="GUID-2E3CB84B-245A-4F3C-886E-C957FF36D050"><h3 class="section-title">Macro
names</h3> <p>Macro names are all capitalised, with underscores
to separates words. </p> </div>
<div id="GUID-10247F18-22B5-4FC8-B5F4-134532BC602F"><h3 class="section-title">Enumeration
names</h3> <p>Enumerations are named as follows: </p> <ul>
<li id="GUID-FFB2E991-CB2B-5F95-BF13-E0019EF0FDD8"><a name="GUID-FFB2E991-CB2B-5F95-BF13-E0019EF0FDD8"><!-- --></a><p>as enumerations
are types, they have the <code class="codeph">T</code> prefix </p> </li>
<li id="GUID-9E021588-6989-59D7-93D6-6E6B27A88E45"><a name="GUID-9E021588-6989-59D7-93D6-6E6B27A88E45"><!-- --></a><p>enumeration
members have the prefix <code class="codeph">E</code> </p> </li>
<li id="GUID-95C953A3-6E0F-5FE2-B357-D1A470DC92E5"><a name="GUID-95C953A3-6E0F-5FE2-B357-D1A470DC92E5"><!-- --></a><p>type and members
should have a meaningful, unambiguous name </p> </li>
</ul> <p>Enumerations should be scoped within the relevant class,
so as not to pollute the global name space. </p> <p>An example of
the declaration and use of an enumeration is as follows: </p> <pre class="codeblock">class TDemo
    {
public:
    enum TShape {EShapeRound, EShapeSquare};
    };

TDemo::TShape shape=TDemo::EShapeSquare;</pre> </div>
<div id="GUID-B5C3B213-1C19-4964-967A-A08BAC6FC9B0"><h3 class="section-title">Constant
names</h3> <p>Names of constants have a prefix <code class="codeph">K</code>. For example, </p> <pre class="codeblock">const TInt KMaxNameLength=0x20;</pre> </div>
</div></div></div><div class="footer"><p class="metadata">Last updated November 16th, 2010</p><hr /><div class="copy">© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-9BADA8E9-15AA-5867-BF14-DB8C4D9B40A6.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:49:09 GMT -->
</html>