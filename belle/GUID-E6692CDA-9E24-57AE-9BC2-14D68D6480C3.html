
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-E6692CDA-9E24-57AE-9BC2-14D68D6480C3.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:03:52 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Enhanced Features for Encoder and Decoder Tutorial" /><meta name="DC.Relation" scheme="URI" content="GUID-88091838-03FC-550F-9A3D-DA70907EF955" /><meta name="DC.Relation" scheme="URI" content="GUID-C0B39D73-0A3C-5289-A774-7BE590037404" /><meta name="DC.Relation" scheme="URI" content="GUID-9D6C086F-7621-5522-AE0B-81CBD5E99125" /><meta name="DC.Relation" scheme="URI" content="GUID-E6692CDA-9E24-57AE-9BC2-14D68D6480C3" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-1DE5CDAD-8D71-5384-9E98-5665D5A4C792" /><meta name="DC.Relation" scheme="URI" content="GUID-3E341F9F-2635-589B-A59A-B999FE7DF9BE" /><meta name="DC.Relation" scheme="URI" content="GUID-7DB86BF1-0485-5CBA-9554-4C474B0EC1FB" /><meta name="DC.Relation" scheme="URI" content="GUID-9DFB1340-FA1E-530E-9372-DB6509CECA2B" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-E6692CDA-9E24-57AE-9BC2-14D68D6480C3" /><meta name="DC.Language" content="en" /><title> Enhanced Features for Encoder and Decoder Tutorial </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-E6692CDA-9E24-57AE-9BC2-14D68D6480C3"> Enhanced Features for Encoder and Decoder Tutorial</h1><div><p>This document gives you more information about the enhanced features for the encoder and the decoder during the bitmap transformation. </p> <div><h3 class="section-title">Purpose</h3> <p>The purpose of the enhanced features for encoder and decoder is to set various transformation operations during encoding and decoding, which gives faster and more resource friendly output. </p> <p><strong>Required Background</strong> </p> <p>The enhanced features for encoder and decoder are provided through Imaging Frameworks and Imaging plugins. </p> <p><strong>Introduction</strong> </p> <p>The enhanced features of the decoder are currently supported by the Symbian JPEG codec and PNG codec. The transformation features during the decoding are as follows: </p> <ul><li id="GUID-7FB92047-2217-580B-B201-EFCC9CA627B8"><a name="GUID-7FB92047-2217-580B-B201-EFCC9CA627B8"><!-- --></a><p> <strong>Clipping : </strong> </p> <p>A rectangular region of an image is chosen and it is clipped for decoding. The decoded output is either a native bitmap (<a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><code class="apiname">CFbsBitmap</code></a>) or a pixel buffer (e.g YUV 4:2:2 frames). </p> </li> <li id="GUID-1C14DD15-3EE9-53F7-946B-B48FAA7C23CB"><a name="GUID-1C14DD15-3EE9-53F7-946B-B48FAA7C23CB"><!-- --></a><p> <strong> Rotation / Mirroring : </strong> </p> <p>The functionality in rotation are 90º increments, mirroring over the horizontal axis, mirroring over the vertical axis, and combination of these features. </p> </li> <li id="GUID-6E856862-0EE7-59EA-A354-CEA4C2C840F4"><a name="GUID-6E856862-0EE7-59EA-A354-CEA4C2C840F4"><!-- --></a><p> <strong>Scaling : </strong> </p> <p>In scaling only downscaling is supported during the decode operation. At present the supported scaling coefficients for an image are ½, ¼ or ⅛ of the original image size. </p> </li> </ul> <p>In transformation of an image during decode you can choose more than one operation. For example you can choose clipping and scaling, or clipping and rotation, or all the three combinations of clipping, scaling and rotation. </p> <p> <strong>Note:-</strong> When you want to clip and scale an image you need to follow this order: </p> <ul><li id="GUID-41626AF1-F425-5965-B238-F5B94A0EA627"><a name="GUID-41626AF1-F425-5965-B238-F5B94A0EA627"><!-- --></a><p>First you need to clip the image. </p> </li> <li id="GUID-056D21EA-6627-5FA6-848D-ED516C332CE6"><a name="GUID-056D21EA-6627-5FA6-848D-ED516C332CE6"><!-- --></a><p>Then you can scale the image. </p> </li> </ul> <p>This order is defined because if you scale an image and do clipping the output will not be a resource friendly output. </p> <p>The enhanced feature of the encoder is currently supported by the Symbian JPEG codec and PNG codec. The transformation feature during the encoding is: </p> <ul><li id="GUID-667B9F91-729B-5B4B-B83D-B3EC4219E297"><a name="GUID-667B9F91-729B-5B4B-B83D-B3EC4219E297"><!-- --></a><p>Imaging Frameworks provides support for rotation and mirroring while encode bitmaps or YUV pixel data, contained in a memory descriptor, to the data format. </p> </li> </ul> <p><strong>Setup and Configuration Requirements</strong> </p> <p> <strong>Setting up the right decoder</strong> </p> <p>In order to allow the decoder to advertise the extended operations (cropping, rotation, horizontal flipping and vertical flipping) use <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-350DA091-17AB-3455-BE35-10A4ABA34706"><code class="apiname">CImageDecoder::TOptions()</code></a> and select the option for <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DA07559-7DDC-32A9-9E09-D557348D46DE"><code class="apiname">CImageDecoder::FileNewL()</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-00FB83E8-3759-32BE-B6E8-6F04EC60A909"><code class="apiname">CImageDecoder::DataNewL()</code></a>. The code below shows, how to set the right decoder and to set the options: </p> <pre class="codeblock">

TUint options =    CImageDecoder::EOptionExtRotation |
            CImageDecoder::EOptionExtMirrorHorizontalAxis |
            CImageDecoder::EOptionExtScaling;

// The installed decoder supports all the operations requested.
CImageDecoder* decoder = CImageDecoder::FileNewL(iFs, KInputFile, static_cast&lt;CImageDecoder::TOptions&gt;(options));

// Ask for vertical flipping support.
TImageConvOperation* operation = decoder-&gt;OperationL();
if (operation)
    {
    // This gives KErrNotSupported because you have not asked for vertical flipping support.
    
operation&gt;AddOperationL(TImageConvOperation::EMirrorVerticalAxis);
}

</pre> <p> <strong>Setting up the right encoder</strong> </p> <p>In order to allow the encoder to advertise the extended operations (rotation, horizontal flipping and vertical flipping) use <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-737DA130-9A66-39E2-9E68-2E65F37E02C8.html#GUID-669FCF04-BC55-3CAF-93EB-C824E6C2BBB5"><code class="apiname">CImageEncoder::TOptions()</code></a> and select the option for <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-737DA130-9A66-39E2-9E68-2E65F37E02C8.html#GUID-1F25CC18-A8E4-3E1D-BA3D-F5F472E20CC0"><code class="apiname">CImageEncoder::FileNewL()</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-737DA130-9A66-39E2-9E68-2E65F37E02C8.html#GUID-51ECB4D3-5A87-35E7-82EB-DF2BAEAB2CAC"><code class="apiname">CImageEncoder::DataNewL()</code></a>. The code below shows, how to set the right encoder and to set the options: </p> <pre class="codeblock">

TUint options =    CImageEncoder::EOptionExtRotation |
            CImageEncoder::EOptionExtMirrorHorizontalAxis 
            
// The installed encoder supports all the operations requested.
CImageEncoder* encoder = CImageEncoder::FileNewL(iFs, KInputFile, static_cast&lt;CImageEncoder::TOptions&gt;(options));

// Ask for vertical flipping support.
TImageConvOperation* operation = encoder-&gt;OperationL();
if (operation)
    {
    // This gives KErrNotSupported because you have not asked for vertical flipping support.
    
operation&gt;AddOperationL(TImageConvOperation::EMirrorVerticalAxis);
}


</pre> </div> <div><h3 class="section-title">Using Enhanced Features for Encoder and Decoder </h3> <p>The Following tasks are covered in this tutorial: </p> <ul><li id="GUID-FBC2B2C3-CD3A-5C88-8086-6F348FF709FA"><a name="GUID-FBC2B2C3-CD3A-5C88-8086-6F348FF709FA"><!-- --></a><p><a href="#GUID-B5E10863-7F1D-586B-B752-8A6C0081F022">How to set clipping / cropping operation during decode</a> </p> </li> <li id="GUID-AA02F1AC-FB21-5F70-8E72-71BC04B23557"><a name="GUID-AA02F1AC-FB21-5F70-8E72-71BC04B23557"><!-- --></a><p><a href="#GUID-D92FA64D-3ABF-5159-815A-06108FEE6A4E">How to set rotation / mirroring operation during decode</a> </p> </li> <li id="GUID-EA24348E-9C10-5147-9419-CD5540F8C9B8"><a name="GUID-EA24348E-9C10-5147-9419-CD5540F8C9B8"><!-- --></a><p><a href="#GUID-3362463F-5B27-571B-AE8D-047BB544CF8D">How to set scaling operation during decode</a> </p> </li> <li id="GUID-9397F20A-79CA-5C3B-B251-A07741BCECC6"><a name="GUID-9397F20A-79CA-5C3B-B251-A07741BCECC6"><!-- --></a><p><a href="#GUID-466BDF59-39CE-5631-9CE1-83615C3D92A1">How to set rotation / mirrioring opeartion during encode</a> </p> </li> </ul> <p id="GUID-B5E10863-7F1D-586B-B752-8A6C0081F022"><a name="GUID-B5E10863-7F1D-586B-B752-8A6C0081F022"><!-- --></a><strong>Basic Procedure For Clipping / Cropping Operation During Decode</strong> </p> <p>The high level steps to set clipping / cropping operation during decode are as follows: </p> <ol id="GUID-9873ED31-6562-5E9B-89B6-05B00185AAD5"><li id="GUID-19A92D1F-49C6-5A6C-9D80-C75D35F37F52"><a name="GUID-19A92D1F-49C6-5A6C-9D80-C75D35F37F52"><!-- --></a><p>To create the decoder call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DA07559-7DDC-32A9-9E09-D557348D46DE"><code class="apiname">CImageDecoder::FileNewL()</code></a> or <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-00FB83E8-3759-32BE-B6E8-6F04EC60A909"><code class="apiname">CImageDecoder::DataNewL()</code></a>, using the <code class="codeph">TOptions</code> parameter of <code class="codeph">EOptionExtCrop</code> to request the added functionality. </p> </li> <li id="GUID-6EF8781B-61F2-5421-B7AB-4890590D55B6"><a name="GUID-6EF8781B-61F2-5421-B7AB-4890590D55B6"><!-- --></a><p>In order to clip / crop the image call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-BA78485B-F2DB-31A5-A1B1-188A0F72C69D"><code class="apiname">CImageDecoder::SetClippingRectL()</code></a>. </p> </li> <li id="GUID-488BCB35-1F0C-5F3D-998C-8F3625BE97A9"><a name="GUID-488BCB35-1F0C-5F3D-998C-8F3625BE97A9"><!-- --></a><p>Then you need to obtain the size of the bitmap which holds the output of the operation being performed during decode, call the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B8F6B2B5-F99B-3C4F-B2AD-0B378777D9B0"><code class="apiname">CImageDecoder::GetDestinationSize()</code></a> function. </p> </li> <li id="GUID-0ED79E97-DB79-5F31-A849-D60D9849262A"><a name="GUID-0ED79E97-DB79-5F31-A849-D60D9849262A"><!-- --></a><p>Finally start the decoding operation by calling <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-8118AC37-471E-3CB6-9F71-4E93507DDE57"><code class="apiname">CImageDecoder::Convert()</code></a> and use the <code class="codeph">CFbsBitmap</code> obtained by <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B8F6B2B5-F99B-3C4F-B2AD-0B378777D9B0"><code class="apiname">CImageDecoder::GetDestinationSize()</code></a>. </p> </li> </ol> <p>For example code got to the session <a href="#GUID-AC972EE1-E26C-5166-AC0A-5979ACA7FC73">Example Code During Decode</a>. </p> <p id="GUID-3362463F-5B27-571B-AE8D-047BB544CF8D"><a name="GUID-3362463F-5B27-571B-AE8D-047BB544CF8D"><!-- --></a><strong>Basic Procedure For Scaling Operation During Decode</strong> </p> <p>The high level steps to set scaling during decode are as follows: </p> <ol id="GUID-B084C5B1-2098-5802-8862-F6E5D54104D4"><li id="GUID-B099FFAB-F2B3-5A73-A2B5-5C7CAF6D02D1"><a name="GUID-B099FFAB-F2B3-5A73-A2B5-5C7CAF6D02D1"><!-- --></a><p>To create the decoder call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DA07559-7DDC-32A9-9E09-D557348D46DE"><code class="apiname">CImageDecoder::FileNewL()</code></a> or <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-00FB83E8-3759-32BE-B6E8-6F04EC60A909"><code class="apiname">CImageDecoder::DataNewL()</code></a>. </p> <p> </p> </li> <li id="GUID-6529BA30-0BCC-5023-83CB-484A3CC909BE"><a name="GUID-6529BA30-0BCC-5023-83CB-484A3CC909BE"><!-- --></a><p>In order to scale the image call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-0C59067D-22EB-32E1-A4F6-A4335FD94B40"><code class="apiname">CImageDecoder::ScalerL()</code></a>. </p> </li> <li id="GUID-8D1C2920-E59B-5DAB-B08D-27A5A814DEF9"><a name="GUID-8D1C2920-E59B-5DAB-B08D-27A5A814DEF9"><!-- --></a><p>Then you need to obtain the size of the bitmap which holds the output of the operation being performed during decode, call the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B8F6B2B5-F99B-3C4F-B2AD-0B378777D9B0"><code class="apiname">CImageDecoder::GetDestinationSize()</code></a> function. </p> </li> <li id="GUID-AAF8C49D-8620-533E-AA22-055E8B505E98"><a name="GUID-AAF8C49D-8620-533E-AA22-055E8B505E98"><!-- --></a><p>Finally start the decoding operation by calling <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-8118AC37-471E-3CB6-9F71-4E93507DDE57"><code class="apiname">CImageDecoder::Convert()</code></a> and use the <code class="codeph">CFbsBitmap</code> obtained by <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B8F6B2B5-F99B-3C4F-B2AD-0B378777D9B0"><code class="apiname">CImageDecoder::GetDestinationSize()</code></a>. </p> </li> </ol> <p>For example code got to the session <a href="#GUID-AC972EE1-E26C-5166-AC0A-5979ACA7FC73">Example Code During Decode</a>. </p> <p id="GUID-AC972EE1-E26C-5166-AC0A-5979ACA7FC73"><a name="GUID-AC972EE1-E26C-5166-AC0A-5979ACA7FC73"><!-- --></a><strong>Example Code For Clipping And Scaling During Decode</strong> </p> <p>The example below shows how to peform clipping and scaling during decode : </p> <pre class="codeblock">

void CIclExample::ClipScaleDuringDecode()
    {
    TRect clipRect(TPoint(50, 65), TSize(170, 160));    // The wheel in thumbimage.jpg
    TSize finalSize;

    // The decoder supports all the operations you are going to perform.
    TUint options =    CImageDecoder::EOptionExtRotation |
                    CImageDecoder::EOptionExtMirrorHorizontalAxis |
                    CImageDecoder::EOptionExtCrop |
                    CImageDecoder::EOptionExtScaling;

    // The installed decoder supports all the operations requested in options.
    _LIT(KInputFile, "c:\\ICLExample\\thumbimage.jpg");
    CImageDecoder* decoder = CImageDecoder::FileNewL(iFs, KInputFile, static_cast&lt;CImageDecoder::TOptions&gt;(options));
    CleanupStack::PushL(decoder);

    const TFrameInfo&amp; frameInfo = decoder-&gt;FrameInfo(KFirstFrame);
    CFbsBitmap* output = new(ELeave) CFbsBitmap();
    CleanupStack::PushL(output);
    User::LeaveIfError(output-&gt;Create(frameInfo.iFrameSizeInPixels, frameInfo.iFrameDisplayMode));

    CActiveListener* ao = CActiveListener::NewLC();

    TImageConvOperation* operation = decoder-&gt;OperationL();
    TImageConvScaler* scaler = decoder-&gt;ScalerL();

    TInt i = 0;
    while (KDecodeParams[i].iOutputFile != NULL)
        {
        const TDecodeParams&amp; params = KDecodeParams[i++];

        operation-&gt;ClearOperationStack();
        if (params.iRotate90)
            {
            operation-&gt;AddOperationL(TImageConvOperation::ERotation90DegreesClockwise);
            }

        if (params.iMirrorVerticalAxis)
            {
            operation-&gt;AddOperationL(TImageConvOperation::EMirrorVerticalAxis);
            }

        // Some codecs have a limit on the amount of scaling they can do.
        scaler-&gt;SetScalingL(params.iScalingCoeff, TImageConvScaler::EMaximumQuality);

        // Setting the clipping rect to NULL decodes the whole image.
        decoder-&gt;SetClippingRectL(params.iClip ? &amp;clipRect : NULL);
        User::LeaveIfError(decoder-&gt;GetDestinationSize(finalSize, KFirstFrame));
        User::LeaveIfError(output-&gt;Resize(finalSize));

        // See Note 1
        ao-&gt;Initialize();
        decoder-&gt;Convert(&amp;ao-&gt;iStatus, *output, KFirstFrame);

        // See Note 2
        CActiveScheduler::Start();

        TPtrC outputFile(params.iOutputFile);
        output-&gt;Save(outputFile);    // Ignore error code.
        }

    CleanupStack::PopAndDestroy(3); // decoder, output, ao
    }

</pre> <p id="GUID-D92FA64D-3ABF-5159-815A-06108FEE6A4E"><a name="GUID-D92FA64D-3ABF-5159-815A-06108FEE6A4E"><!-- --></a><strong>Basic Procedure For Rotation / Mirroring Operation During Decode </strong> </p> <p>The high level steps to set rotation / mirroring operation during decode are as follows: </p> <ol id="GUID-085C04F4-13C2-57F5-9C97-5171CB5ACC1E"><li id="GUID-FAE03E80-DD1E-5833-A10D-3775C8857E75"><a name="GUID-FAE03E80-DD1E-5833-A10D-3775C8857E75"><!-- --></a><p>To create the decoder call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DA07559-7DDC-32A9-9E09-D557348D46DE"><code class="apiname">CImageDecoder::FileNewL()</code></a> or <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-00FB83E8-3759-32BE-B6E8-6F04EC60A909"><code class="apiname">CImageDecoder::DataNewL()</code></a>, using the <code class="codeph">TOptions</code> parameter to request the desired functionality from the decoder. </p> </li> <li id="GUID-00393EB0-413B-59DC-BCD6-22511ECAB9EE"><a name="GUID-00393EB0-413B-59DC-BCD6-22511ECAB9EE"><!-- --></a><p>In order to rotate the image call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-6DB314D3-4B0F-3DA7-98A5-43C6B121B810"><code class="apiname">CImageDecoder::EOptionRotation()</code></a> and for vertical mirroring call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-F0973A0F-AE96-3781-8D44-09019D87F8A3"><code class="apiname">CImageDecoder::EOptionMirrorVerticalAxis()</code></a>. </p> </li> <li id="GUID-E6E176CE-8DA8-57BE-9C6B-4B0C367D82FE"><a name="GUID-E6E176CE-8DA8-57BE-9C6B-4B0C367D82FE"><!-- --></a><p>Then you need to obtain the size of the bitmap which holds the output of the operation being performed during decode, call the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B8F6B2B5-F99B-3C4F-B2AD-0B378777D9B0"><code class="apiname">CImageDecoder::GetDestinationSize()</code></a> function. </p> </li> <li id="GUID-758730D6-F264-5690-BD11-9575A0ABECD6"><a name="GUID-758730D6-F264-5690-BD11-9575A0ABECD6"><!-- --></a><p>Finally start the decoding operation by calling <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-8118AC37-471E-3CB6-9F71-4E93507DDE57"><code class="apiname">CImageDecoder::Convert()</code></a> and use the <code class="codeph">CFbsBitmap</code> obtained by <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-B8F6B2B5-F99B-3C4F-B2AD-0B378777D9B0"><code class="apiname">CImageDecoder::GetDestinationSize()</code></a>. </p> </li> </ol> <p><strong>Example </strong> </p> <p>The example below shows how to peform clipping and rotation operation during decode: </p> <pre class="codeblock">

void CIclExample::ClipAndRotateDuringDecode()
    {
    TRect clipRect(TPoint(50, 65), TSize(170, 160));    // The wheel in thumbimage.jpg
    TSize finalSize;

    // The decoder must support *all* the operations we're going to perform.
    TUint options =    CImageDecoder::EOptionExtRotation |
                    CImageDecoder::EOptionExtMirrorHorizontalAxis |
                    CImageDecoder::EOptionExtCrop |
                    CImageDecoder::EOptionExtScaling;

    // The installed decoders must support *all* the operations requested in aOptions.
    _LIT(KInputFile, "c:\\ICLExample\\thumbimage.jpg");
    CImageDecoder* decoder = CImageDecoder::FileNewL(iFs, KInputFile, static_cast&lt;CImageDecoder::TOptions&gt;(options));
    CleanupStack::PushL(decoder);

    const TFrameInfo&amp; frameInfo = decoder-&gt;FrameInfo(KFirstFrame);
    CFbsBitmap* output = new(ELeave) CFbsBitmap();
    CleanupStack::PushL(output);
    User::LeaveIfError(output-&gt;Create(frameInfo.iFrameSizeInPixels, frameInfo.iFrameDisplayMode));

    CActiveListener* ao = CActiveListener::NewLC();

    TImageConvOperation* operation = decoder-&gt;OperationL();
    TImageConvScaler* scaler = decoder-&gt;ScalerL();

    TInt i = 0;
    while (KDecodeParams[i].iOutputFile != NULL)
        {
        const TDecodeParams&amp; params = KDecodeParams[i++];

        operation-&gt;ClearOperationStack();
        if (params.iRotate90)
            {
            operation-&gt;AddOperationL(TImageConvOperation::ERotation90DegreesClockwise);
            }

        if (params.iMirrorVerticalAxis)
            {
            operation-&gt;AddOperationL(TImageConvOperation::EMirrorVerticalAxis);
            }

        // Some codecs may have a limit on the amount of scaling they can do.
        scaler-&gt;SetScalingL(params.iScalingCoeff, TImageConvScaler::EMaximumQuality);

        // Setting the clipping rect to NULL will decode the whole image.
        decoder-&gt;SetClippingRectL(params.iClip ? &amp;clipRect : NULL);
        User::LeaveIfError(decoder-&gt;GetDestinationSize(finalSize, KFirstFrame));
        User::LeaveIfError(output-&gt;Resize(finalSize));

        // See Note 1
        ao-&gt;Initialize();
        decoder-&gt;Convert(&amp;ao-&gt;iStatus, *output, KFirstFrame);

        // See Note 2
        CActiveScheduler::Start();

        TPtrC outputFile(params.iOutputFile);
        output-&gt;Save(outputFile);    // Ignore error code.
        }

    CleanupStack::PopAndDestroy(3); // decoder, output, ao
    }

</pre> <p id="GUID-466BDF59-39CE-5631-9CE1-83615C3D92A1"><a name="GUID-466BDF59-39CE-5631-9CE1-83615C3D92A1"><!-- --></a><strong>Basic Procedure For Rotation / Mirroring Operation During Encode</strong> </p> <p>The high level steps to set rotation / mirroring during encode are as follows: </p> <ol id="GUID-15EB693F-5149-579B-83C6-20EC69AE3436"><li id="GUID-CC6F230B-1478-5E81-9D1C-48B917DC4E7B"><a name="GUID-CC6F230B-1478-5E81-9D1C-48B917DC4E7B"><!-- --></a><p>To create the encoder call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-737DA130-9A66-39E2-9E68-2E65F37E02C8.html#GUID-1F25CC18-A8E4-3E1D-BA3D-F5F472E20CC0"><code class="apiname">CImageEncoder::FileNewL()</code></a> or <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-737DA130-9A66-39E2-9E68-2E65F37E02C8.html#GUID-51ECB4D3-5A87-35E7-82EB-DF2BAEAB2CAC"><code class="apiname">CImageEncoder::DataNewL()</code></a> and a bitmap holding the image which is to be encoded. </p> </li> <li id="GUID-85932A49-E067-518B-97F2-044A5F336DB7"><a name="GUID-85932A49-E067-518B-97F2-044A5F336DB7"><!-- --></a><p>To request an operation extension call, <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-737DA130-9A66-39E2-9E68-2E65F37E02C8.html#GUID-DE7E1ACD-9619-3D42-B29F-4909DB491630"><code class="apiname">CImageEncoder::OperationL()</code></a>. If the extension is supported then a T class pointer is returned which gives access to the codec extension. <code class="codeph">TImageConvOperation</code> has the extension function for rotation, and mirroring operation. </p> </li> <li id="GUID-BF922F17-05D3-5044-A5FE-A8B18BACC257"><a name="GUID-BF922F17-05D3-5044-A5FE-A8B18BACC257"><!-- --></a><p>To add multiple transformation operations call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8B339FC8-C565-3992-965D-DCE097110937.html#GUID-1A9C2AA5-F6F7-3BDE-839F-75C307B8B789"><code class="apiname">TImageConvOperation::AddOperationL()</code></a>. And to remove the transformation operation call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8B339FC8-C565-3992-965D-DCE097110937.html#GUID-49D6254B-9CCF-3623-AE1C-DF750632AC14"><code class="apiname">TImageConvOperation::ClearOperationStack()</code></a>. </p> <p>The rotations defined are: </p> <ul><li id="GUID-0CCFD0EE-9039-54C6-8D2E-68DB0C10C143"><a name="GUID-0CCFD0EE-9039-54C6-8D2E-68DB0C10C143"><!-- --></a><p>Clockwise rotation 90 degrees. </p> </li> <li id="GUID-36E35E45-FE83-5A6B-BF73-12A9BA027C6C"><a name="GUID-36E35E45-FE83-5A6B-BF73-12A9BA027C6C"><!-- --></a><p>Clockwise rotation 180 degrees. </p> </li> <li id="GUID-454E31B3-CE8F-5786-B14D-4C8EB6B43F02"><a name="GUID-454E31B3-CE8F-5786-B14D-4C8EB6B43F02"><!-- --></a><p>Clockwise rotation 270 degrees. </p> </li> <li id="GUID-5F5B89F5-16B1-5025-B5B7-4445092521CB"><a name="GUID-5F5B89F5-16B1-5025-B5B7-4445092521CB"><!-- --></a><p>Horizontal axis mirroring. </p> </li> <li id="GUID-0DA0FD9A-FF1B-58E6-BD5B-6F98A350D741"><a name="GUID-0DA0FD9A-FF1B-58E6-BD5B-6F98A350D741"><!-- --></a><p>Vertical axis mirroring. </p> </li> </ul> </li> <li id="GUID-5FF035AB-DB18-5793-AC59-BA7084676585"><a name="GUID-5FF035AB-DB18-5793-AC59-BA7084676585"><!-- --></a><p>Finally call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8F2953B2-E64E-3D8B-B30B-B35B373368D4.html#GUID-8118AC37-471E-3CB6-9F71-4E93507DDE57"><code class="apiname">CImageDecoder::Convert()</code></a> to decode the image. At the end of the <code class="codeph">Convert()</code> call, the waiting application output in the main application is signalled and the bitmap or YUV image is encoded into a transformed <code>JPEG</code> based on the operations applied, assuming that no error is returned. </p> <p> <strong>NOTE:</strong> The transformation operations are only supported by the images which are multiples of Minimum Coded Unit (MCU). </p> </li> </ol> <p><strong>Example </strong> </p> <p>The example below shows how to peform rotation / mirrioring operation during encode: </p> <pre class="codeblock">

void CIclExample::EncodeBitmapToFileUsingOperationExtensionL(const TDesC&amp; aSrcFileName, const TDesC&amp; aDestFileName)
    {
    // Create the encoder, passing the filename. 
    // If the image is not recognised or valid then the call will leave with an error    
    CImageEncoder* jpegImageEncoder = CImageEncoder::FileNewL(iFs, aDestFileName, CImageEncoder::EOptionNone, KImageTypeJPGUid);
    CleanupStack::PushL(jpegImageEncoder);
    
    // Create a CFbsBitmap to store the source bitmap to encode
    CFbsBitmap* sourceBitmap = new(ELeave) CFbsBitmap;
    CleanupStack::PushL(sourceBitmap);

    User::LeaveIfError(sourceBitmap-&gt;Create(TSize(20,30), EColor16M));
    User::LeaveIfError(sourceBitmap-&gt;Load(aSrcFileName));
    
    // Create operation extension
    TImageConvOperation* operation = jpegImageEncoder-&gt;OperationL();
    
    // Add Rotate 90degrees operation
    operation-&gt;AddOperationL(TImageConvOperation::ERotation90DegreesClockwise); 
    //NOTE: Multiple operations can be added
    
    // See Note 1
    CActiveListener* activeListener = CreateAndInitializeActiveListenerLC();

    // Convert the image
    jpegImageEncoder-&gt;Convert(&amp;activeListener-&gt;iStatus, *sourceBitmap, NULL);

    // See Note 2
    CActiveScheduler::Start();
    User::LeaveIfError(activeListener-&gt;iStatus.Int());// encode complete either display the image or report an error.
    
    CleanupStack::PopAndDestroy(3); // jpegImageEncoder, sourceBitmap and activeListener
    }
</pre> </div> </div><h3>Related concepts</h3><ul><li><a href="GUID-88091838-03FC-550F-9A3D-DA70907EF955.html">Imaging Frameworks overview</a></li><li><a href="GUID-C0B39D73-0A3C-5289-A774-7BE590037404.html"> Bitmap Transform Library
                Overview</a></li><li><a href="GUID-9D6C086F-7621-5522-AE0B-81CBD5E99125.html">Bitmap Transform Library Guide</a></li><li><a href="#GUID-E6692CDA-9E24-57AE-9BC2-14D68D6480C3">Enhanced Features for Encoder and
                Decoder Tutorial</a></li></ul></div></div><div class="footer"><p class="metadata">Last updated October 9th, 2009</p><hr /><div class="copy">© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-E6692CDA-9E24-57AE-9BC2-14D68D6480C3.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:03:52 GMT -->
</html>