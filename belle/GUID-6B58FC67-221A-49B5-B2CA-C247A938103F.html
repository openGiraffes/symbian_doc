
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6B58FC67-221A-49B5-B2CA-C247A938103F.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:49:40 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Symbian exception handling" /><meta name="abstract" content="Introduction to the trap and leave mechanism used in Symbian code instead of standard C++ exceptions." /><meta name="description" content="Introduction to the trap and leave mechanism used in Symbian code instead of standard C++ exceptions." /><meta name="DC.Relation" scheme="URI" content="GUID-226AF3DB-3C92-4B11-B31C-B26492B6B900" /><meta name="DC.Relation" scheme="URI" content="GUID-B2DDCCB6-4350-4A67-9015-DE7094C0F590" /><meta name="DC.Relation" scheme="URI" content="GUID-C3206E31-251C-4AFC-90C2-04B38CCF8E18" /><meta name="DC.Relation" scheme="URI" content="GUID-86C9DACB-DCCF-43F6-BCEE-91144F4EADC8_overview-GUID-2CA5C27E-A526-4B26-941B-85F0B32E1FFA" /><meta name="DC.Relation" scheme="URI" content="GUID-C3206E31-251C-4AFC-90C2-04B38CCF8E18" /><meta name="DC.Relation" scheme="URI" content="GUID-3642FBBC-53B8-4BA7-926C-09DC50AF1B20" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-6B58FC67-221A-49B5-B2CA-C247A938103F" /><meta name="DC.Language" content="en" /><title>Symbian exception handling </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-6B58FC67-221A-49B5-B2CA-C247A938103F">Symbian exception handling</h1><div><p>Introduction to the trap and leave mechanism used in Symbian
code instead of standard C++ exceptions.</p>
<div id="GUID-03C6FE92-FFF0-41EC-9611-1D0E6A2E3B08"><h3 class="section-title">Leaves are lightweight exceptions</h3><p>A leave
is equivalent to throwing in standard C++ exception handling. Like
C++ exceptions, leaves are used to propagate errors to where they
can be handled.</p><div class="p">A leave may occur in a function if it:<ul>
<li><p>calls one of the functions in class <code class="codeph">User</code> that
cause a leave, such as <code class="codeph">User::Leave()</code> or <code class="codeph">User::LeaveIfError()</code>.</p></li>
<li><p>uses the Symbian overloaded form of <code class="codeph">operator new</code>, which takes <code class="codeph">ELeave</code> as a parameter, and there is
insufficient remaining memory to allocate the object. </p></li>
<li><p>calls another function that may leave (for either of the reasons
above) without using a <code class="codeph">TRAP</code> harness.</p></li>
</ul>There is a naming convention to indicate the potential for a
leave within a function.  If a function may leave, its name must end
with a trailing L. This convention is strictly adhered to in Symbian
code.</div></div>
<div id="GUID-6B4D4DE1-160D-4AD6-9232-E80A55ED7A26"><h3 class="section-title">Handling a leave using TRAP or TRAPD</h3>The <code class="codeph">TRAP</code> and <code class="codeph">TRAPD</code> macros correspond to the <code class="codeph">try</code> and <code class="codeph">catch {…}</code> of C++ standard exception
handling. You place a call to a function that may leave inside a <code class="codeph">TRAP</code> harness and then test whether the function resulted
in a leave. For example:<pre class="codeblock">// Declare and intitialize a variable to store
// the leave code generated by MayLeaveL().
TInt result = KErrNone;

// Wrap the call to the leaving function 
// inside a trap harness.
TRAP( result, MayLeaveL() );

// Check result to find out if a leave
// occurred.
if ( result != KErrNone )    
   {    
   // Test for individual leave values
   // and handle as appropriate.
   }</pre>The <code class="codeph">TRAP</code> and <code class="codeph">TRAPD</code> macros differ only in that <code class="codeph">TRAPD</code> declares and initializes
the variable in which the leave error code is returned. So the code
above could be rewritten more simply:<pre class="codeblock">// The variable result is automatically declared and 
// initialized to KErrNone by the TRAPD macro.
TRAPD( result, MayLeaveL() );

if ( result != KErrNone )    
   {    
   ...
   }</pre><code class="codeph">TRAP</code> macros can be nested to catch
and handle leaves at different levels, where they can best be dealt
with. This allows you to propagate an error from its point of detection
to a handler higher up the function call chain without needing to
add conditional logic to the intermediate functions. Each <code class="codeph">TRAP</code> has an impact on executable size and execution speed,
so the number of traps should be minimized. <p></p></div>
<div id="GUID-20C6E3D1-B583-46B5-8EAA-282B9D3F3D7A"><h3 class="section-title">Comparing a leave and a panic</h3><p>All leaves
generated within an application should ultimately be trapped to ensure
that errors are handled gracefully. A leave that is not trapped will
cause the thread to terminate, resulting in poor user experience.
 The Qt and AVKON application frameworks contain a top-level trap
in the main application thread.</p><p>In contrast, a call to the static
function <code class="codeph">User::Panic()</code> cannot be caught and handled.
A panic always terminates the thread in which it is occurs. Panics
are only useful for tracking down programming errors during development.
The most common use of panics is inside a call to <code class="codeph">__ASSERT_DEBUG</code>, which is equivalent to the <code class="codeph">assert</code> macro used in
C and C++ code. </p></div>
<div id="GUID-B4D49ED2-760A-4D18-AA3B-0647D4801F73"><h3 class="section-title">Copyright note</h3><p>Some of the material in this
topic is based with permission on a Symbian Foundation wiki article <cite>Leaves and the Cleanup Stack</cite> which is part of the series <cite>The Fundamentals of Symbian C++</cite>. The version used was that
available at <a href="http://developer.symbian.org/" target="_blank">http://developer.symbian.org/</a> on 3 November 2010. The content in this page is licensed
under the Creative Commons Attribution-Share Alike 2.0 UK: England
&amp; Wales License (<a href="http://creativecommons.org/licenses/by-sa/2.0/uk" target="_blank">http://creativecommons.org/licenses/by-sa/2.0/uk</a>).</p></div>
</div><h3>Related concepts</h3><ul><li><a href="GUID-226AF3DB-3C92-4B11-B31C-B26492B6B900.html">Using
the cleanup stack</a></li><li><a href="GUID-B2DDCCB6-4350-4A67-9015-DE7094C0F590.html">Assertions
and panics</a></li><li><a href="GUID-C3206E31-251C-4AFC-90C2-04B38CCF8E18.html">Introduction
to Symbian C++ development</a></li></ul></div></div><div class="footer"><p class="metadata">Last updated November 19th, 2010</p><hr /><div class="copy">© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6B58FC67-221A-49B5-B2CA-C247A938103F.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:49:40 GMT -->
</html>