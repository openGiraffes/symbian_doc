<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/src_2libvorbis_2lib_2psy_8c_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:19:05 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Example Code: examples/SFExamples/oggvorbiscodec/src/libvorbis/lib/psy.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<h1>examples/SFExamples/oggvorbiscodec/src/libvorbis/lib/psy.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/********************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *                                                                  *</span>
<a name="l00003"></a>00003 <span class="comment"> * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *</span>
<a name="l00004"></a>00004 <span class="comment"> * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *</span>
<a name="l00005"></a>00005 <span class="comment"> * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *</span>
<a name="l00006"></a>00006 <span class="comment"> * IN &#39;COPYING&#39;. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *</span>
<a name="l00007"></a>00007 <span class="comment"> *                                                                  *</span>
<a name="l00008"></a>00008 <span class="comment"> * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2002             *</span>
<a name="l00009"></a>00009 <span class="comment"> * by the XIPHOPHORUS Company http://www.xiph.org/                  *</span>
<a name="l00010"></a>00010 <span class="comment"> *                                                                  *</span>
<a name="l00011"></a>00011 <span class="comment"> ********************************************************************</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment"> function: psychoacoustics not including preecho</span>
<a name="l00014"></a>00014 <span class="comment"> last mod: $Id: psy.c 7187 2004-07-20 07:24:27Z xiphmont $</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> ********************************************************************/</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;vorbis/codec.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;codec_internal.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;masking.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;psy.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;os.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;lpc.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;smallft.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;scales.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;misc.h&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#define NEGINF -9999.f</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">double</span> stereo_threshholds[]={0.0, .5, 1.0, 1.5, 2.5, 4.5, 8.5, 16.5, 9e10};
<a name="l00033"></a>00033 <span class="keyword">static</span> <span class="keywordtype">double</span> stereo_threshholds_limited[]={0.0, .5, 1.0, 1.5, 2.0, 2.5, 4.5, 8.5, 9e10};
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <a class="code" href="structvorbis__look__psy__global.html">vorbis_look_psy_global</a> *_vp_global_look(<a class="code" href="structvorbis__info.html">vorbis_info</a> *vi){
<a name="l00036"></a>00036   <a class="code" href="structcodec__setup__info.html">codec_setup_info</a> *ci=(<a class="code" href="structcodec__setup__info.html">codec_setup_info</a>*)vi-&gt;codec_setup;
<a name="l00037"></a>00037   <a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *gi=&amp;ci-&gt;psy_g_param;
<a name="l00038"></a>00038   <a class="code" href="structvorbis__look__psy__global.html">vorbis_look_psy_global</a> *look=(<a class="code" href="structvorbis__look__psy__global.html">vorbis_look_psy_global</a>*)_ogg_calloc(1,<span class="keyword">sizeof</span>(*look));
<a name="l00039"></a>00039 
<a name="l00040"></a>00040   look-&gt;channels=vi-&gt;channels;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   look-&gt;ampmax=-9999.;
<a name="l00043"></a>00043   look-&gt;gi=gi;
<a name="l00044"></a>00044   <span class="keywordflow">return</span>(look);
<a name="l00045"></a>00045 }
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keywordtype">void</span> _vp_global_free(<a class="code" href="structvorbis__look__psy__global.html">vorbis_look_psy_global</a> *look){
<a name="l00048"></a>00048   <span class="keywordflow">if</span>(look){
<a name="l00049"></a>00049     memset(look,0,<span class="keyword">sizeof</span>(*look));
<a name="l00050"></a>00050     _ogg_free(look);
<a name="l00051"></a>00051   }
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keywordtype">void</span> _vi_gpsy_free(<a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *i){
<a name="l00055"></a>00055   <span class="keywordflow">if</span>(i){
<a name="l00056"></a>00056     memset(i,0,<span class="keyword">sizeof</span>(*i));
<a name="l00057"></a>00057     _ogg_free(i);
<a name="l00058"></a>00058   }
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="keywordtype">void</span> _vi_psy_free(<a class="code" href="structvorbis__info__psy.html">vorbis_info_psy</a> *i){
<a name="l00062"></a>00062   <span class="keywordflow">if</span>(i){
<a name="l00063"></a>00063     memset(i,0,<span class="keyword">sizeof</span>(*i));
<a name="l00064"></a>00064     _ogg_free(i);
<a name="l00065"></a>00065   }
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">void</span> min_curve(<span class="keywordtype">float</span> *c,
<a name="l00069"></a>00069                        <span class="keywordtype">float</span> *c2){
<a name="l00070"></a>00070   <span class="keywordtype">int</span> i;  
<a name="l00071"></a>00071   <span class="keywordflow">for</span>(i=0;i&lt;EHMER_MAX;i++)<span class="keywordflow">if</span>(c2[i]&lt;c[i])c[i]=c2[i];
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 <span class="keyword">static</span> <span class="keywordtype">void</span> max_curve(<span class="keywordtype">float</span> *c,
<a name="l00074"></a>00074                        <span class="keywordtype">float</span> *c2){
<a name="l00075"></a>00075   <span class="keywordtype">int</span> i;  
<a name="l00076"></a>00076   <span class="keywordflow">for</span>(i=0;i&lt;EHMER_MAX;i++)if(c2[i]&gt;c[i])c[i]=c2[i];
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keywordtype">void</span> attenuate_curve(<span class="keywordtype">float</span> *c,<span class="keywordtype">float</span> att){
<a name="l00080"></a>00080   <span class="keywordtype">int</span> i;
<a name="l00081"></a>00081   <span class="keywordflow">for</span>(i=0;i&lt;EHMER_MAX;i++)
<a name="l00082"></a>00082     c[i]+=att;
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="keyword">static</span> <span class="keywordtype">float</span> ***setup_tone_curves(<span class="keywordtype">float</span> curveatt_dB[P_BANDS],<span class="keywordtype">float</span> binHz,<span class="keywordtype">int</span> n,
<a name="l00087"></a>00087                                   <span class="keywordtype">float</span> center_boost, <span class="keywordtype">float</span> center_decay_rate){
<a name="l00088"></a>00088   <span class="keywordtype">int</span> i,j,k,m;
<a name="l00089"></a>00089   <span class="keywordtype">float</span> ath[EHMER_MAX];
<a name="l00090"></a>00090   <span class="comment">//float workc[P_BANDS][P_LEVELS][EHMER_MAX];</span>
<a name="l00091"></a>00091   <span class="comment">//float athc[P_LEVELS][EHMER_MAX];</span>
<a name="l00092"></a>00092   <span class="keywordtype">float</span> *brute_buffer= (<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*brute_buffer));<span class="comment">//alloca(n*sizeof(*brute_buffer));//patch</span>
<a name="l00093"></a>00093   <span class="keywordtype">float</span> *brute_buffer_cpy = brute_buffer;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095   <span class="keywordtype">float</span> ***ret=(<span class="keywordtype">float</span>***)_ogg_malloc(<span class="keyword">sizeof</span>(*ret)*P_BANDS);
<a name="l00096"></a>00096   <span class="keywordtype">float</span> ***workc = (<span class="keywordtype">float</span>***)_ogg_malloc(<span class="keyword">sizeof</span>(*workc)*P_BANDS);       
<a name="l00097"></a>00097   <span class="comment">//added to fix the stack overflow on H4</span>
<a name="l00098"></a>00098   <span class="keywordtype">float</span> **athc = (<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*athc)*P_LEVELS);;
<a name="l00099"></a>00099   <span class="keywordflow">for</span>(i=0;i&lt;P_LEVELS;i++)
<a name="l00100"></a>00100         {
<a name="l00101"></a>00101         athc[i]=(<span class="keywordtype">float</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(**athc)*EHMER_MAX);
<a name="l00102"></a>00102         <span class="keywordflow">for</span>(j=0;j&lt;EHMER_MAX;j++)
<a name="l00103"></a>00103                 {
<a name="l00104"></a>00104         athc[i][j] = 0;
<a name="l00105"></a>00105                 }
<a name="l00106"></a>00106         }<span class="comment">//fix end</span>
<a name="l00107"></a>00107         
<a name="l00108"></a>00108   <span class="comment">//added to fix the stack overflow on H4</span>
<a name="l00109"></a>00109   <span class="keywordflow">for</span>(i=0;i&lt;P_BANDS;i++)
<a name="l00110"></a>00110         {
<a name="l00111"></a>00111         workc[i]=(<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(**workc)*P_LEVELS);
<a name="l00112"></a>00112         <span class="keywordflow">for</span>(j=0;j&lt;P_LEVELS;j++)
<a name="l00113"></a>00113                 {
<a name="l00114"></a>00114         workc[i][j]=(<span class="keywordtype">float</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(***workc)*(EHMER_MAX));
<a name="l00115"></a>00115                 <span class="keywordflow">for</span>(k=0;k&lt;EHMER_MAX;k++)
<a name="l00116"></a>00116                         {
<a name="l00117"></a>00117                 workc[i][j][k] = 0;
<a name="l00118"></a>00118                         }
<a name="l00119"></a>00119                 }
<a name="l00120"></a>00120         }<span class="comment">//fix end</span>
<a name="l00121"></a>00121   
<a name="l00122"></a>00122   
<a name="l00123"></a>00123   <span class="comment">//memset(workc,0,sizeof(workc));</span>
<a name="l00124"></a>00124         
<a name="l00125"></a>00125   <span class="keywordflow">for</span>(i=0;i&lt;P_BANDS;i++){
<a name="l00126"></a>00126     <span class="comment">/* we add back in the ATH to avoid low level curves falling off to</span>
<a name="l00127"></a>00127 <span class="comment">       -infinity and unnecessarily cutting off high level curves in the</span>
<a name="l00128"></a>00128 <span class="comment">       curve limiting (last step). */</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     <span class="comment">/* A half-band&#39;s settings must be valid over the whole band, and</span>
<a name="l00131"></a>00131 <span class="comment">       it&#39;s better to mask too little than too much */</span>  
<a name="l00132"></a>00132     <span class="keywordtype">int</span> ath_offset=i*4;
<a name="l00133"></a>00133     <span class="keywordflow">for</span>(j=0;j&lt;EHMER_MAX;j++){
<a name="l00134"></a>00134       <span class="keywordtype">float</span> min=999.;
<a name="l00135"></a>00135       <span class="keywordflow">for</span>(k=0;k&lt;4;k++)
<a name="l00136"></a>00136         <span class="keywordflow">if</span>(j+k+ath_offset&lt;MAX_ATH){
<a name="l00137"></a>00137           <span class="keywordflow">if</span>(min&gt;ATH[j+k+ath_offset])min=ATH[j+k+ath_offset];
<a name="l00138"></a>00138         }<span class="keywordflow">else</span>{
<a name="l00139"></a>00139           <span class="keywordflow">if</span>(min&gt;ATH[MAX_ATH-1])min=ATH[MAX_ATH-1];
<a name="l00140"></a>00140         }
<a name="l00141"></a>00141       ath[j]=min;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="comment">/* copy curves into working space, replicate the 50dB curve to 30</span>
<a name="l00145"></a>00145 <span class="comment">       and 40, replicate the 100dB curve to 110 */</span>
<a name="l00146"></a>00146     <span class="keywordflow">for</span>(j=0;j&lt;6;j++)
<a name="l00147"></a>00147       memcpy(workc[i][j+2],tonemasks[i][j],EHMER_MAX*<span class="keyword">sizeof</span>(*tonemasks[i][j]));
<a name="l00148"></a>00148     memcpy(workc[i][0],tonemasks[i][0],EHMER_MAX*<span class="keyword">sizeof</span>(*tonemasks[i][0]));
<a name="l00149"></a>00149     memcpy(workc[i][1],tonemasks[i][0],EHMER_MAX*<span class="keyword">sizeof</span>(*tonemasks[i][0]));
<a name="l00150"></a>00150     
<a name="l00151"></a>00151     <span class="comment">/* apply centered curve boost/decay */</span>
<a name="l00152"></a>00152     <span class="keywordflow">for</span>(j=0;j&lt;P_LEVELS;j++){
<a name="l00153"></a>00153       <span class="keywordflow">for</span>(k=0;k&lt;EHMER_MAX;k++){
<a name="l00154"></a>00154         <span class="keywordtype">float</span> adj=center_boost+abs(EHMER_OFFSET-k)*center_decay_rate;
<a name="l00155"></a>00155         <span class="keywordflow">if</span>(adj&lt;0. &amp;&amp; center_boost&gt;0)adj=0.;
<a name="l00156"></a>00156         <span class="keywordflow">if</span>(adj&gt;0. &amp;&amp; center_boost&lt;0)adj=0.;
<a name="l00157"></a>00157         workc[i][j][k]+=adj;
<a name="l00158"></a>00158       }
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="comment">/* normalize curves so the driving amplitude is 0dB */</span>
<a name="l00162"></a>00162     <span class="comment">/* make temp curves with the ATH overlayed */</span>
<a name="l00163"></a>00163     <span class="keywordflow">for</span>(j=0;j&lt;P_LEVELS;j++){
<a name="l00164"></a>00164       attenuate_curve(workc[i][j],curveatt_dB[i]+100.-(j&lt;2?2:j)*10.-P_LEVEL_0);
<a name="l00165"></a>00165       memcpy(athc[j],ath,EHMER_MAX*<span class="keyword">sizeof</span>(**athc));
<a name="l00166"></a>00166       attenuate_curve(athc[j],+100.-j*10.f-P_LEVEL_0);
<a name="l00167"></a>00167       max_curve(athc[j],workc[i][j]);
<a name="l00168"></a>00168     }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     <span class="comment">/* Now limit the louder curves.</span>
<a name="l00171"></a>00171 <span class="comment">       </span>
<a name="l00172"></a>00172 <span class="comment">       the idea is this: We don&#39;t know what the playback attenuation</span>
<a name="l00173"></a>00173 <span class="comment">       will be; 0dB SL moves every time the user twiddles the volume</span>
<a name="l00174"></a>00174 <span class="comment">       knob. So that means we have to use a single &#39;most pessimal&#39; curve</span>
<a name="l00175"></a>00175 <span class="comment">       for all masking amplitudes, right?  Wrong.  The *loudest* sound</span>
<a name="l00176"></a>00176 <span class="comment">       can be in (we assume) a range of ...+100dB] SL.  However, sounds</span>
<a name="l00177"></a>00177 <span class="comment">       20dB down will be in a range ...+80], 40dB down is from ...+60],</span>
<a name="l00178"></a>00178 <span class="comment">       etc... */</span>
<a name="l00179"></a>00179     
<a name="l00180"></a>00180     <span class="keywordflow">for</span>(j=1;j&lt;P_LEVELS;j++){
<a name="l00181"></a>00181       min_curve(athc[j],athc[j-1]);
<a name="l00182"></a>00182       min_curve(workc[i][j],athc[j]);
<a name="l00183"></a>00183     }
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordflow">for</span>(i=0;i&lt;P_BANDS;i++){
<a name="l00187"></a>00187     <span class="keywordtype">int</span> hi_curve,lo_curve,bin;
<a name="l00188"></a>00188     ret[i]=(<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(**ret)*P_LEVELS);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     <span class="comment">/* low frequency curves are measured with greater resolution than</span>
<a name="l00191"></a>00191 <span class="comment">       the MDCT/FFT will actually give us; we want the curve applied</span>
<a name="l00192"></a>00192 <span class="comment">       to the tone data to be pessimistic and thus apply the minimum</span>
<a name="l00193"></a>00193 <span class="comment">       masking possible for a given bin.  That means that a single bin</span>
<a name="l00194"></a>00194 <span class="comment">       could span more than one octave and that the curve will be a</span>
<a name="l00195"></a>00195 <span class="comment">       composite of multiple octaves.  It also may mean that a single</span>
<a name="l00196"></a>00196 <span class="comment">       bin may span &gt; an eighth of an octave and that the eighth</span>
<a name="l00197"></a>00197 <span class="comment">       octave values may also be composited. */</span>
<a name="l00198"></a>00198     
<a name="l00199"></a>00199     <span class="comment">/* which octave curves will we be compositing? */</span>
<a name="l00200"></a>00200     bin=floor(fromOC(i*.5)/binHz);
<a name="l00201"></a>00201     lo_curve=  ceil(toOC(bin*binHz+1)*2);
<a name="l00202"></a>00202     hi_curve=  floor(toOC((bin+1)*binHz)*2);
<a name="l00203"></a>00203     <span class="keywordflow">if</span>(lo_curve&gt;i)lo_curve=i;
<a name="l00204"></a>00204     <span class="keywordflow">if</span>(lo_curve&lt;0)lo_curve=0;
<a name="l00205"></a>00205     <span class="keywordflow">if</span>(hi_curve&gt;=P_BANDS)hi_curve=P_BANDS-1;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="keywordflow">for</span>(m=0;m&lt;P_LEVELS;m++){
<a name="l00208"></a>00208       ret[i][m]=(<span class="keywordtype">float</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(***ret)*(EHMER_MAX+2));
<a name="l00209"></a>00209       
<a name="l00210"></a>00210       <span class="keywordflow">for</span>(j=0;j&lt;n;j++)brute_buffer[j]=999.;
<a name="l00211"></a>00211       
<a name="l00212"></a>00212       <span class="comment">/* render the curve into bins, then pull values back into curve.</span>
<a name="l00213"></a>00213 <span class="comment">         The point is that any inherent subsampling aliasing results in</span>
<a name="l00214"></a>00214 <span class="comment">         a safe minimum */</span>
<a name="l00215"></a>00215       <span class="keywordflow">for</span>(k=lo_curve;k&lt;=hi_curve;k++){
<a name="l00216"></a>00216         <span class="keywordtype">int</span> l=0;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         <span class="keywordflow">for</span>(j=0;j&lt;EHMER_MAX;j++){
<a name="l00219"></a>00219           <span class="keywordtype">int</span> lo_bin= fromOC(j*.125+k*.5-2.0625)/binHz;
<a name="l00220"></a>00220           <span class="keywordtype">int</span> hi_bin= fromOC(j*.125+k*.5-1.9375)/binHz+1;
<a name="l00221"></a>00221           
<a name="l00222"></a>00222           <span class="keywordflow">if</span>(lo_bin&lt;0)lo_bin=0;
<a name="l00223"></a>00223           <span class="keywordflow">if</span>(lo_bin&gt;n)lo_bin=n;
<a name="l00224"></a>00224           <span class="keywordflow">if</span>(lo_bin&lt;l)l=lo_bin;
<a name="l00225"></a>00225           <span class="keywordflow">if</span>(hi_bin&lt;0)hi_bin=0;
<a name="l00226"></a>00226           <span class="keywordflow">if</span>(hi_bin&gt;n)hi_bin=n;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228           <span class="keywordflow">for</span>(;l&lt;hi_bin &amp;&amp; l&lt;n;l++)
<a name="l00229"></a>00229             <span class="keywordflow">if</span>(brute_buffer[l]&gt;workc[k][m][j])
<a name="l00230"></a>00230               brute_buffer[l]=workc[k][m][j];
<a name="l00231"></a>00231         }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233         <span class="keywordflow">for</span>(;l&lt;n;l++)
<a name="l00234"></a>00234           <span class="keywordflow">if</span>(brute_buffer[l]&gt;workc[k][m][EHMER_MAX-1])
<a name="l00235"></a>00235             brute_buffer[l]=workc[k][m][EHMER_MAX-1];
<a name="l00236"></a>00236 
<a name="l00237"></a>00237       }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239       <span class="comment">/* be equally paranoid about being valid up to next half ocatve */</span>
<a name="l00240"></a>00240       <span class="keywordflow">if</span>(i+1&lt;P_BANDS){
<a name="l00241"></a>00241         <span class="keywordtype">int</span> l=0;
<a name="l00242"></a>00242         k=i+1;
<a name="l00243"></a>00243         <span class="keywordflow">for</span>(j=0;j&lt;EHMER_MAX;j++){
<a name="l00244"></a>00244           <span class="keywordtype">int</span> lo_bin= fromOC(j*.125+i*.5-2.0625)/binHz;
<a name="l00245"></a>00245           <span class="keywordtype">int</span> hi_bin= fromOC(j*.125+i*.5-1.9375)/binHz+1;
<a name="l00246"></a>00246           
<a name="l00247"></a>00247           <span class="keywordflow">if</span>(lo_bin&lt;0)lo_bin=0;
<a name="l00248"></a>00248           <span class="keywordflow">if</span>(lo_bin&gt;n)lo_bin=n;
<a name="l00249"></a>00249           <span class="keywordflow">if</span>(lo_bin&lt;l)l=lo_bin;
<a name="l00250"></a>00250           <span class="keywordflow">if</span>(hi_bin&lt;0)hi_bin=0;
<a name="l00251"></a>00251           <span class="keywordflow">if</span>(hi_bin&gt;n)hi_bin=n;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253           <span class="keywordflow">for</span>(;l&lt;hi_bin &amp;&amp; l&lt;n;l++)
<a name="l00254"></a>00254             <span class="keywordflow">if</span>(brute_buffer[l]&gt;workc[k][m][j])
<a name="l00255"></a>00255               brute_buffer[l]=workc[k][m][j];
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258         <span class="keywordflow">for</span>(;l&lt;n;l++)
<a name="l00259"></a>00259           <span class="keywordflow">if</span>(brute_buffer[l]&gt;workc[k][m][EHMER_MAX-1])
<a name="l00260"></a>00260             brute_buffer[l]=workc[k][m][EHMER_MAX-1];
<a name="l00261"></a>00261 
<a name="l00262"></a>00262       }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 
<a name="l00265"></a>00265       <span class="keywordflow">for</span>(j=0;j&lt;EHMER_MAX;j++){
<a name="l00266"></a>00266         <span class="keywordtype">int</span> bin=fromOC(j*.125+i*.5-2.)/binHz;
<a name="l00267"></a>00267         <span class="keywordflow">if</span>(bin&lt;0){
<a name="l00268"></a>00268           ret[i][m][j+2]=-999.;
<a name="l00269"></a>00269         }<span class="keywordflow">else</span>{
<a name="l00270"></a>00270           <span class="keywordflow">if</span>(bin&gt;=n){
<a name="l00271"></a>00271             ret[i][m][j+2]=-999.;
<a name="l00272"></a>00272           }<span class="keywordflow">else</span>{
<a name="l00273"></a>00273             ret[i][m][j+2]=brute_buffer[bin];
<a name="l00274"></a>00274           }
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276       }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278       <span class="comment">/* add fenceposts */</span>
<a name="l00279"></a>00279       <span class="keywordflow">for</span>(j=0;j&lt;EHMER_OFFSET;j++)
<a name="l00280"></a>00280         <span class="keywordflow">if</span>(ret[i][m][j+2]&gt;-200.f)<span class="keywordflow">break</span>;  
<a name="l00281"></a>00281       ret[i][m][0]=j;
<a name="l00282"></a>00282       
<a name="l00283"></a>00283       <span class="keywordflow">for</span>(j=EHMER_MAX-1;j&gt;EHMER_OFFSET+1;j--)
<a name="l00284"></a>00284         <span class="keywordflow">if</span>(ret[i][m][j+2]&gt;-200.f)
<a name="l00285"></a>00285           <span class="keywordflow">break</span>;
<a name="l00286"></a>00286       ret[i][m][1]=j;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     }
<a name="l00289"></a>00289   }
<a name="l00290"></a>00290   
<a name="l00291"></a>00291   free(brute_buffer_cpy);       
<a name="l00292"></a>00292   
<a name="l00293"></a>00293   <span class="keywordflow">for</span>(i=0;i&lt;P_BANDS;i++) 
<a name="l00294"></a>00294         { 
<a name="l00295"></a>00295     <span class="keywordflow">for</span>(j=0;j&lt;P_LEVELS;j++) 
<a name="l00296"></a>00296         {
<a name="l00297"></a>00297         _ogg_free(workc[i][j]);
<a name="l00298"></a>00298         } 
<a name="l00299"></a>00299         _ogg_free(workc[i]); 
<a name="l00300"></a>00300     } 
<a name="l00301"></a>00301   _ogg_free(workc); 
<a name="l00302"></a>00302   <span class="keywordflow">for</span>(i=0;i&lt;P_LEVELS;i++)
<a name="l00303"></a>00303         {
<a name="l00304"></a>00304         _ogg_free(athc[i]);
<a name="l00305"></a>00305         }
<a name="l00306"></a>00306   _ogg_free(athc);
<a name="l00307"></a>00307   <span class="keywordflow">return</span>(ret);
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="keywordtype">void</span> _vp_psy_init(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,<a class="code" href="structvorbis__info__psy.html">vorbis_info_psy</a> *vi,
<a name="l00312"></a>00312                   <a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *gi,<span class="keywordtype">int</span> n,<span class="keywordtype">long</span> rate){
<a name="l00313"></a>00313   <span class="keywordtype">long</span> i,j,lo=-99,hi=1;
<a name="l00314"></a>00314   <span class="keywordtype">long</span> maxoc;
<a name="l00315"></a>00315   memset(p,0,<span class="keyword">sizeof</span>(*p));
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   p-&gt;eighth_octave_lines=gi-&gt;eighth_octave_lines;
<a name="l00318"></a>00318   p-&gt;shiftoc=rint(log(gi-&gt;eighth_octave_lines*8.f)/log(2.f))-1;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   p-&gt;firstoc=toOC(.25f*rate*.5/n)*(1&lt;&lt;(p-&gt;shiftoc+1))-gi-&gt;eighth_octave_lines;
<a name="l00321"></a>00321   maxoc=toOC((n+.25f)*rate*.5/n)*(1&lt;&lt;(p-&gt;shiftoc+1))+.5f;
<a name="l00322"></a>00322   p-&gt;total_octave_lines=maxoc-p-&gt;firstoc+1;
<a name="l00323"></a>00323   p-&gt;ath=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*p-&gt;ath));
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   p-&gt;octave=(<span class="keywordtype">long</span> <span class="keywordtype">int</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*p-&gt;octave));
<a name="l00326"></a>00326   p-&gt;bark=(<span class="keywordtype">long</span> <span class="keywordtype">int</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*p-&gt;bark));
<a name="l00327"></a>00327   p-&gt;vi=vi;
<a name="l00328"></a>00328   p-&gt;n=n;
<a name="l00329"></a>00329   p-&gt;rate=rate;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <span class="comment">/* AoTuV HF weighting */</span>
<a name="l00332"></a>00332   p-&gt;m_val = 1.;
<a name="l00333"></a>00333   <span class="keywordflow">if</span>(rate &lt; 26000) p-&gt;m_val = 0;
<a name="l00334"></a>00334   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rate &lt; 38000) p-&gt;m_val = .94;   <span class="comment">/* 32kHz */</span>
<a name="l00335"></a>00335   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rate &gt; 46000) p-&gt;m_val = 1.275; <span class="comment">/* 48kHz */</span>
<a name="l00336"></a>00336   
<a name="l00337"></a>00337   <span class="comment">/* set up the lookups for a given blocksize and sample rate */</span>
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="keywordflow">for</span>(i=0,j=0;i&lt;MAX_ATH-1;i++){
<a name="l00340"></a>00340     <span class="keywordtype">int</span> endpos=rint(fromOC((i+1)*.125-2.)*2*n/rate);
<a name="l00341"></a>00341     <span class="keywordtype">float</span> base=ATH[i];
<a name="l00342"></a>00342     <span class="keywordflow">if</span>(j&lt;endpos){
<a name="l00343"></a>00343       <span class="keywordtype">float</span> delta=(ATH[i+1]-base)/(endpos-j);
<a name="l00344"></a>00344       <span class="keywordflow">for</span>(;j&lt;endpos &amp;&amp; j&lt;n;j++){
<a name="l00345"></a>00345         p-&gt;ath[j]=base+100.;
<a name="l00346"></a>00346         base+=delta;
<a name="l00347"></a>00347       }
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349   }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00352"></a>00352     <span class="keywordtype">float</span> bark=toBARK(rate/(2*n)*i); 
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="keywordflow">for</span>(;lo+vi-&gt;noisewindowlomin&lt;i &amp;&amp; 
<a name="l00355"></a>00355           toBARK(rate/(2*n)*lo)&lt;(bark-vi-&gt;noisewindowlo);lo++)
<a name="l00356"></a>00356     
<a name="l00357"></a>00357     <span class="keywordflow">for</span>(;hi&lt;=n &amp;&amp; (hi&lt;i+vi-&gt;noisewindowhimin ||
<a name="l00358"></a>00358           toBARK(rate/(2*n)*hi)&lt;(bark+vi-&gt;noisewindowhi));hi++)
<a name="l00359"></a>00359     
<a name="l00360"></a>00360     p-&gt;bark[i]=((lo-1)&lt;&lt;16)+(hi-1);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   }
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="keywordflow">for</span>(i=0;i&lt;n;i++)
<a name="l00365"></a>00365     p-&gt;octave[i]=toOC((i+.25f)*.5*rate/n)*(1&lt;&lt;(p-&gt;shiftoc+1))+.5f;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   p-&gt;tonecurves=setup_tone_curves(vi-&gt;toneatt,rate*.5/n,n,
<a name="l00368"></a>00368                                   vi-&gt;tone_centerboost,vi-&gt;tone_decay);
<a name="l00369"></a>00369   
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="comment">/* set up rolling noise median */</span>
<a name="l00372"></a>00372   p-&gt;noiseoffset=(<span class="keywordtype">float</span>**)_ogg_malloc(P_NOISECURVES*<span class="keyword">sizeof</span>(*p-&gt;noiseoffset));
<a name="l00373"></a>00373   <span class="keywordflow">for</span>(i=0;i&lt;P_NOISECURVES;i ++)
<a name="l00374"></a>00374     p-&gt;noiseoffset[i]=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(**p-&gt;noiseoffset));
<a name="l00375"></a>00375   
<a name="l00376"></a>00376   <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00377"></a>00377     <span class="keywordtype">float</span> halfoc=toOC((i+.5)*rate/(2.*n))*2.;
<a name="l00378"></a>00378     <span class="keywordtype">int</span> inthalfoc;
<a name="l00379"></a>00379     <span class="keywordtype">float</span> del;
<a name="l00380"></a>00380     
<a name="l00381"></a>00381     <span class="keywordflow">if</span>(halfoc&lt;0)halfoc=0;
<a name="l00382"></a>00382     <span class="keywordflow">if</span>(halfoc&gt;=P_BANDS-1)halfoc=P_BANDS-1;
<a name="l00383"></a>00383     inthalfoc=(int)halfoc;
<a name="l00384"></a>00384     del=halfoc-inthalfoc;
<a name="l00385"></a>00385     
<a name="l00386"></a>00386     <span class="keywordflow">for</span>(j=0;j&lt;P_NOISECURVES;j++)
<a name="l00387"></a>00387       p-&gt;noiseoffset[j][i]=
<a name="l00388"></a>00388         p-&gt;vi-&gt;noiseoff[j][inthalfoc]*(1.-del) + 
<a name="l00389"></a>00389         p-&gt;vi-&gt;noiseoff[j][inthalfoc+1]*del;
<a name="l00390"></a>00390     
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392 <span class="preprocessor">#if 0</span>
<a name="l00393"></a>00393 <span class="preprocessor"></span>  {
<a name="l00394"></a>00394     <span class="keyword">static</span> <span class="keywordtype">int</span> ls=0;
<a name="l00395"></a>00395     _analysis_output_always(<span class="stringliteral">&quot;noiseoff0&quot;</span>,ls,p-&gt;noiseoffset[0],n,1,0,0);
<a name="l00396"></a>00396     _analysis_output_always(<span class="stringliteral">&quot;noiseoff1&quot;</span>,ls,p-&gt;noiseoffset[1],n,1,0,0);
<a name="l00397"></a>00397     _analysis_output_always(<span class="stringliteral">&quot;noiseoff2&quot;</span>,ls++,p-&gt;noiseoffset[2],n,1,0,0);
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399 <span class="preprocessor">#endif</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>}
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="keywordtype">void</span> _vp_psy_clear(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p){
<a name="l00403"></a>00403   <span class="keywordtype">int</span> i,j;
<a name="l00404"></a>00404   <span class="keywordflow">if</span>(p){
<a name="l00405"></a>00405     <span class="keywordflow">if</span>(p-&gt;ath)_ogg_free(p-&gt;ath);
<a name="l00406"></a>00406     <span class="keywordflow">if</span>(p-&gt;octave)_ogg_free(p-&gt;octave);
<a name="l00407"></a>00407     <span class="keywordflow">if</span>(p-&gt;bark)_ogg_free(p-&gt;bark);
<a name="l00408"></a>00408     <span class="keywordflow">if</span>(p-&gt;tonecurves){
<a name="l00409"></a>00409       <span class="keywordflow">for</span>(i=0;i&lt;P_BANDS;i++){
<a name="l00410"></a>00410         <span class="keywordflow">for</span>(j=0;j&lt;P_LEVELS;j++){
<a name="l00411"></a>00411           _ogg_free(p-&gt;tonecurves[i][j]);
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413         _ogg_free(p-&gt;tonecurves[i]);
<a name="l00414"></a>00414       }
<a name="l00415"></a>00415       _ogg_free(p-&gt;tonecurves);
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417     <span class="keywordflow">if</span>(p-&gt;noiseoffset){
<a name="l00418"></a>00418       <span class="keywordflow">for</span>(i=0;i&lt;P_NOISECURVES;i++){
<a name="l00419"></a>00419         _ogg_free(p-&gt;noiseoffset[i]);
<a name="l00420"></a>00420       }
<a name="l00421"></a>00421       _ogg_free(p-&gt;noiseoffset);
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423     memset(p,0,<span class="keyword">sizeof</span>(*p));
<a name="l00424"></a>00424   }
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="comment">/* octave/(8*eighth_octave_lines) x scale and dB y scale */</span>
<a name="l00428"></a>00428 <span class="keyword">static</span> <span class="keywordtype">void</span> seed_curve(<span class="keywordtype">float</span> *seed,
<a name="l00429"></a>00429                        <span class="keyword">const</span> <span class="keywordtype">float</span> **curves,
<a name="l00430"></a>00430                        <span class="keywordtype">float</span> amp,
<a name="l00431"></a>00431                        <span class="keywordtype">int</span> oc, <span class="keywordtype">int</span> n,
<a name="l00432"></a>00432                        <span class="keywordtype">int</span> linesper,<span class="keywordtype">float</span> dBoffset){
<a name="l00433"></a>00433   <span class="keywordtype">int</span> i,post1;
<a name="l00434"></a>00434   <span class="keywordtype">int</span> seedptr;
<a name="l00435"></a>00435   <span class="keyword">const</span> <span class="keywordtype">float</span> *posts,*curve;
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="keywordtype">int</span> choice=(int)((amp+dBoffset-P_LEVEL_0)*.1f);
<a name="l00438"></a>00438   choice=max(choice,0);
<a name="l00439"></a>00439   choice=min(choice,P_LEVELS-1);
<a name="l00440"></a>00440   posts=curves[choice];
<a name="l00441"></a>00441   curve=posts+2;
<a name="l00442"></a>00442   post1=(int)posts[1];
<a name="l00443"></a>00443   seedptr=oc+(posts[0]-EHMER_OFFSET)*linesper-(linesper&gt;&gt;1);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordflow">for</span>(i=posts[0];i&lt;post1;i++){
<a name="l00446"></a>00446     <span class="keywordflow">if</span>(seedptr&gt;0){
<a name="l00447"></a>00447       <span class="keywordtype">float</span> lin=amp+curve[i];
<a name="l00448"></a>00448       <span class="keywordflow">if</span>(seed[seedptr]&lt;lin)seed[seedptr]=lin;
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450     seedptr+=linesper;
<a name="l00451"></a>00451     <span class="keywordflow">if</span>(seedptr&gt;=n)<span class="keywordflow">break</span>;
<a name="l00452"></a>00452   }
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="keyword">static</span> <span class="keywordtype">void</span> seed_loop(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l00456"></a>00456                       <span class="keyword">const</span> <span class="keywordtype">float</span> ***curves,
<a name="l00457"></a>00457                       <span class="keyword">const</span> <span class="keywordtype">float</span> *f, 
<a name="l00458"></a>00458                       <span class="keyword">const</span> <span class="keywordtype">float</span> *flr,
<a name="l00459"></a>00459                       <span class="keywordtype">float</span> *seed,
<a name="l00460"></a>00460                       <span class="keywordtype">float</span> specmax){
<a name="l00461"></a>00461   <a class="code" href="structvorbis__info__psy.html">vorbis_info_psy</a> *vi=p-&gt;vi;
<a name="l00462"></a>00462   <span class="keywordtype">long</span> n=p-&gt;n,i;
<a name="l00463"></a>00463   <span class="keywordtype">float</span> dBoffset=vi-&gt;max_curve_dB-specmax;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="comment">/* prime the working vector with peak values */</span>
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00468"></a>00468     <span class="keywordtype">float</span> max=f[i];
<a name="l00469"></a>00469     <span class="keywordtype">long</span> oc=p-&gt;octave[i];
<a name="l00470"></a>00470     <span class="keywordflow">while</span>(i+1&lt;n &amp;&amp; p-&gt;octave[i+1]==oc){
<a name="l00471"></a>00471       i++;
<a name="l00472"></a>00472       <span class="keywordflow">if</span>(f[i]&gt;max)max=f[i];
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474     
<a name="l00475"></a>00475     <span class="keywordflow">if</span>(max+6.f&gt;flr[i]){
<a name="l00476"></a>00476       oc=oc&gt;&gt;p-&gt;shiftoc;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478       <span class="keywordflow">if</span>(oc&gt;=P_BANDS)oc=P_BANDS-1;
<a name="l00479"></a>00479       <span class="keywordflow">if</span>(oc&lt;0)oc=0;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481       seed_curve(seed,
<a name="l00482"></a>00482                  curves[oc],
<a name="l00483"></a>00483                  max,
<a name="l00484"></a>00484                  p-&gt;octave[i]-p-&gt;firstoc,
<a name="l00485"></a>00485                  p-&gt;total_octave_lines,
<a name="l00486"></a>00486                  p-&gt;eighth_octave_lines,
<a name="l00487"></a>00487                  dBoffset);
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="keyword">static</span> <span class="keywordtype">void</span> seed_chase(<span class="keywordtype">float</span> *seeds, <span class="keywordtype">int</span> linesper, <span class="keywordtype">long</span> n){
<a name="l00493"></a>00493   <span class="keywordtype">long</span>  *posstack= (<span class="keywordtype">long</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*posstack));<span class="comment">//alloca(n*sizeof(*posstack)); //patch</span>
<a name="l00494"></a>00494   <span class="keywordtype">float</span> *ampstack= (<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*ampstack));<span class="comment">//alloca(n*sizeof(*ampstack)); //patch </span>
<a name="l00495"></a>00495   <span class="keywordtype">long</span> *posstack_cpy = posstack;
<a name="l00496"></a>00496   <span class="keywordtype">float</span> *ampstack_cpy = ampstack;
<a name="l00497"></a>00497   <span class="keywordtype">long</span>   stack=0;
<a name="l00498"></a>00498   <span class="keywordtype">long</span>   pos=0;
<a name="l00499"></a>00499   <span class="keywordtype">long</span>   i;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00502"></a>00502     <span class="keywordflow">if</span>(stack&lt;2){
<a name="l00503"></a>00503       posstack[stack]=i;
<a name="l00504"></a>00504       ampstack[stack++]=seeds[i];
<a name="l00505"></a>00505     }<span class="keywordflow">else</span>{
<a name="l00506"></a>00506       <span class="keywordflow">while</span>(1){
<a name="l00507"></a>00507         <span class="keywordflow">if</span>(seeds[i]&lt;ampstack[stack-1]){
<a name="l00508"></a>00508           posstack[stack]=i;
<a name="l00509"></a>00509           ampstack[stack++]=seeds[i];
<a name="l00510"></a>00510           <span class="keywordflow">break</span>;
<a name="l00511"></a>00511         }<span class="keywordflow">else</span>{
<a name="l00512"></a>00512           <span class="keywordflow">if</span>(i&lt;posstack[stack-1]+linesper){
<a name="l00513"></a>00513             <span class="keywordflow">if</span>(stack&gt;1 &amp;&amp; ampstack[stack-1]&lt;=ampstack[stack-2] &amp;&amp;
<a name="l00514"></a>00514                i&lt;posstack[stack-2]+linesper){
<a name="l00515"></a>00515               <span class="comment">/* we completely overlap, making stack-1 irrelevant.  pop it */</span>
<a name="l00516"></a>00516               stack--;
<a name="l00517"></a>00517               <span class="keywordflow">continue</span>;
<a name="l00518"></a>00518             }
<a name="l00519"></a>00519           }
<a name="l00520"></a>00520           posstack[stack]=i;
<a name="l00521"></a>00521           ampstack[stack++]=seeds[i];
<a name="l00522"></a>00522           <span class="keywordflow">break</span>;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525       }
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527   }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529   <span class="comment">/* the stack now contains only the positions that are relevant. Scan</span>
<a name="l00530"></a>00530 <span class="comment">     &#39;em straight through */</span>
<a name="l00531"></a>00531 
<a name="l00532"></a>00532   <span class="keywordflow">for</span>(i=0;i&lt;stack;i++){
<a name="l00533"></a>00533     <span class="keywordtype">long</span> endpos;
<a name="l00534"></a>00534     <span class="keywordflow">if</span>(i&lt;stack-1 &amp;&amp; ampstack[i+1]&gt;ampstack[i]){
<a name="l00535"></a>00535       endpos=posstack[i+1];
<a name="l00536"></a>00536     }<span class="keywordflow">else</span>{
<a name="l00537"></a>00537       endpos=posstack[i]+linesper+1; <span class="comment">/* +1 is important, else bin 0 is</span>
<a name="l00538"></a>00538 <span class="comment">                                        discarded in short frames */</span>
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540     <span class="keywordflow">if</span>(endpos&gt;n)endpos=n;
<a name="l00541"></a>00541     <span class="keywordflow">for</span>(;pos&lt;endpos;pos++)
<a name="l00542"></a>00542       seeds[pos]=ampstack[i];
<a name="l00543"></a>00543   }
<a name="l00544"></a>00544   
<a name="l00545"></a>00545   <span class="comment">/* there.  Linear time.  I now remember this was on a problem set I</span>
<a name="l00546"></a>00546 <span class="comment">     had in Grad Skool... I didn&#39;t solve it at the time ;-) */</span>
<a name="l00547"></a>00547 free(posstack_cpy);
<a name="l00548"></a>00548 free(ampstack_cpy);
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="comment">/* bleaugh, this is more complicated than it needs to be */</span>
<a name="l00552"></a>00552 <span class="preprocessor">#include&lt;stdio.h&gt;</span>
<a name="l00553"></a>00553 <span class="keyword">static</span> <span class="keywordtype">void</span> max_seeds(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l00554"></a>00554                       <span class="keywordtype">float</span> *seed,
<a name="l00555"></a>00555                       <span class="keywordtype">float</span> *flr){
<a name="l00556"></a>00556   <span class="keywordtype">long</span>   n=p-&gt;total_octave_lines;
<a name="l00557"></a>00557   <span class="keywordtype">int</span>    linesper=p-&gt;eighth_octave_lines;
<a name="l00558"></a>00558   <span class="keywordtype">long</span>   linpos=0;
<a name="l00559"></a>00559   <span class="keywordtype">long</span>   pos;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   seed_chase(seed,linesper,n); <span class="comment">/* for masking */</span>
<a name="l00562"></a>00562  
<a name="l00563"></a>00563   pos=p-&gt;octave[0]-p-&gt;firstoc-(linesper&gt;&gt;1);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="keywordflow">while</span>(linpos+1&lt;p-&gt;n){
<a name="l00566"></a>00566     <span class="keywordtype">float</span> minV=seed[pos];
<a name="l00567"></a>00567     <span class="keywordtype">long</span> end=((p-&gt;octave[linpos]+p-&gt;octave[linpos+1])&gt;&gt;1)-p-&gt;firstoc;
<a name="l00568"></a>00568     <span class="keywordflow">if</span>(minV&gt;p-&gt;vi-&gt;tone_abs_limit)minV=p-&gt;vi-&gt;tone_abs_limit;
<a name="l00569"></a>00569     <span class="keywordflow">while</span>(pos+1&lt;=end){
<a name="l00570"></a>00570       pos++;
<a name="l00571"></a>00571       <span class="keywordflow">if</span>((seed[pos]&gt;NEGINF &amp;&amp; seed[pos]&lt;minV) || minV==NEGINF)
<a name="l00572"></a>00572         minV=seed[pos];
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574     
<a name="l00575"></a>00575     end=pos+p-&gt;firstoc;
<a name="l00576"></a>00576     <span class="keywordflow">for</span>(;linpos&lt;p-&gt;n &amp;&amp; p-&gt;octave[linpos]&lt;=end;linpos++)
<a name="l00577"></a>00577       <span class="keywordflow">if</span>(flr[linpos]&lt;minV)flr[linpos]=minV;
<a name="l00578"></a>00578   }
<a name="l00579"></a>00579   
<a name="l00580"></a>00580   {
<a name="l00581"></a>00581     <span class="keywordtype">float</span> minV=seed[p-&gt;total_octave_lines-1];
<a name="l00582"></a>00582     <span class="keywordflow">for</span>(;linpos&lt;p-&gt;n;linpos++)
<a name="l00583"></a>00583       <span class="keywordflow">if</span>(flr[linpos]&lt;minV)flr[linpos]=minV;
<a name="l00584"></a>00584   }
<a name="l00585"></a>00585   
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="keyword">static</span> <span class="keywordtype">void</span> bark_noise_hybridmp(<span class="keywordtype">int</span> n,<span class="keyword">const</span> <span class="keywordtype">long</span> *b,
<a name="l00589"></a>00589                                 <span class="keyword">const</span> <span class="keywordtype">float</span> *f,
<a name="l00590"></a>00590                                 <span class="keywordtype">float</span> *noise,
<a name="l00591"></a>00591                                 <span class="keyword">const</span> <span class="keywordtype">float</span> offset,
<a name="l00592"></a>00592                                 <span class="keyword">const</span> <span class="keywordtype">int</span> fixed){
<a name="l00593"></a>00593   <span class="comment">/*</span>
<a name="l00594"></a>00594 <span class="comment">  float *N=alloca(n*sizeof(*N));</span>
<a name="l00595"></a>00595 <span class="comment">  float *X=alloca(n*sizeof(*N));</span>
<a name="l00596"></a>00596 <span class="comment">  float *XX=alloca(n*sizeof(*N));</span>
<a name="l00597"></a>00597 <span class="comment">  float *Y=alloca(n*sizeof(*N));</span>
<a name="l00598"></a>00598 <span class="comment">  float *XY=alloca(n*sizeof(*N));</span>
<a name="l00599"></a>00599 <span class="comment">  */</span>
<a name="l00600"></a>00600   <span class="keywordtype">float</span> *N=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*N));
<a name="l00601"></a>00601   <span class="keywordtype">float</span> *X=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*N));
<a name="l00602"></a>00602   <span class="keywordtype">float</span> *XX=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*N));
<a name="l00603"></a>00603   <span class="keywordtype">float</span> *Y=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*N));
<a name="l00604"></a>00604   <span class="keywordtype">float</span> *XY=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*N));
<a name="l00605"></a>00605   
<a name="l00606"></a>00606   <span class="keywordtype">float</span> *N_cpy = N;
<a name="l00607"></a>00607   <span class="keywordtype">float</span> *X_cpy = X;
<a name="l00608"></a>00608   <span class="keywordtype">float</span> *XX_cpy = XX;
<a name="l00609"></a>00609   <span class="keywordtype">float</span> *Y_cpy = Y;
<a name="l00610"></a>00610   <span class="keywordtype">float</span> *XY_cpy = XY;
<a name="l00611"></a>00611   <span class="comment">//--------------------------------------patch </span>
<a name="l00612"></a>00612   <span class="keywordtype">float</span> tN, tX, tXX, tY, tXY;
<a name="l00613"></a>00613   <span class="keywordtype">int</span> i;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="keywordtype">int</span> lo, hi;
<a name="l00616"></a>00616   <span class="keywordtype">float</span> R, A = 0.f, B = 0.f, D = 0.f;
<a name="l00617"></a>00617   <span class="keywordtype">float</span> w, x, y;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   tN = tX = tXX = tY = tXY = 0.f;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   y = f[0] + offset;
<a name="l00622"></a>00622   <span class="keywordflow">if</span> (y &lt; 1.f) y = 1.f;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   w = y * y * .5;
<a name="l00625"></a>00625     
<a name="l00626"></a>00626   tN += w;
<a name="l00627"></a>00627   tX += w;
<a name="l00628"></a>00628   tY += w * y;
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   N[0] = tN;
<a name="l00631"></a>00631   X[0] = tX;
<a name="l00632"></a>00632   XX[0] = tXX;
<a name="l00633"></a>00633   Y[0] = tY;
<a name="l00634"></a>00634   XY[0] = tXY;
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="keywordflow">for</span> (i = 1, x = 1.f; i &lt; n; i++, x += 1.f) {
<a name="l00637"></a>00637     
<a name="l00638"></a>00638     y = f[i] + offset;
<a name="l00639"></a>00639     <span class="keywordflow">if</span> (y &lt; 1.f) y = 1.f;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     w = y * y;
<a name="l00642"></a>00642     
<a name="l00643"></a>00643     tN += w;
<a name="l00644"></a>00644     tX += w * x;
<a name="l00645"></a>00645     tXX += w * x * x;
<a name="l00646"></a>00646     tY += w * y;
<a name="l00647"></a>00647     tXY += w * x * y;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     N[i] = tN;
<a name="l00650"></a>00650     X[i] = tX;
<a name="l00651"></a>00651     XX[i] = tXX;
<a name="l00652"></a>00652     Y[i] = tY;
<a name="l00653"></a>00653     XY[i] = tXY;
<a name="l00654"></a>00654   }
<a name="l00655"></a>00655   
<a name="l00656"></a>00656   <span class="keywordflow">for</span> (i = 0, x = 0.f;; i++, x += 1.f) {
<a name="l00657"></a>00657     
<a name="l00658"></a>00658     lo = b[i] &gt;&gt; 16;
<a name="l00659"></a>00659     <span class="keywordflow">if</span>( lo&gt;=0 ) <span class="keywordflow">break</span>;
<a name="l00660"></a>00660     hi = b[i] &amp; 0xffff;
<a name="l00661"></a>00661     
<a name="l00662"></a>00662     tN = N[hi] + N[-lo];
<a name="l00663"></a>00663     tX = X[hi] - X[-lo];
<a name="l00664"></a>00664     tXX = XX[hi] + XX[-lo];
<a name="l00665"></a>00665     tY = Y[hi] + Y[-lo];    
<a name="l00666"></a>00666     tXY = XY[hi] - XY[-lo];
<a name="l00667"></a>00667     
<a name="l00668"></a>00668     A = tY * tXX - tX * tXY;
<a name="l00669"></a>00669     B = tN * tXY - tX * tY;
<a name="l00670"></a>00670     D = tN * tXX - tX * tX;
<a name="l00671"></a>00671     R = (A + x * B) / D;
<a name="l00672"></a>00672     <span class="keywordflow">if</span> (R &lt; 0.f)
<a name="l00673"></a>00673       R = 0.f;
<a name="l00674"></a>00674     
<a name="l00675"></a>00675     noise[i] = R - offset;
<a name="l00676"></a>00676   }
<a name="l00677"></a>00677   
<a name="l00678"></a>00678   <span class="keywordflow">for</span> ( ;; i++, x += 1.f) {
<a name="l00679"></a>00679     
<a name="l00680"></a>00680     lo = b[i] &gt;&gt; 16;
<a name="l00681"></a>00681     hi = b[i] &amp; 0xffff;
<a name="l00682"></a>00682     <span class="keywordflow">if</span>(hi&gt;=n)<span class="keywordflow">break</span>;
<a name="l00683"></a>00683     
<a name="l00684"></a>00684     tN = N[hi] - N[lo];
<a name="l00685"></a>00685     tX = X[hi] - X[lo];
<a name="l00686"></a>00686     tXX = XX[hi] - XX[lo];
<a name="l00687"></a>00687     tY = Y[hi] - Y[lo];
<a name="l00688"></a>00688     tXY = XY[hi] - XY[lo];
<a name="l00689"></a>00689     
<a name="l00690"></a>00690     A = tY * tXX - tX * tXY;
<a name="l00691"></a>00691     B = tN * tXY - tX * tY;
<a name="l00692"></a>00692     D = tN * tXX - tX * tX;
<a name="l00693"></a>00693     R = (A + x * B) / D;
<a name="l00694"></a>00694     <span class="keywordflow">if</span> (R &lt; 0.f) R = 0.f;
<a name="l00695"></a>00695     
<a name="l00696"></a>00696     noise[i] = R - offset;
<a name="l00697"></a>00697   }
<a name="l00698"></a>00698   <span class="keywordflow">for</span> ( ; i &lt; n; i++, x += 1.f) {
<a name="l00699"></a>00699     
<a name="l00700"></a>00700     R = (A + x * B) / D;
<a name="l00701"></a>00701     <span class="keywordflow">if</span> (R &lt; 0.f) R = 0.f;
<a name="l00702"></a>00702     
<a name="l00703"></a>00703     noise[i] = R - offset;
<a name="l00704"></a>00704   }
<a name="l00705"></a>00705   
<a name="l00706"></a>00706   <span class="comment">//if (fixed &lt;= 0) return; //patch</span>
<a name="l00707"></a>00707   <span class="comment">//------------------</span>
<a name="l00708"></a>00708   <span class="keywordflow">if</span> (fixed &lt;= 0)
<a name="l00709"></a>00709   {
<a name="l00710"></a>00710   free(N_cpy);
<a name="l00711"></a>00711   free(X_cpy);
<a name="l00712"></a>00712   free(XX_cpy);
<a name="l00713"></a>00713   free(Y_cpy);
<a name="l00714"></a>00714   free(XY_cpy);
<a name="l00715"></a>00715   <span class="keywordflow">return</span>;
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717   <span class="comment">//----------------------</span>
<a name="l00718"></a>00718   
<a name="l00719"></a>00719   <span class="keywordflow">for</span> (i = 0, x = 0.f;; i++, x += 1.f) {
<a name="l00720"></a>00720     hi = i + fixed / 2;
<a name="l00721"></a>00721     lo = hi - fixed;
<a name="l00722"></a>00722     <span class="keywordflow">if</span>(lo&gt;=0)<span class="keywordflow">break</span>;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     tN = N[hi] + N[-lo];
<a name="l00725"></a>00725     tX = X[hi] - X[-lo];
<a name="l00726"></a>00726     tXX = XX[hi] + XX[-lo];
<a name="l00727"></a>00727     tY = Y[hi] + Y[-lo];
<a name="l00728"></a>00728     tXY = XY[hi] - XY[-lo];
<a name="l00729"></a>00729     
<a name="l00730"></a>00730     
<a name="l00731"></a>00731     A = tY * tXX - tX * tXY;
<a name="l00732"></a>00732     B = tN * tXY - tX * tY;
<a name="l00733"></a>00733     D = tN * tXX - tX * tX;
<a name="l00734"></a>00734     R = (A + x * B) / D;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (R - offset &lt; noise[i]) noise[i] = R - offset;
<a name="l00737"></a>00737   }
<a name="l00738"></a>00738   <span class="keywordflow">for</span> ( ;; i++, x += 1.f) {
<a name="l00739"></a>00739     
<a name="l00740"></a>00740     hi = i + fixed / 2;
<a name="l00741"></a>00741     lo = hi - fixed;
<a name="l00742"></a>00742     <span class="keywordflow">if</span>(hi&gt;=n)<span class="keywordflow">break</span>;
<a name="l00743"></a>00743     
<a name="l00744"></a>00744     tN = N[hi] - N[lo];
<a name="l00745"></a>00745     tX = X[hi] - X[lo];
<a name="l00746"></a>00746     tXX = XX[hi] - XX[lo];
<a name="l00747"></a>00747     tY = Y[hi] - Y[lo];
<a name="l00748"></a>00748     tXY = XY[hi] - XY[lo];
<a name="l00749"></a>00749     
<a name="l00750"></a>00750     A = tY * tXX - tX * tXY;
<a name="l00751"></a>00751     B = tN * tXY - tX * tY;
<a name="l00752"></a>00752     D = tN * tXX - tX * tX;
<a name="l00753"></a>00753     R = (A + x * B) / D;
<a name="l00754"></a>00754     
<a name="l00755"></a>00755     <span class="keywordflow">if</span> (R - offset &lt; noise[i]) noise[i] = R - offset;
<a name="l00756"></a>00756   }
<a name="l00757"></a>00757   <span class="keywordflow">for</span> ( ; i &lt; n; i++, x += 1.f) {
<a name="l00758"></a>00758     R = (A + x * B) / D;
<a name="l00759"></a>00759     <span class="keywordflow">if</span> (R - offset &lt; noise[i]) noise[i] = R - offset;
<a name="l00760"></a>00760   }
<a name="l00761"></a>00761   <span class="comment">//----------------patch----</span>
<a name="l00762"></a>00762   free(N_cpy); 
<a name="l00763"></a>00763   free(X_cpy);
<a name="l00764"></a>00764   free(XX_cpy);
<a name="l00765"></a>00765   free(Y_cpy);
<a name="l00766"></a>00766   free(XY_cpy);
<a name="l00767"></a>00767   <span class="comment">//----------------</span>
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="keyword">static</span> <span class="keywordtype">float</span> FLOOR1_fromdB_INV_LOOKUP[256]={
<a name="l00771"></a>00771   0.F, 8.81683e+06F, 8.27882e+06F, 7.77365e+06F, 
<a name="l00772"></a>00772   7.29930e+06F, 6.85389e+06F, 6.43567e+06F, 6.04296e+06F, 
<a name="l00773"></a>00773   5.67422e+06F, 5.32798e+06F, 5.00286e+06F, 4.69759e+06F, 
<a name="l00774"></a>00774   4.41094e+06F, 4.14178e+06F, 3.88905e+06F, 3.65174e+06F, 
<a name="l00775"></a>00775   3.42891e+06F, 3.21968e+06F, 3.02321e+06F, 2.83873e+06F, 
<a name="l00776"></a>00776   2.66551e+06F, 2.50286e+06F, 2.35014e+06F, 2.20673e+06F, 
<a name="l00777"></a>00777   2.07208e+06F, 1.94564e+06F, 1.82692e+06F, 1.71544e+06F, 
<a name="l00778"></a>00778   1.61076e+06F, 1.51247e+06F, 1.42018e+06F, 1.33352e+06F, 
<a name="l00779"></a>00779   1.25215e+06F, 1.17574e+06F, 1.10400e+06F, 1.03663e+06F, 
<a name="l00780"></a>00780   973377.F, 913981.F, 858210.F, 805842.F, 
<a name="l00781"></a>00781   756669.F, 710497.F, 667142.F, 626433.F, 
<a name="l00782"></a>00782   588208.F, 552316.F, 518613.F, 486967.F, 
<a name="l00783"></a>00783   457252.F, 429351.F, 403152.F, 378551.F, 
<a name="l00784"></a>00784   355452.F, 333762.F, 313396.F, 294273.F, 
<a name="l00785"></a>00785   276316.F, 259455.F, 243623.F, 228757.F, 
<a name="l00786"></a>00786   214798.F, 201691.F, 189384.F, 177828.F, 
<a name="l00787"></a>00787   166977.F, 156788.F, 147221.F, 138237.F, 
<a name="l00788"></a>00788   129802.F, 121881.F, 114444.F, 107461.F, 
<a name="l00789"></a>00789   100903.F, 94746.3F, 88964.9F, 83536.2F, 
<a name="l00790"></a>00790   78438.8F, 73652.5F, 69158.2F, 64938.1F, 
<a name="l00791"></a>00791   60975.6F, 57254.9F, 53761.2F, 50480.6F, 
<a name="l00792"></a>00792   47400.3F, 44507.9F, 41792.0F, 39241.9F, 
<a name="l00793"></a>00793   36847.3F, 34598.9F, 32487.7F, 30505.3F, 
<a name="l00794"></a>00794   28643.8F, 26896.0F, 25254.8F, 23713.7F, 
<a name="l00795"></a>00795   22266.7F, 20908.0F, 19632.2F, 18434.2F, 
<a name="l00796"></a>00796   17309.4F, 16253.1F, 15261.4F, 14330.1F, 
<a name="l00797"></a>00797   13455.7F, 12634.6F, 11863.7F, 11139.7F, 
<a name="l00798"></a>00798   10460.0F, 9821.72F, 9222.39F, 8659.64F, 
<a name="l00799"></a>00799   8131.23F, 7635.06F, 7169.17F, 6731.70F, 
<a name="l00800"></a>00800   6320.93F, 5935.23F, 5573.06F, 5232.99F, 
<a name="l00801"></a>00801   4913.67F, 4613.84F, 4332.30F, 4067.94F, 
<a name="l00802"></a>00802   3819.72F, 3586.64F, 3367.78F, 3162.28F, 
<a name="l00803"></a>00803   2969.31F, 2788.13F, 2617.99F, 2458.24F, 
<a name="l00804"></a>00804   2308.24F, 2167.39F, 2035.14F, 1910.95F, 
<a name="l00805"></a>00805   1794.35F, 1684.85F, 1582.04F, 1485.51F, 
<a name="l00806"></a>00806   1394.86F, 1309.75F, 1229.83F, 1154.78F, 
<a name="l00807"></a>00807   1084.32F, 1018.15F, 956.024F, 897.687F, 
<a name="l00808"></a>00808   842.910F, 791.475F, 743.179F, 697.830F, 
<a name="l00809"></a>00809   655.249F, 615.265F, 577.722F, 542.469F, 
<a name="l00810"></a>00810   509.367F, 478.286F, 449.101F, 421.696F, 
<a name="l00811"></a>00811   395.964F, 371.803F, 349.115F, 327.812F, 
<a name="l00812"></a>00812   307.809F, 289.026F, 271.390F, 254.830F, 
<a name="l00813"></a>00813   239.280F, 224.679F, 210.969F, 198.096F, 
<a name="l00814"></a>00814   186.008F, 174.658F, 164.000F, 153.993F, 
<a name="l00815"></a>00815   144.596F, 135.773F, 127.488F, 119.708F, 
<a name="l00816"></a>00816   112.404F, 105.545F, 99.1046F, 93.0572F, 
<a name="l00817"></a>00817   87.3788F, 82.0469F, 77.0404F, 72.3394F, 
<a name="l00818"></a>00818   67.9252F, 63.7804F, 59.8885F, 56.2341F, 
<a name="l00819"></a>00819   52.8027F, 49.5807F, 46.5553F, 43.7144F, 
<a name="l00820"></a>00820   41.0470F, 38.5423F, 36.1904F, 33.9821F, 
<a name="l00821"></a>00821   31.9085F, 29.9614F, 28.1332F, 26.4165F, 
<a name="l00822"></a>00822   24.8045F, 23.2910F, 21.8697F, 20.5352F, 
<a name="l00823"></a>00823   19.2822F, 18.1056F, 17.0008F, 15.9634F, 
<a name="l00824"></a>00824   14.9893F, 14.0746F, 13.2158F, 12.4094F, 
<a name="l00825"></a>00825   11.6522F, 10.9411F, 10.2735F, 9.64662F, 
<a name="l00826"></a>00826   9.05798F, 8.50526F, 7.98626F, 7.49894F, 
<a name="l00827"></a>00827   7.04135F, 6.61169F, 6.20824F, 5.82941F, 
<a name="l00828"></a>00828   5.47370F, 5.13970F, 4.82607F, 4.53158F, 
<a name="l00829"></a>00829   4.25507F, 3.99542F, 3.75162F, 3.52269F, 
<a name="l00830"></a>00830   3.30774F, 3.10590F, 2.91638F, 2.73842F, 
<a name="l00831"></a>00831   2.57132F, 2.41442F, 2.26709F, 2.12875F, 
<a name="l00832"></a>00832   1.99885F, 1.87688F, 1.76236F, 1.65482F, 
<a name="l00833"></a>00833   1.55384F, 1.45902F, 1.36999F, 1.28640F, 
<a name="l00834"></a>00834   1.20790F, 1.13419F, 1.06499F, 1.F
<a name="l00835"></a>00835 };
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 <span class="keywordtype">void</span> _vp_remove_floor(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l00838"></a>00838                       <span class="keywordtype">float</span> *mdct,
<a name="l00839"></a>00839                       <span class="keywordtype">int</span> *codedflr,
<a name="l00840"></a>00840                       <span class="keywordtype">float</span> *residue,
<a name="l00841"></a>00841                       <span class="keywordtype">int</span> sliding_lowpass){ 
<a name="l00842"></a>00842 
<a name="l00843"></a>00843   <span class="keywordtype">int</span> i,n=p-&gt;n;
<a name="l00844"></a>00844  
<a name="l00845"></a>00845   <span class="keywordflow">if</span>(sliding_lowpass&gt;n)sliding_lowpass=n;
<a name="l00846"></a>00846   
<a name="l00847"></a>00847   <span class="keywordflow">for</span>(i=0;i&lt;sliding_lowpass;i++){
<a name="l00848"></a>00848     residue[i]=
<a name="l00849"></a>00849       mdct[i]*FLOOR1_fromdB_INV_LOOKUP[codedflr[i]];
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordflow">for</span>(;i&lt;n;i++)
<a name="l00853"></a>00853     residue[i]=0.;
<a name="l00854"></a>00854 }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856 <span class="keywordtype">void</span> _vp_noisemask(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l00857"></a>00857                    <span class="keywordtype">float</span> *logmdct, 
<a name="l00858"></a>00858                    <span class="keywordtype">float</span> *logmask){
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   <span class="keywordtype">int</span> i,n=p-&gt;n;
<a name="l00861"></a>00861   <span class="keywordtype">float</span> *work=(<span class="keywordtype">float</span>*)_ogg_malloc(n*<span class="keyword">sizeof</span>(*work));<span class="comment">//alloca(n*sizeof(*work)); //patch</span>
<a name="l00862"></a>00862   <span class="keywordtype">float</span> *work_cpy = work;
<a name="l00863"></a>00863         
<a name="l00864"></a>00864   bark_noise_hybridmp(n,p-&gt;bark,logmdct,logmask,
<a name="l00865"></a>00865                       140.,-1);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="keywordflow">for</span>(i=0;i&lt;n;i++)work[i]=logmdct[i]-logmask[i];
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   bark_noise_hybridmp(n,p-&gt;bark,work,logmask,0.,
<a name="l00870"></a>00870                       p-&gt;vi-&gt;noisewindowfixed);
<a name="l00871"></a>00871 
<a name="l00872"></a>00872   <span class="keywordflow">for</span>(i=0;i&lt;n;i++)work[i]=logmdct[i]-work[i];
<a name="l00873"></a>00873   
<a name="l00874"></a>00874 <span class="preprocessor">#if 0</span>
<a name="l00875"></a>00875 <span class="preprocessor"></span>  {
<a name="l00876"></a>00876     <span class="keyword">static</span> <span class="keywordtype">int</span> seq=0;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <span class="keywordtype">float</span> work2[n];
<a name="l00879"></a>00879     <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00880"></a>00880       work2[i]=logmask[i]+work[i];
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882     
<a name="l00883"></a>00883     <span class="keywordflow">if</span>(seq&amp;1)
<a name="l00884"></a>00884       _analysis_output(<span class="stringliteral">&quot;median2R&quot;</span>,seq/2,work,n,1,0,0);
<a name="l00885"></a>00885     <span class="keywordflow">else</span>
<a name="l00886"></a>00886       _analysis_output(<span class="stringliteral">&quot;median2L&quot;</span>,seq/2,work,n,1,0,0);
<a name="l00887"></a>00887     
<a name="l00888"></a>00888     <span class="keywordflow">if</span>(seq&amp;1)
<a name="l00889"></a>00889       _analysis_output(<span class="stringliteral">&quot;envelope2R&quot;</span>,seq/2,work2,n,1,0,0);
<a name="l00890"></a>00890     <span class="keywordflow">else</span>
<a name="l00891"></a>00891       _analysis_output(<span class="stringliteral">&quot;envelope2L&quot;</span>,seq/2,work2,n,1,0,0);
<a name="l00892"></a>00892     seq++;
<a name="l00893"></a>00893   }
<a name="l00894"></a>00894 <span class="preprocessor">#endif</span>
<a name="l00895"></a>00895 <span class="preprocessor"></span>
<a name="l00896"></a>00896   <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00897"></a>00897     <span class="keywordtype">int</span> dB=logmask[i]+.5;
<a name="l00898"></a>00898     <span class="keywordflow">if</span>(dB&gt;=NOISE_COMPAND_LEVELS)dB=NOISE_COMPAND_LEVELS-1;
<a name="l00899"></a>00899     <span class="keywordflow">if</span>(dB&lt;0)dB=0;
<a name="l00900"></a>00900     logmask[i]= work[i]+p-&gt;vi-&gt;noisecompand[dB];
<a name="l00901"></a>00901   }
<a name="l00902"></a>00902  free(work_cpy); <span class="comment">//patch        </span>
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keywordtype">void</span> _vp_tonemask(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l00906"></a>00906                   <span class="keywordtype">float</span> *logfft,
<a name="l00907"></a>00907                   <span class="keywordtype">float</span> *logmask,
<a name="l00908"></a>00908                   <span class="keywordtype">float</span> global_specmax,
<a name="l00909"></a>00909                   <span class="keywordtype">float</span> local_specmax){
<a name="l00910"></a>00910 
<a name="l00911"></a>00911   <span class="keywordtype">int</span> i,n=p-&gt;n;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="keywordtype">float</span> *seed= (<span class="keywordtype">float</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(*seed)*p-&gt;total_octave_lines);<span class="comment">//alloca(sizeof(*seed)*p-&gt;total_octave_lines); //patch</span>
<a name="l00914"></a>00914   <span class="keywordtype">float</span> *seed_cpy = seed;
<a name="l00915"></a>00915   <span class="keywordtype">float</span> att=local_specmax+p-&gt;vi-&gt;ath_adjatt;
<a name="l00916"></a>00916   <span class="keywordflow">for</span>(i=0;i&lt;p-&gt;total_octave_lines;i++)seed[i]=NEGINF;
<a name="l00917"></a>00917   
<a name="l00918"></a>00918   <span class="comment">/* set the ATH (floating below localmax, not global max by a</span>
<a name="l00919"></a>00919 <span class="comment">     specified att) */</span>
<a name="l00920"></a>00920   <span class="keywordflow">if</span>(att&lt;p-&gt;vi-&gt;ath_maxatt)att=p-&gt;vi-&gt;ath_maxatt;
<a name="l00921"></a>00921   
<a name="l00922"></a>00922   <span class="keywordflow">for</span>(i=0;i&lt;n;i++)
<a name="l00923"></a>00923     logmask[i]=p-&gt;ath[i]+att;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   <span class="comment">/* tone masking */</span>
<a name="l00926"></a>00926   seed_loop(p,(<span class="keyword">const</span> <span class="keywordtype">float</span> ***)p-&gt;tonecurves,logfft,logmask,seed,global_specmax);
<a name="l00927"></a>00927   max_seeds(p,seed,logmask);
<a name="l00928"></a>00928   free(seed_cpy);       <span class="comment">//patch</span>
<a name="l00929"></a>00929 }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 <span class="keywordtype">void</span> _vp_offset_and_mix(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l00932"></a>00932                         <span class="keywordtype">float</span> *noise,
<a name="l00933"></a>00933                         <span class="keywordtype">float</span> *tone,
<a name="l00934"></a>00934                         <span class="keywordtype">int</span> offset_select,
<a name="l00935"></a>00935                         <span class="keywordtype">float</span> *logmask,
<a name="l00936"></a>00936                         <span class="keywordtype">float</span> *mdct,
<a name="l00937"></a>00937                         <span class="keywordtype">float</span> *logmdct){
<a name="l00938"></a>00938   <span class="keywordtype">int</span> i,n=p-&gt;n;
<a name="l00939"></a>00939   <span class="keywordtype">float</span> de, coeffi, cx;<span class="comment">/* AoTuV */</span>
<a name="l00940"></a>00940   <span class="keywordtype">float</span> toneatt=p-&gt;vi-&gt;tone_masteratt[offset_select];
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   cx = p-&gt;m_val;
<a name="l00943"></a>00943   
<a name="l00944"></a>00944   <span class="keywordflow">for</span>(i=0;i&lt;n;i++){
<a name="l00945"></a>00945     <span class="keywordtype">float</span> val= noise[i]+p-&gt;noiseoffset[offset_select][i];
<a name="l00946"></a>00946     <span class="keywordflow">if</span>(val&gt;p-&gt;vi-&gt;noisemaxsupp)val=p-&gt;vi-&gt;noisemaxsupp;
<a name="l00947"></a>00947     logmask[i]=max(val,tone[i]+toneatt);
<a name="l00948"></a>00948 
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     <span class="comment">/* AoTuV */</span>
<a name="l00959"></a>00959     <span class="keywordflow">if</span>(offset_select == 1) {
<a name="l00960"></a>00960       coeffi = -17.2;       <span class="comment">/* coeffi is a -17.2dB threshold */</span>
<a name="l00961"></a>00961       val = val - logmdct[i];  <span class="comment">/* val == mdct line value relative to floor in dB */</span>
<a name="l00962"></a>00962       
<a name="l00963"></a>00963       <span class="keywordflow">if</span>(val &gt; coeffi){
<a name="l00964"></a>00964         <span class="comment">/* mdct value is &gt; -17.2 dB below floor */</span>
<a name="l00965"></a>00965         
<a name="l00966"></a>00966         de = 1.0-((val-coeffi)*0.005*cx);
<a name="l00967"></a>00967         <span class="comment">/* pro-rated attenuation:</span>
<a name="l00968"></a>00968 <span class="comment">           -0.00 dB boost if mdct value is -17.2dB (relative to floor) </span>
<a name="l00969"></a>00969 <span class="comment">           -0.77 dB boost if mdct value is 0dB (relative to floor) </span>
<a name="l00970"></a>00970 <span class="comment">           -1.64 dB boost if mdct value is +17.2dB (relative to floor) </span>
<a name="l00971"></a>00971 <span class="comment">           etc... */</span>
<a name="l00972"></a>00972         
<a name="l00973"></a>00973         <span class="keywordflow">if</span>(de &lt; 0) de = 0.0001;
<a name="l00974"></a>00974       }<span class="keywordflow">else</span>
<a name="l00975"></a>00975         <span class="comment">/* mdct value is &lt;= -17.2 dB below floor */</span>
<a name="l00976"></a>00976         
<a name="l00977"></a>00977         de = 1.0-((val-coeffi)*0.0003*cx);
<a name="l00978"></a>00978       <span class="comment">/* pro-rated attenuation:</span>
<a name="l00979"></a>00979 <span class="comment">         +0.00 dB atten if mdct value is -17.2dB (relative to floor) </span>
<a name="l00980"></a>00980 <span class="comment">         +0.45 dB atten if mdct value is -34.4dB (relative to floor) </span>
<a name="l00981"></a>00981 <span class="comment">         etc... */</span>
<a name="l00982"></a>00982       
<a name="l00983"></a>00983       mdct[i] *= de;
<a name="l00984"></a>00984       
<a name="l00985"></a>00985     }
<a name="l00986"></a>00986   }
<a name="l00987"></a>00987 }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keywordtype">float</span> _vp_ampmax_decay(<span class="keywordtype">float</span> amp,<a class="code" href="structvorbis__dsp__state.html">vorbis_dsp_state</a> *vd){
<a name="l00990"></a>00990   <a class="code" href="structvorbis__info.html">vorbis_info</a> *vi=vd-&gt;vi;
<a name="l00991"></a>00991   <a class="code" href="structcodec__setup__info.html">codec_setup_info</a> *ci=(<a class="code" href="structcodec__setup__info.html">codec_setup_info</a>*)vi-&gt;codec_setup;
<a name="l00992"></a>00992   <a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *gi=&amp;ci-&gt;psy_g_param;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   <span class="keywordtype">int</span> n=ci-&gt;blocksizes[vd-&gt;W]/2;
<a name="l00995"></a>00995   <span class="keywordtype">float</span> secs=(<span class="keywordtype">float</span>)n/vi-&gt;rate;
<a name="l00996"></a>00996 
<a name="l00997"></a>00997   amp+=secs*gi-&gt;ampmax_att_per_sec;
<a name="l00998"></a>00998   <span class="keywordflow">if</span>(amp&lt;-9999)amp=-9999;
<a name="l00999"></a>00999   <span class="keywordflow">return</span>(amp);
<a name="l01000"></a>01000 }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 <span class="keyword">static</span> <span class="keywordtype">void</span> couple_lossless(<span class="keywordtype">float</span> A, <span class="keywordtype">float</span> B, 
<a name="l01003"></a>01003                             <span class="keywordtype">float</span> *qA, <span class="keywordtype">float</span> *qB){
<a name="l01004"></a>01004   <span class="keywordtype">int</span> test1=fabs(*qA)&gt;fabs(*qB);
<a name="l01005"></a>01005   test1-= fabs(*qA)&lt;fabs(*qB);
<a name="l01006"></a>01006   
<a name="l01007"></a>01007   <span class="keywordflow">if</span>(!test1)test1=((fabs(A)&gt;fabs(B))&lt;&lt;1)-1;
<a name="l01008"></a>01008   <span class="keywordflow">if</span>(test1==1){
<a name="l01009"></a>01009     *qB=(*qA&gt;0.f?*qA-*qB:*qB-*qA);
<a name="l01010"></a>01010   }<span class="keywordflow">else</span>{
<a name="l01011"></a>01011     <span class="keywordtype">float</span> temp=*qB;  
<a name="l01012"></a>01012     *qB=(*qB&gt;0.f?*qA-*qB:*qB-*qA);
<a name="l01013"></a>01013     *qA=temp;
<a name="l01014"></a>01014   }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <span class="keywordflow">if</span>(*qB&gt;fabs(*qA)*1.9999f){
<a name="l01017"></a>01017     *qB= -fabs(*qA)*2.f;
<a name="l01018"></a>01018     *qA= -*qA;
<a name="l01019"></a>01019   }
<a name="l01020"></a>01020 }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022 <span class="keyword">static</span> <span class="keywordtype">float</span> hypot_lookup[32]={
<a name="l01023"></a>01023   -0.009935, -0.011245, -0.012726, -0.014397, 
<a name="l01024"></a>01024   -0.016282, -0.018407, -0.020800, -0.023494, 
<a name="l01025"></a>01025   -0.026522, -0.029923, -0.033737, -0.038010, 
<a name="l01026"></a>01026   -0.042787, -0.048121, -0.054064, -0.060671, 
<a name="l01027"></a>01027   -0.068000, -0.076109, -0.085054, -0.094892, 
<a name="l01028"></a>01028   -0.105675, -0.117451, -0.130260, -0.144134, 
<a name="l01029"></a>01029   -0.159093, -0.175146, -0.192286, -0.210490, 
<a name="l01030"></a>01030   -0.229718, -0.249913, -0.271001, -0.292893};
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="keyword">static</span> <span class="keywordtype">void</span> precomputed_couple_point(<span class="keywordtype">float</span> premag,
<a name="l01033"></a>01033                                      <span class="keywordtype">int</span> floorA,<span class="keywordtype">int</span> floorB,
<a name="l01034"></a>01034                                      <span class="keywordtype">float</span> *mag, <span class="keywordtype">float</span> *ang){
<a name="l01035"></a>01035   
<a name="l01036"></a>01036   <span class="keywordtype">int</span> test=(floorA&gt;floorB)-1;
<a name="l01037"></a>01037   <span class="keywordtype">int</span> offset=31-abs(floorA-floorB);
<a name="l01038"></a>01038   <span class="keywordtype">float</span> floormag=hypot_lookup[((offset&lt;0)-1)&amp;offset]+1.f;
<a name="l01039"></a>01039 
<a name="l01040"></a>01040   floormag*=FLOOR1_fromdB_INV_LOOKUP[(floorB&amp;test)|(floorA&amp;(~test))];
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   *mag=premag*floormag;
<a name="l01043"></a>01043   *ang=0.f;
<a name="l01044"></a>01044 }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046 <span class="comment">/* just like below, this is currently set up to only do</span>
<a name="l01047"></a>01047 <span class="comment">   single-step-depth coupling.  Otherwise, we&#39;d have to do more</span>
<a name="l01048"></a>01048 <span class="comment">   copying (which will be inevitable later) */</span>
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 <span class="comment">/* doing the real circular magnitude calculation is audibly superior</span>
<a name="l01051"></a>01051 <span class="comment">   to (A+B)/sqrt(2) */</span>
<a name="l01052"></a>01052 <span class="keyword">static</span> <span class="keywordtype">float</span> dipole_hypot(<span class="keywordtype">float</span> a, <span class="keywordtype">float</span> b){
<a name="l01053"></a>01053   <span class="keywordflow">if</span>(a&gt;0.){
<a name="l01054"></a>01054     <span class="keywordflow">if</span>(b&gt;0.)<span class="keywordflow">return</span> sqrt(a*a+b*b);
<a name="l01055"></a>01055     <span class="keywordflow">if</span>(a&gt;-b)<span class="keywordflow">return</span> sqrt(a*a-b*b);
<a name="l01056"></a>01056     <span class="keywordflow">return</span> -sqrt(b*b-a*a);
<a name="l01057"></a>01057   }
<a name="l01058"></a>01058   <span class="keywordflow">if</span>(b&lt;0.)<span class="keywordflow">return</span> -sqrt(a*a+b*b);
<a name="l01059"></a>01059   <span class="keywordflow">if</span>(-a&gt;b)<span class="keywordflow">return</span> -sqrt(a*a-b*b);
<a name="l01060"></a>01060   <span class="keywordflow">return</span> sqrt(b*b-a*a);
<a name="l01061"></a>01061 }
<a name="l01062"></a>01062 <span class="keyword">static</span> <span class="keywordtype">float</span> round_hypot(<span class="keywordtype">float</span> a, <span class="keywordtype">float</span> b){
<a name="l01063"></a>01063   <span class="keywordflow">if</span>(a&gt;0.){
<a name="l01064"></a>01064     <span class="keywordflow">if</span>(b&gt;0.)<span class="keywordflow">return</span> sqrt(a*a+b*b);
<a name="l01065"></a>01065     <span class="keywordflow">if</span>(a&gt;-b)<span class="keywordflow">return</span> sqrt(a*a+b*b);
<a name="l01066"></a>01066     <span class="keywordflow">return</span> -sqrt(b*b+a*a);
<a name="l01067"></a>01067   }
<a name="l01068"></a>01068   <span class="keywordflow">if</span>(b&lt;0.)<span class="keywordflow">return</span> -sqrt(a*a+b*b);
<a name="l01069"></a>01069   <span class="keywordflow">if</span>(-a&gt;b)<span class="keywordflow">return</span> -sqrt(a*a+b*b);
<a name="l01070"></a>01070   <span class="keywordflow">return</span> sqrt(b*b+a*a);
<a name="l01071"></a>01071 }
<a name="l01072"></a>01072 
<a name="l01073"></a>01073 <span class="comment">/* revert to round hypot for now */</span>
<a name="l01074"></a>01074 <span class="keywordtype">float</span> **_vp_quantize_couple_memo(<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb,
<a name="l01075"></a>01075                                  <a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *g,
<a name="l01076"></a>01076                                  <a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l01077"></a>01077                                  <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *vi,
<a name="l01078"></a>01078                                  <span class="keywordtype">float</span> **mdct){
<a name="l01079"></a>01079   
<a name="l01080"></a>01080   <span class="keywordtype">int</span> i,j,n=p-&gt;n;
<a name="l01081"></a>01081   <span class="keywordtype">float</span> **ret=(<span class="keywordtype">float</span>**)_vorbis_block_alloc(vb,vi-&gt;coupling_steps*<span class="keyword">sizeof</span>(*ret));
<a name="l01082"></a>01082   <span class="keywordtype">int</span> limit=g-&gt;coupling_pointlimit[p-&gt;vi-&gt;blockflag][PACKETBLOBS/2];
<a name="l01083"></a>01083   
<a name="l01084"></a>01084   <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;coupling_steps;i++){
<a name="l01085"></a>01085     <span class="keywordtype">float</span> *mdctM=mdct[vi-&gt;coupling_mag[i]];
<a name="l01086"></a>01086     <span class="keywordtype">float</span> *mdctA=mdct[vi-&gt;coupling_ang[i]];
<a name="l01087"></a>01087     ret[i]=(<span class="keywordtype">float</span>*)_vorbis_block_alloc(vb,n*<span class="keyword">sizeof</span>(**ret));
<a name="l01088"></a>01088     <span class="keywordflow">for</span>(j=0;j&lt;limit;j++)
<a name="l01089"></a>01089       ret[i][j]=dipole_hypot(mdctM[j],mdctA[j]);
<a name="l01090"></a>01090     <span class="keywordflow">for</span>(;j&lt;n;j++)
<a name="l01091"></a>01091       ret[i][j]=round_hypot(mdctM[j],mdctA[j]);
<a name="l01092"></a>01092   }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   <span class="keywordflow">return</span>(ret);
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 <span class="comment">/* this is for per-channel noise normalization */</span>
<a name="l01098"></a>01098 <span class="keyword">static</span> <span class="keywordtype">int</span> apsort(<span class="keyword">const</span> <span class="keywordtype">void</span> *a, <span class="keyword">const</span> <span class="keywordtype">void</span> *b){
<a name="l01099"></a>01099   <span class="keywordtype">float</span> f1=fabs(**(<span class="keywordtype">float</span>**)a);
<a name="l01100"></a>01100   <span class="keywordtype">float</span> f2=fabs(**(<span class="keywordtype">float</span>**)b);
<a name="l01101"></a>01101   <span class="keywordflow">return</span> (f1&lt;f2)-(f1&gt;f2);
<a name="l01102"></a>01102 }
<a name="l01103"></a>01103 
<a name="l01104"></a>01104 <span class="keywordtype">int</span> **_vp_quantize_couple_sort(<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb,
<a name="l01105"></a>01105                                <a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l01106"></a>01106                                <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *vi,
<a name="l01107"></a>01107                                <span class="keywordtype">float</span> **mags){
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   <span class="keywordflow">if</span>(p-&gt;vi-&gt;normal_point_p){
<a name="l01111"></a>01111     <span class="keywordtype">int</span> i,j,k,n=p-&gt;n;
<a name="l01112"></a>01112     <span class="keywordtype">int</span> **ret=(<span class="keywordtype">int</span>**)_vorbis_block_alloc(vb,vi-&gt;coupling_steps*<span class="keyword">sizeof</span>(*ret));
<a name="l01113"></a>01113     <span class="keywordtype">int</span> partition=p-&gt;vi-&gt;normal_partition;
<a name="l01114"></a>01114     <span class="keywordtype">float</span> **work= (<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*work)*partition);<span class="comment">//alloca(sizeof(*work)*partition); //patch</span>
<a name="l01115"></a>01115     <span class="keywordtype">float</span> **work_cpy = work;
<a name="l01116"></a>01116     <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;coupling_steps;i++){
<a name="l01117"></a>01117       ret[i]=(<span class="keywordtype">int</span>*)_vorbis_block_alloc(vb,n*<span class="keyword">sizeof</span>(**ret));
<a name="l01118"></a>01118       
<a name="l01119"></a>01119       <span class="keywordflow">for</span>(j=0;j&lt;n;j+=partition){
<a name="l01120"></a>01120         <span class="keywordflow">for</span>(k=0;k&lt;partition;k++)work[k]=mags[i]+k+j;
<a name="l01121"></a>01121         qsort(work,partition,<span class="keyword">sizeof</span>(*work),apsort);
<a name="l01122"></a>01122         <span class="keywordflow">for</span>(k=0;k&lt;partition;k++)ret[i][k+j]=work[k]-mags[i];
<a name="l01123"></a>01123       }
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     free(work_cpy); <span class="comment">//patch</span>
<a name="l01126"></a>01126     <span class="keywordflow">return</span>(ret);
<a name="l01127"></a>01127   }
<a name="l01128"></a>01128   <span class="keywordflow">return</span>(NULL);
<a name="l01129"></a>01129 }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 <span class="keywordtype">void</span> _vp_noise_normalize_sort(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l01132"></a>01132                               <span class="keywordtype">float</span> *magnitudes,<span class="keywordtype">int</span> *sortedindex){
<a name="l01133"></a>01133   <span class="keywordtype">int</span> i,j,n=p-&gt;n;
<a name="l01134"></a>01134   <a class="code" href="structvorbis__info__psy.html">vorbis_info_psy</a> *vi=p-&gt;vi;
<a name="l01135"></a>01135   <span class="keywordtype">int</span> partition=vi-&gt;normal_partition;
<a name="l01136"></a>01136   <span class="keywordtype">float</span> **work=(<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*work)*partition);<span class="comment">//alloca(sizeof(*work)*partition);//patch</span>
<a name="l01137"></a>01137   <span class="keywordtype">float</span> **work_cpy = work; <span class="comment">//patch</span>
<a name="l01138"></a>01138   <span class="keywordtype">int</span> start=vi-&gt;normal_start;
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="keywordflow">for</span>(j=start;j&lt;n;j+=partition){
<a name="l01141"></a>01141     <span class="keywordflow">if</span>(j+partition&gt;n)partition=n-j;
<a name="l01142"></a>01142     <span class="keywordflow">for</span>(i=0;i&lt;partition;i++)work[i]=magnitudes+i+j;
<a name="l01143"></a>01143     qsort(work,partition,<span class="keyword">sizeof</span>(*work),apsort);
<a name="l01144"></a>01144     <span class="keywordflow">for</span>(i=0;i&lt;partition;i++){
<a name="l01145"></a>01145       sortedindex[i+j-start]=work[i]-magnitudes;
<a name="l01146"></a>01146     }
<a name="l01147"></a>01147   }
<a name="l01148"></a>01148   free(work_cpy); <span class="comment">//patch</span>
<a name="l01149"></a>01149 }
<a name="l01150"></a>01150 
<a name="l01151"></a>01151 <span class="keywordtype">void</span> _vp_noise_normalize(<a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l01152"></a>01152                          <span class="keywordtype">float</span> *in,<span class="keywordtype">float</span> *out,<span class="keywordtype">int</span> *sortedindex){
<a name="l01153"></a>01153   <span class="keywordtype">int</span> <span class="comment">/*flag=0,*/</span>i,j=0,n=p-&gt;n;<span class="comment">//warning</span>
<a name="l01154"></a>01154   <a class="code" href="structvorbis__info__psy.html">vorbis_info_psy</a> *vi=p-&gt;vi;
<a name="l01155"></a>01155   <span class="keywordtype">int</span> partition=vi-&gt;normal_partition;
<a name="l01156"></a>01156   <span class="keywordtype">int</span> start=vi-&gt;normal_start;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158   <span class="keywordflow">if</span>(start&gt;n)start=n;
<a name="l01159"></a>01159 
<a name="l01160"></a>01160   <span class="keywordflow">if</span>(vi-&gt;normal_channel_p){
<a name="l01161"></a>01161     <span class="keywordflow">for</span>(;j&lt;start;j++)
<a name="l01162"></a>01162       out[j]=rint(in[j]);
<a name="l01163"></a>01163     
<a name="l01164"></a>01164     <span class="keywordflow">for</span>(;j+partition&lt;=n;j+=partition){
<a name="l01165"></a>01165       <span class="keywordtype">float</span> acc=0.;
<a name="l01166"></a>01166       <span class="keywordtype">int</span> k;
<a name="l01167"></a>01167       
<a name="l01168"></a>01168       <span class="keywordflow">for</span>(i=j;i&lt;j+partition;i++)
<a name="l01169"></a>01169         acc+=in[i]*in[i];
<a name="l01170"></a>01170       
<a name="l01171"></a>01171       <span class="keywordflow">for</span>(i=0;i&lt;partition;i++){
<a name="l01172"></a>01172         k=sortedindex[i+j-start];
<a name="l01173"></a>01173         
<a name="l01174"></a>01174         <span class="keywordflow">if</span>(in[k]*in[k]&gt;=.25f){
<a name="l01175"></a>01175           out[k]=rint(in[k]);
<a name="l01176"></a>01176           acc-=in[k]*in[k];
<a name="l01177"></a>01177           <span class="comment">//flag=1;</span>
<a name="l01178"></a>01178         }<span class="keywordflow">else</span>{
<a name="l01179"></a>01179           <span class="keywordflow">if</span>(acc&lt;vi-&gt;normal_thresh)<span class="keywordflow">break</span>;
<a name="l01180"></a>01180           out[k]=unitnorm(in[k]);
<a name="l01181"></a>01181           acc-=1.;
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183       }
<a name="l01184"></a>01184       
<a name="l01185"></a>01185       <span class="keywordflow">for</span>(;i&lt;partition;i++){
<a name="l01186"></a>01186         k=sortedindex[i+j-start];
<a name="l01187"></a>01187         out[k]=0.;
<a name="l01188"></a>01188       }
<a name="l01189"></a>01189     }
<a name="l01190"></a>01190   }
<a name="l01191"></a>01191   
<a name="l01192"></a>01192   <span class="keywordflow">for</span>(;j&lt;n;j++)
<a name="l01193"></a>01193     out[j]=rint(in[j]);
<a name="l01194"></a>01194   
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="keywordtype">void</span> _vp_couple(<span class="keywordtype">int</span> blobno,
<a name="l01198"></a>01198                 <a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *g,
<a name="l01199"></a>01199                 <a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p,
<a name="l01200"></a>01200                 <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *vi,
<a name="l01201"></a>01201                 <span class="keywordtype">float</span> **res,
<a name="l01202"></a>01202                 <span class="keywordtype">float</span> **mag_memo,
<a name="l01203"></a>01203                 <span class="keywordtype">int</span>   **mag_sort,
<a name="l01204"></a>01204                 <span class="keywordtype">int</span>   **ifloor,
<a name="l01205"></a>01205                 <span class="keywordtype">int</span>   *nonzero,
<a name="l01206"></a>01206                 <span class="keywordtype">int</span>  sliding_lowpass){
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="keywordtype">int</span> i,j,k,n=p-&gt;n;
<a name="l01209"></a>01209 
<a name="l01210"></a>01210   <span class="comment">/* perform any requested channel coupling */</span>
<a name="l01211"></a>01211   <span class="comment">/* point stereo can only be used in a first stage (in this encoder)</span>
<a name="l01212"></a>01212 <span class="comment">     because of the dependency on floor lookups */</span>
<a name="l01213"></a>01213   <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;coupling_steps;i++){
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     <span class="comment">/* once we&#39;re doing multistage coupling in which a channel goes</span>
<a name="l01216"></a>01216 <span class="comment">       through more than one coupling step, the floor vector</span>
<a name="l01217"></a>01217 <span class="comment">       magnitudes will also have to be recalculated an propogated</span>
<a name="l01218"></a>01218 <span class="comment">       along with PCM.  Right now, we&#39;re not (that will wait until 5.1</span>
<a name="l01219"></a>01219 <span class="comment">       most likely), so the code isn&#39;t here yet. The memory management</span>
<a name="l01220"></a>01220 <span class="comment">       here is all assuming single depth couplings anyway. */</span>
<a name="l01221"></a>01221 
<a name="l01222"></a>01222     <span class="comment">/* make sure coupling a zero and a nonzero channel results in two</span>
<a name="l01223"></a>01223 <span class="comment">       nonzero channels. */</span>
<a name="l01224"></a>01224     <span class="keywordflow">if</span>(nonzero[vi-&gt;coupling_mag[i]] ||
<a name="l01225"></a>01225        nonzero[vi-&gt;coupling_ang[i]]){
<a name="l01226"></a>01226      
<a name="l01227"></a>01227 
<a name="l01228"></a>01228       <span class="keywordtype">float</span> *rM=res[vi-&gt;coupling_mag[i]];
<a name="l01229"></a>01229       <span class="keywordtype">float</span> *rA=res[vi-&gt;coupling_ang[i]];
<a name="l01230"></a>01230       <span class="keywordtype">float</span> *qM=rM+n;
<a name="l01231"></a>01231       <span class="keywordtype">float</span> *qA=rA+n;
<a name="l01232"></a>01232       <span class="keywordtype">int</span> *floorM=ifloor[vi-&gt;coupling_mag[i]];
<a name="l01233"></a>01233       <span class="keywordtype">int</span> *floorA=ifloor[vi-&gt;coupling_ang[i]];
<a name="l01234"></a>01234       <span class="keywordtype">float</span> prepoint=stereo_threshholds[g-&gt;coupling_prepointamp[blobno]];
<a name="l01235"></a>01235       <span class="keywordtype">float</span> postpoint=stereo_threshholds[g-&gt;coupling_postpointamp[blobno]];
<a name="l01236"></a>01236       <span class="keywordtype">int</span> partition=(p-&gt;vi-&gt;normal_point_p?p-&gt;vi-&gt;normal_partition:p-&gt;n);
<a name="l01237"></a>01237       <span class="keywordtype">int</span> limit=g-&gt;coupling_pointlimit[p-&gt;vi-&gt;blockflag][blobno];
<a name="l01238"></a>01238       <span class="keywordtype">int</span> pointlimit=limit;
<a name="l01239"></a>01239 
<a name="l01240"></a>01240       nonzero[vi-&gt;coupling_mag[i]]=1; 
<a name="l01241"></a>01241       nonzero[vi-&gt;coupling_ang[i]]=1; 
<a name="l01242"></a>01242 
<a name="l01243"></a>01243        <span class="comment">/* The threshold of a stereo is changed with the size of n */</span>
<a name="l01244"></a>01244        <span class="keywordflow">if</span>(n &gt; 1000)
<a name="l01245"></a>01245          postpoint=stereo_threshholds_limited[g-&gt;coupling_postpointamp[blobno]]; 
<a name="l01246"></a>01246  
<a name="l01247"></a>01247       <span class="keywordflow">for</span>(j=0;j&lt;p-&gt;n;j+=partition){
<a name="l01248"></a>01248         <span class="keywordtype">float</span> acc=0.f;
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         <span class="keywordflow">for</span>(k=0;k&lt;partition;k++){
<a name="l01251"></a>01251           <span class="keywordtype">int</span> l=k+j;
<a name="l01252"></a>01252 
<a name="l01253"></a>01253           <span class="keywordflow">if</span>(l&lt;sliding_lowpass){
<a name="l01254"></a>01254             <span class="keywordflow">if</span>((l&gt;=limit &amp;&amp; fabs(rM[l])&lt;postpoint &amp;&amp; fabs(rA[l])&lt;postpoint) ||
<a name="l01255"></a>01255                (fabs(rM[l])&lt;prepoint &amp;&amp; fabs(rA[l])&lt;prepoint)){
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 
<a name="l01258"></a>01258               precomputed_couple_point(mag_memo[i][l],
<a name="l01259"></a>01259                                        floorM[l],floorA[l],
<a name="l01260"></a>01260                                        qM+l,qA+l);
<a name="l01261"></a>01261 
<a name="l01262"></a>01262               <span class="keywordflow">if</span>(rint(qM[l])==0.f)acc+=qM[l]*qM[l];
<a name="l01263"></a>01263             }<span class="keywordflow">else</span>{
<a name="l01264"></a>01264               couple_lossless(rM[l],rA[l],qM+l,qA+l);
<a name="l01265"></a>01265             }
<a name="l01266"></a>01266           }<span class="keywordflow">else</span>{
<a name="l01267"></a>01267             qM[l]=0.;
<a name="l01268"></a>01268             qA[l]=0.;
<a name="l01269"></a>01269           }
<a name="l01270"></a>01270         }
<a name="l01271"></a>01271         
<a name="l01272"></a>01272         <span class="keywordflow">if</span>(p-&gt;vi-&gt;normal_point_p){
<a name="l01273"></a>01273           <span class="keywordflow">for</span>(k=0;k&lt;partition &amp;&amp; acc&gt;=p-&gt;vi-&gt;normal_thresh;k++){
<a name="l01274"></a>01274             <span class="keywordtype">int</span> l=mag_sort[i][j+k];
<a name="l01275"></a>01275             <span class="keywordflow">if</span>(l&lt;sliding_lowpass &amp;&amp; l&gt;=pointlimit &amp;&amp; rint(qM[l])==0.f){
<a name="l01276"></a>01276               qM[l]=unitnorm(qM[l]);
<a name="l01277"></a>01277               acc-=1.f;
<a name="l01278"></a>01278             }
<a name="l01279"></a>01279           } 
<a name="l01280"></a>01280         }
<a name="l01281"></a>01281       }
<a name="l01282"></a>01282     }
<a name="l01283"></a>01283   }
<a name="l01284"></a>01284 }
<a name="l01285"></a>01285 
<a name="l01286"></a>01286 <span class="comment">/* AoTuV */</span>
<a name="l01293"></a>01293 <span class="keywordtype">void</span> hf_reduction(<a class="code" href="structvorbis__info__psy__global.html">vorbis_info_psy_global</a> *g,
<a name="l01294"></a>01294                       <a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *p, 
<a name="l01295"></a>01295                       <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *vi,
<a name="l01296"></a>01296                       <span class="keywordtype">float</span> **mdct){
<a name="l01297"></a>01297  
<a name="l01298"></a>01298   <span class="keywordtype">int</span> i,j,n=p-&gt;n, de=0.3*p-&gt;m_val;
<a name="l01299"></a>01299   <span class="keywordtype">int</span> limit=g-&gt;coupling_pointlimit[p-&gt;vi-&gt;blockflag][PACKETBLOBS/2];
<a name="l01300"></a>01300   <span class="comment">//int start=p-&gt;vi-&gt;normal_start;//warning</span>
<a name="l01301"></a>01301   
<a name="l01302"></a>01302   <span class="keywordflow">for</span>(i=0; i&lt;vi-&gt;coupling_steps; i++){
<a name="l01303"></a>01303     <span class="comment">/* for(j=start; j&lt;limit; j++){} // ???*/</span>
<a name="l01304"></a>01304     <span class="keywordflow">for</span>(j=limit; j&lt;n; j++) 
<a name="l01305"></a>01305       mdct[i][j] *= (1.0 - de*((<span class="keywordtype">float</span>)(j-limit) / (<span class="keywordtype">float</span>)(n-limit)));
<a name="l01306"></a>01306   }
<a name="l01307"></a>01307 }
</pre></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/src_2libvorbis_2lib_2psy_8c_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:19:05 GMT -->
</html>
