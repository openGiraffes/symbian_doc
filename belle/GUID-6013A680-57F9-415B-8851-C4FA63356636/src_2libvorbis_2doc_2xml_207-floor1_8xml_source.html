<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/src_2libvorbis_2doc_2xml_207-floor1_8xml_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:19:04 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Example Code: examples/SFExamples/oggvorbiscodec/src/libvorbis/doc/xml/07-floor1.xml Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<h1>examples/SFExamples/oggvorbiscodec/src/libvorbis/doc/xml/07-floor1.xml</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> standalone=<span class="stringliteral">&quot;no&quot;</span>?&gt;
<a name="l00002"></a>00002 &lt;!DOCTYPE section PUBLIC <span class="stringliteral">&quot;-//OASIS//DTD DocBook XML V4.2//EN&quot;</span>
<a name="l00003"></a>00003                 <span class="stringliteral">&quot;http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd&quot;</span> [
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 ]&gt;
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 &lt;section <span class="keywordtype">id</span>=<span class="stringliteral">&quot;vorbis-spec-floor1&quot;</span>&gt;
<a name="l00008"></a>00008 &lt;sectioninfo&gt;
<a name="l00009"></a>00009 &lt;releaseinfo&gt;
<a name="l00010"></a>00010  $Id: 07-floor1.xml 10466 2005-11-28 00:34:44Z giles $
<a name="l00011"></a>00011 &lt;/releaseinfo&gt;
<a name="l00012"></a>00012 &lt;/sectioninfo&gt;
<a name="l00013"></a>00013 &lt;title&gt;Floor type 1 setup and decode&lt;/title&gt;
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 &lt;section&gt;
<a name="l00016"></a>00016 &lt;title&gt;Overview&lt;/title&gt;
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 &lt;para&gt;
<a name="l00019"></a>00019 Vorbis floor type one uses a piecewise straight-line representation to
<a name="l00020"></a>00020 encode a spectral envelope curve. The representation plots <span class="keyword">this</span> curve
<a name="l00021"></a>00021 mechanically on a linear frequency axis and a logarithmic (dB)
<a name="l00022"></a>00022 amplitude axis. The integer plotting algorithm used is similar to
<a name="l00023"></a>00023 Bresenham&#39;s algorithm.&lt;/para&gt;
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 &lt;/section&gt;
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 &lt;section&gt;
<a name="l00028"></a>00028 &lt;title&gt;Floor 1 format&lt;/title&gt;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 &lt;section&gt;&lt;title&gt;model&lt;/title&gt;
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 &lt;para&gt;
<a name="l00033"></a>00033 Floor type one represents a spectral curve as a series of
<a name="l00034"></a>00034 line segments.  Synthesis constructs a floor curve using iterative
<a name="l00035"></a>00035 prediction in a process roughly equivalent to the following simplified
<a name="l00036"></a>00036 description:&lt;/para&gt;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 &lt;para&gt;
<a name="l00039"></a>00039 &lt;itemizedlist&gt;
<a name="l00040"></a>00040  &lt;listitem&gt;&lt;simpara&gt; the first line segment (base case) is a logical line spanning
<a name="l00041"></a>00041 from x_0,y_0 to x_1,y_1 where in the base case x_0=0 and x_1=[n], the
<a name="l00042"></a>00042 full range of the spectral floor to be computed.&lt;/simpara&gt;&lt;/listitem&gt;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 &lt;listitem&gt;&lt;simpara&gt;the induction step chooses a point x_new within an existing
<a name="l00045"></a>00045 logical line segment and produces a y_new value at that point computed
<a name="l00046"></a>00046 from the existing line&#39;s y value at x_new (as plotted by the line) and
<a name="l00047"></a>00047 a difference value decoded from the bitstream packet.&lt;/simpara&gt;&lt;/listitem&gt;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 &lt;listitem&gt;&lt;simpara&gt;floor computation produces two new line segments, one running from
<a name="l00050"></a>00050 x_0,y_0 to x_new,y_new and from x_new,y_new to x_1,y_1. This step is
<a name="l00051"></a>00051 performed logically even if y_new represents no change to the
<a name="l00052"></a>00052 amplitude value at x_new so that later refinement is additionally
<a name="l00053"></a>00053 bounded at x_new.&lt;/simpara&gt;&lt;/listitem&gt;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 &lt;listitem&gt;&lt;simpara&gt;the induction step repeats, using a list of x values specified in
<a name="l00056"></a>00056 the codec setup header at floor 1 initialization time.  Computation
<a name="l00057"></a>00057 is completed at the end of the x value list.&lt;/simpara&gt;&lt;/listitem&gt;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 &lt;/itemizedlist&gt;
<a name="l00060"></a>00060 &lt;/para&gt;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 &lt;para&gt;
<a name="l00063"></a>00063 Consider the following example, with values chosen <a class="code" href="interfacefor.html">for</a> ease of
<a name="l00064"></a>00064 understanding rather than representing typical configuration:&lt;/para&gt;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 &lt;para&gt;
<a name="l00067"></a>00067 For the below example, we assume a floor setup with an [n] of 128.
<a name="l00068"></a>00068 The list of selected X values in increasing order is
<a name="l00069"></a>00069 0,16,32,48,64,80,96,112 and 128.  In list order, the values interleave
<a name="l00070"></a>00070 as 0, 128, 64, 32, 96, 16, 48, 80 and 112.  The corresponding
<a name="l00071"></a>00071 list-order Y values as decoded from an example packet are 110, 20, -5,
<a name="l00072"></a>00072 -45, 0, -25, -10, 30 and -10.  We compute the floor in the following
<a name="l00073"></a>00073 way, beginning with the first line:&lt;/para&gt;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 &lt;mediaobject&gt;
<a name="l00076"></a>00076 &lt;imageobject&gt;
<a name="l00077"></a>00077  &lt;imagedata fileref=&quot;floor1-1.png&quot; format=&quot;PNG&quot;/&gt;
<a name="l00078"></a>00078 &lt;/imageobject&gt;
<a name="l00079"></a>00079 &lt;textobject&gt;
<a name="l00080"></a>00080  &lt;phrase&gt;[graph of example floor]&lt;/phrase&gt;
<a name="l00081"></a>00081 &lt;/textobject&gt;
<a name="l00082"></a>00082 &lt;/mediaobject&gt;
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 &lt;para&gt;
<a name="l00085"></a>00085 We now draw new logical lines to reflect the correction to new_Y, and
<a name="l00086"></a>00086 iterate <a class="code" href="interfacefor.html">for</a> X positions 32 and 96:&lt;/para&gt;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 &lt;mediaobject&gt;
<a name="l00089"></a>00089 &lt;imageobject&gt;
<a name="l00090"></a>00090  &lt;imagedata fileref=&quot;floor1-2.png&quot; format=&quot;PNG&quot;/&gt; 
<a name="l00091"></a>00091  &lt;/imageobject&gt;
<a name="l00092"></a>00092  &lt;textobject&gt;
<a name="l00093"></a>00093   &lt;phrase&gt;[graph of example floor]&lt;/phrase&gt;
<a name="l00094"></a>00094  &lt;/textobject&gt;
<a name="l00095"></a>00095 &lt;/mediaobject&gt;
<a name="l00096"></a>00096   
<a name="l00097"></a>00097 &lt;para&gt;
<a name="l00098"></a>00098 Although the new Y value at X position 96 is unchanged, it is still
<a name="l00099"></a>00099 used later as an endpoint <a class="code" href="interfacefor.html">for</a> further refinement.  From here on, the
<a name="l00100"></a>00100 pattern should be clear; we complete the floor computation as follows:&lt;/para&gt;
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 &lt;mediaobject&gt;
<a name="l00103"></a>00103 &lt;imageobject&gt;
<a name="l00104"></a>00104  &lt;imagedata fileref=&quot;floor1-3.png&quot; format=&quot;PNG&quot;/&gt; 
<a name="l00105"></a>00105  &lt;/imageobject&gt;
<a name="l00106"></a>00106  &lt;textobject&gt;
<a name="l00107"></a>00107   &lt;phrase&gt;[graph of example floor]&lt;/phrase&gt;
<a name="l00108"></a>00108  &lt;/textobject&gt;
<a name="l00109"></a>00109 &lt;/mediaobject&gt;
<a name="l00110"></a>00110   
<a name="l00111"></a>00111 &lt;mediaobject&gt;
<a name="l00112"></a>00112 &lt;imageobject&gt;
<a name="l00113"></a>00113  &lt;imagedata fileref=&quot;floor1-4.png&quot; format=&quot;PNG&quot;/&gt; 
<a name="l00114"></a>00114  &lt;/imageobject&gt;
<a name="l00115"></a>00115  &lt;textobject&gt;
<a name="l00116"></a>00116   &lt;phrase&gt;[graph of example floor]&lt;/phrase&gt;
<a name="l00117"></a>00117  &lt;/textobject&gt;
<a name="l00118"></a>00118 &lt;/mediaobject&gt;
<a name="l00119"></a>00119   
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 &lt;para&gt;
<a name="l00122"></a>00122 A more efficient algorithm with carefully defined integer rounding
<a name="l00123"></a>00123 behavior is used <a class="code" href="interfacefor.html">for</a> actual decode, as described later.  The actual
<a name="l00124"></a>00124 algorithm splits Y value computation and line plotting into two steps
<a name="l00125"></a>00125 with modifications to the above algorithm to eliminate noise
<a name="l00126"></a>00126 accumulation through integer roundoff/truncation. &lt;/para&gt;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 &lt;/section&gt;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 &lt;section&gt;&lt;title&gt;header decode&lt;/title&gt;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 &lt;para&gt;
<a name="l00133"></a>00133 A list of floor X values is stored in the packet header in interleaved
<a name="l00134"></a>00134 format (used in list order during packet decode and synthesis).  This
<a name="l00135"></a>00135 list is split into partitions, and each partition is assigned to a
<a name="l00136"></a>00136 partition class.  X positions 0 and [n] are implicit and do not belong
<a name="l00137"></a>00137 to an explicit partition or partition class.&lt;/para&gt;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 &lt;para&gt;
<a name="l00140"></a>00140 A partition class consists of a representation vector width (the
<a name="l00141"></a>00141 number of Y values which the partition class encodes at once), a
<a name="l00142"></a>00142 &#39;subclass&#39; value representing the number of alternate entropy books
<a name="l00143"></a>00143 the partition class may use in representing Y values, the list of
<a name="l00144"></a>00144 [subclass] books and a master book used to encode which alternate
<a name="l00145"></a>00145 books were chosen <a class="code" href="interfacefor.html">for</a> representation in a given packet.  The
<a name="l00146"></a>00146 master/subclass mechanism is meant to be used as a flexible
<a name="l00147"></a>00147 representation cascade while still using codebooks only in a scalar
<a name="l00148"></a>00148 context.&lt;/para&gt;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 &lt;screen&gt;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   1) [floor1_partitions] = read 5 bits as <span class="keywordtype">unsigned</span> integer
<a name="l00153"></a>00153   2) [maximum_class] = -1
<a name="l00154"></a>00154   3) iterate [i] over the range 0 ... [floor1_partitions]-1 {
<a name="l00155"></a>00155        
<a name="l00156"></a>00156         4) vector [floor1_partition_class_list] element [i] = read 4 bits as <span class="keywordtype">unsigned</span> integer
<a name="l00157"></a>00157 
<a name="l00158"></a>00158      }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   5) [maximum_class] = largest integer scalar value in vector [floor1_partition_class_list]
<a name="l00161"></a>00161   6) iterate [i] over the range 0 ... [maximum_class] {
<a name="l00162"></a>00162 
<a name="l00163"></a>00163         7) vector [floor1_class_dimensions] element [i] = read 3 bits as <span class="keywordtype">unsigned</span> integer and add 1
<a name="l00164"></a>00164         8) vector [floor1_class_subclasses] element [i] = read 2 bits as <span class="keywordtype">unsigned</span> integer
<a name="l00165"></a>00165         9) <span class="keywordflow">if</span> ( vector [floor1_class_subclasses] element [i] is nonzero ) {
<a name="l00166"></a>00166             
<a name="l00167"></a>00167              10) vector [floor1_class_masterbooks] element [i] = read 8 bits as <span class="keywordtype">unsigned</span> integer
<a name="l00168"></a>00168            
<a name="l00169"></a>00169            }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171        11) iterate [j] over the range 0 ... (2 exponent [floor1_class_subclasses] element [i]) - 1  {
<a name="l00172"></a>00172 
<a name="l00173"></a>00173              12) array [floor1_subclass_books] element [i],[j] = 
<a name="l00174"></a>00174                  read 8 bits as <span class="keywordtype">unsigned</span> integer and subtract one
<a name="l00175"></a>00175            }
<a name="l00176"></a>00176       }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178  13) [floor1_multiplier] = read 2 bits as <span class="keywordtype">unsigned</span> integer and add one
<a name="l00179"></a>00179  14) [rangebits] = read 4 bits as <span class="keywordtype">unsigned</span> integer
<a name="l00180"></a>00180  15) vector [floor1_X_list] element [0] = 0
<a name="l00181"></a>00181  16) vector [floor1_X_list] element [1] = 2 exponent [rangebits];
<a name="l00182"></a>00182  17) [floor1_values] = 2
<a name="l00183"></a>00183  18) iterate [i] over the range 0 ... [floor1_partitions]-1 {
<a name="l00184"></a>00184 
<a name="l00185"></a>00185        19) [current_class_number] = vector [floor1_partition_class_list] element [i]
<a name="l00186"></a>00186        20) iterate [j] over the range 0 ... ([floor1_class_dimensions] element [current_class_number])-1 {
<a name="l00187"></a>00187              21) vector [floor1_X_list] element ([floor1_values]) = 
<a name="l00188"></a>00188                  read [rangebits] bits as <span class="keywordtype">unsigned</span> integer
<a name="l00189"></a>00189              22) increment [floor1_values] by one
<a name="l00190"></a>00190            }
<a name="l00191"></a>00191      }
<a name="l00192"></a>00192  
<a name="l00193"></a>00193  23) done
<a name="l00194"></a>00194 &lt;/screen&gt;
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 &lt;para&gt;
<a name="l00197"></a>00197 An end-of-packet condition <span class="keywordflow">while</span> reading any aspect of a floor 1
<a name="l00198"></a>00198 configuration during setup renders a stream undecodable.  In
<a name="l00199"></a>00199 addition, a &lt;varname&gt;[floor1_class_masterbooks]&lt;/varname&gt; or
<a name="l00200"></a>00200 &lt;varname&gt;[floor1_subclass_books]&lt;/varname&gt; scalar element greater than the
<a name="l00201"></a>00201 highest numbered <a class="code" href="structcodebook.html">codebook</a> configured in <span class="keyword">this</span> stream is an error
<a name="l00202"></a>00202 condition that renders the stream undecodable.&lt;/para&gt;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 &lt;section <span class="keywordtype">id</span>=<span class="stringliteral">&quot;vorbis-spec-floor1-decode&quot;</span>&gt;
<a name="l00205"></a>00205 &lt;title&gt;packet decode&lt;/title&gt;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 &lt;para&gt;
<a name="l00208"></a>00208 Packet decode begins by checking the &lt;varname&gt;[nonzero]&lt;/varname&gt; flag:&lt;/para&gt;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 &lt;screen&gt;
<a name="l00211"></a>00211   1) [nonzero] = read 1 bit as <span class="keywordtype">boolean</span>
<a name="l00212"></a>00212 &lt;/screen&gt;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 &lt;para&gt;
<a name="l00215"></a>00215 If &lt;varname&gt;[nonzero]&lt;/varname&gt; is unset, that indicates <span class="keyword">this</span> channel contained
<a name="l00216"></a>00216 no audio energy in <span class="keyword">this</span> frame.  Decode immediately returns a status
<a name="l00217"></a>00217 indicating <span class="keyword">this</span> floor curve (and thus <span class="keyword">this</span> channel) is unused <span class="keyword">this</span>
<a name="l00218"></a>00218 frame.  (A <span class="keywordflow">return</span> status of <span class="stringliteral">&#39;unused&#39;</span> is different from decoding a
<a name="l00219"></a>00219 floor that has all points <span class="keyword">set</span> to minimum representation amplitude,
<a name="l00220"></a>00220 which happens to be approximately -140dB).
<a name="l00221"></a>00221 &lt;/para&gt;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 &lt;para&gt;
<a name="l00224"></a>00224 Assuming &lt;varname&gt;[nonzero]&lt;/varname&gt; is <span class="keyword">set</span>, decode proceeds as follows:&lt;/para&gt;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 &lt;screen&gt;
<a name="l00227"></a>00227   1) [range] = vector { 256, 128, 86, 64 } element ([floor1_multiplier]-1)
<a name="l00228"></a>00228   2) vector [floor1_Y] element [0] = read &lt;link linkend=&quot;vorbis-spec-ilog&quot;&gt;ilog&lt;/link&gt;([range]-1) bits as <span class="keywordtype">unsigned</span> integer
<a name="l00229"></a>00229   3) vector [floor1_Y] element [1] = read &lt;link linkend=&quot;vorbis-spec-ilog&quot;&gt;ilog&lt;/link&gt;([range]-1) bits as <span class="keywordtype">unsigned</span> integer
<a name="l00230"></a>00230   4) [offset] = 2;
<a name="l00231"></a>00231   5) iterate [i] over the range 0 ... [floor1_partitions]-1 {
<a name="l00232"></a>00232 
<a name="l00233"></a>00233        6) [<span class="keyword">class</span>] = vector [floor1_partition_class]  element [i]
<a name="l00234"></a>00234        7) [cdim]  = vector [floor1_class_dimensions] element [<span class="keyword">class</span>]
<a name="l00235"></a>00235        8) [cbits] = vector [floor1_class_subclasses] element [<span class="keyword">class</span>]
<a name="l00236"></a>00236        9) [csub]  = (2 exponent [cbits])-1
<a name="l00237"></a>00237       10) [cval]  = 0
<a name="l00238"></a>00238       11) <span class="keywordflow">if</span> ( [cbits] is greater than zero ) {
<a name="l00239"></a>00239  
<a name="l00240"></a>00240              12) [cval] = read from packet <span class="keyword">using</span> <a class="code" href="structcodebook.html">codebook</a> number
<a name="l00241"></a>00241                  (vector [floor1_class_masterbooks] element [<span class="keyword">class</span>]) in scalar context
<a name="l00242"></a>00242           }
<a name="l00243"></a>00243       
<a name="l00244"></a>00244       13) iterate [j] over the range 0 ... [cdim]-1 {
<a name="l00245"></a>00245        
<a name="l00246"></a>00246              14) [book] = array [floor1_subclass_books] element [<span class="keyword">class</span>],([cval] bitwise AND [csub])
<a name="l00247"></a>00247              15) [cval] = [cval] right shifted [cbits] bits
<a name="l00248"></a>00248              16) <span class="keywordflow">if</span> ( [book] is not less than zero ) {
<a name="l00249"></a>00249              
<a name="l00250"></a>00250                    17) vector [floor1_Y] element ([j]+[offset]) = read from packet <span class="keyword">using</span> <a class="code" href="structcodebook.html">codebook</a> 
<a name="l00251"></a>00251                        [book] in scalar context
<a name="l00252"></a>00252 
<a name="l00253"></a>00253                  } <span class="keywordflow">else</span> [book] is less than zero {
<a name="l00254"></a>00254 
<a name="l00255"></a>00255                    18) vector [floor1_Y] element ([j]+[offset]) = 0
<a name="l00256"></a>00256 
<a name="l00257"></a>00257                  }
<a name="l00258"></a>00258           }
<a name="l00259"></a>00259              
<a name="l00260"></a>00260       19) [offset] = [offset] + [cdim]
<a name="l00261"></a>00261          
<a name="l00262"></a>00262      }
<a name="l00263"></a>00263   
<a name="l00264"></a>00264  20) done
<a name="l00265"></a>00265 &lt;/screen&gt;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 &lt;para&gt;
<a name="l00268"></a>00268 An end-of-packet condition during curve decode should be considered a
<a name="l00269"></a>00269 nominal occurrence; <span class="keywordflow">if</span> end-of-packet is reached during any read
<a name="l00270"></a>00270 operation above, floor decode is to <span class="keywordflow">return</span> <span class="stringliteral">&#39;unused&#39;</span> status as <span class="keywordflow">if</span> the
<a name="l00271"></a>00271 &lt;varname&gt;[nonzero]&lt;/varname&gt; flag had been unset at the beginning of decode.
<a name="l00272"></a>00272 &lt;/para&gt;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 &lt;para&gt;
<a name="l00275"></a>00275 Vector &lt;varname&gt;[floor1_Y]&lt;/varname&gt; contains the values from packet decode
<a name="l00276"></a>00276 needed <span class="keywordflow">for</span> floor 1 synthesis.&lt;/para&gt;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 &lt;/section&gt;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 &lt;section <span class="keywordtype">id</span>=<span class="stringliteral">&quot;vorbis-spec-floor1-synth&quot;</span>&gt;
<a name="l00281"></a>00281 &lt;title&gt;curve computation&lt;/title&gt;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 &lt;para&gt;
<a name="l00284"></a>00284 Curve computation is split into two logical steps; the first step
<a name="l00285"></a>00285 derives <span class="keyword">final</span> Y amplitude values from the encoded, wrapped difference
<a name="l00286"></a>00286 values taken from the bitstream.  The second step plots the curve
<a name="l00287"></a>00287 lines.  Also, although zero-difference values are used in the
<a name="l00288"></a>00288 iterative prediction to find <span class="keyword">final</span> Y values, these points are
<a name="l00289"></a>00289 conditionally skipped during <span class="keyword">final</span> line computation in step two.
<a name="l00290"></a>00290 Skipping zero-difference values allows a smoother line fit.  &lt;/para&gt;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 &lt;para&gt;
<a name="l00293"></a>00293 Although some aspects of the below algorithm look like inconsequential
<a name="l00294"></a>00294 optimizations, implementors are warned to follow the details closely.
<a name="l00295"></a>00295 Deviation from implementing a strictly equivalent algorithm can result
<a name="l00296"></a>00296 in serious decoding errors.&lt;/para&gt;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 &lt;section&gt;
<a name="l00299"></a>00299 &lt;title&gt;step 1: amplitude value synthesis&lt;/title&gt;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 &lt;para&gt;
<a name="l00302"></a>00302 Unwrap the always-positive-or-zero values read from the packet into
<a name="l00303"></a>00303 +/- difference values, then apply to line prediction.&lt;/para&gt;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 &lt;screen&gt;
<a name="l00306"></a>00306   1) [range] = vector { 256, 128, 86, 64 } element ([floor1_multiplier]-1)
<a name="l00307"></a>00307   2) vector [floor1_step2_flag] element [0] = <span class="keyword">set</span>
<a name="l00308"></a>00308   3) vector [floor1_step2_flag] element [1] = <span class="keyword">set</span>
<a name="l00309"></a>00309   4) vector [floor1_final_Y] element [0] = vector [floor1_Y] element [0]
<a name="l00310"></a>00310   5) vector [floor1_final_Y] element [1] = vector [floor1_Y] element [1]
<a name="l00311"></a>00311   6) iterate [i] over the range 2 ... [floor1_values]-1 {
<a name="l00312"></a>00312     
<a name="l00313"></a>00313        7) [low_neighbor_offset] = &lt;link linkend=<span class="stringliteral">&quot;vorbis-spec-low_neighbor&quot;</span>&gt;low_neighbor&lt;/link&gt;([floor1_X_list],[i])
<a name="l00314"></a>00314        8) [high_neighbor_offset] = &lt;link linkend=<span class="stringliteral">&quot;vorbis-spec-high_neighbor&quot;</span>&gt;high_neighbor&lt;/link&gt;([floor1_X_list],[i])
<a name="l00315"></a>00315 
<a name="l00316"></a>00316        9) [predicted] = &lt;link linkend=<span class="stringliteral">&quot;vorbis-spec-render_point&quot;</span>&gt;render_point&lt;/link&gt;( vector [floor1_X_list] element [low_neighbor_offset],
<a name="l00317"></a>00317                                       vector [floor1_final_Y] element [low_neighbor_offset],
<a name="l00318"></a>00318                                       vector [floor1_X_list] element [high_neighbor_offset],
<a name="l00319"></a>00319                                       vector [floor1_final_Y] element [high_neighbor_offset],
<a name="l00320"></a>00320                                       vector [floor1_X_list] element [i] )
<a name="l00321"></a>00321 
<a name="l00322"></a>00322       10) [val] = vector [floor1_Y] element [i]
<a name="l00323"></a>00323       11) [highroom] = [range] - [predicted]
<a name="l00324"></a>00324       12) [lowroom]  = [predicted]
<a name="l00325"></a>00325       13) <span class="keywordflow">if</span> ( [highroom] is less than [lowroom] ) {
<a name="l00326"></a>00326 
<a name="l00327"></a>00327             14) [room] = [highroom] * 2
<a name="l00328"></a>00328          
<a name="l00329"></a>00329           } <span class="keywordflow">else</span> [highroom] is not less than [lowroom] {
<a name="l00330"></a>00330                       
<a name="l00331"></a>00331             15) [room] = [lowroom] * 2
<a name="l00332"></a>00332         
<a name="l00333"></a>00333           }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335       16) <span class="keywordflow">if</span> ( [val] is nonzero ) {
<a name="l00336"></a>00336 
<a name="l00337"></a>00337             17) vector [floor1_step2_flag] element [low_neighbor_offset] = <span class="keyword">set</span>
<a name="l00338"></a>00338             18) vector [floor1_step2_flag] element [high_neighbor_offset] = <span class="keyword">set</span>
<a name="l00339"></a>00339             19) vector [floor1_step2_flag] element [i] = <span class="keyword">set</span>
<a name="l00340"></a>00340             20) <span class="keywordflow">if</span> ( [val] is greater than or equal to [room] ) {
<a name="l00341"></a>00341  
<a name="l00342"></a>00342                   21) <span class="keywordflow">if</span> ( [highroom] is greater than [lowroom] ) {
<a name="l00343"></a>00343 
<a name="l00344"></a>00344                         22) vector [floor1_final_Y] element [i] = [val] - [lowroom] + [predicted]
<a name="l00345"></a>00345                      
<a name="l00346"></a>00346                       } <span class="keywordflow">else</span> [highroom] is not greater than [lowroom] {
<a name="l00347"></a>00347               
<a name="l00348"></a>00348                         23) vector [floor1_final_Y] element [i] = [predicted] - [val] + [highroom] - 1
<a name="l00349"></a>00349                    
<a name="l00350"></a>00350                       }
<a name="l00351"></a>00351                
<a name="l00352"></a>00352                 } <span class="keywordflow">else</span> [val] is less than [room] {
<a name="l00353"></a>00353                  
<a name="l00354"></a>00354                   24) <span class="keywordflow">if</span> ([val] is odd) {
<a name="l00355"></a>00355                  
<a name="l00356"></a>00356                         25) vector [floor1_final_Y] element [i] = 
<a name="l00357"></a>00357                             [predicted] - (([val] + 1) divided by  2 <span class="keyword">using</span> integer division)
<a name="l00358"></a>00358 
<a name="l00359"></a>00359                       } <span class="keywordflow">else</span> [val] is even {
<a name="l00360"></a>00360 
<a name="l00361"></a>00361                         26) vector [floor1_final_Y] element [i] = 
<a name="l00362"></a>00362                             [predicted] + ([val] / 2 <span class="keyword">using</span> integer division)
<a name="l00363"></a>00363                           
<a name="l00364"></a>00364                       }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366                 }      
<a name="l00367"></a>00367 
<a name="l00368"></a>00368           } <span class="keywordflow">else</span> [val] is zero {
<a name="l00369"></a>00369 
<a name="l00370"></a>00370             27) vector [floor1_step2_flag] element [i] = unset
<a name="l00371"></a>00371             28) vector [floor1_final_Y] element [i] = [predicted]
<a name="l00372"></a>00372 
<a name="l00373"></a>00373           }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375      }
<a name="l00376"></a>00376 
<a name="l00377"></a>00377  29) done
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 &lt;/screen&gt;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 &lt;/section&gt;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 &lt;section&gt;
<a name="l00384"></a>00384 &lt;title&gt;step 2: curve synthesis&lt;/title&gt;
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 &lt;para&gt;
<a name="l00387"></a>00387 Curve synthesis generates a <span class="keywordflow">return</span> vector &lt;varname&gt;[floor]&lt;/varname&gt; of length
<a name="l00388"></a>00388 &lt;varname&gt;[n]&lt;/varname&gt; (where &lt;varname&gt;[n]&lt;/varname&gt; is provided by the decode process
<a name="l00389"></a>00389 calling to floor decode).  Floor 1 curve synthesis makes use of the
<a name="l00390"></a>00390 &lt;varname&gt;[floor1_X_list]&lt;/varname&gt;, &lt;varname&gt;[floor1_final_Y]&lt;/varname&gt; and
<a name="l00391"></a>00391 &lt;varname&gt;[floor1_step2_flag]&lt;/varname&gt; vectors, as well as [floor1_multiplier]
<a name="l00392"></a>00392 and [floor1_values] values.&lt;/para&gt;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 &lt;para&gt;
<a name="l00395"></a>00395 Decode begins by sorting the scalars from vectors
<a name="l00396"></a>00396 &lt;varname&gt;[floor1_X_list]&lt;/varname&gt;, &lt;varname&gt;[floor1_final_Y]&lt;/varname&gt; and
<a name="l00397"></a>00397 &lt;varname&gt;[floor1_step2_flag]&lt;/varname&gt; together into <span class="keyword">new</span> vectors
<a name="l00398"></a>00398 &lt;varname&gt;[floor1_X_list]<span class="stringliteral">&#39;&lt;/varname&gt;, &lt;varname&gt;[floor1_final_Y]&#39;</span>&lt;/varname&gt; and
<a name="l00399"></a>00399 &lt;varname&gt;[floor1_step2_flag]<span class="stringliteral">&#39;&lt;/varname&gt; according to ascending sort order of the</span>
<a name="l00400"></a>00400 <span class="stringliteral">values in &lt;varname&gt;[floor1_X_list]&lt;/varname&gt;.  That is, sort the values of</span>
<a name="l00401"></a>00401 <span class="stringliteral">&lt;varname&gt;[floor1_X_list]&lt;/varname&gt; and then apply the same permutation to</span>
<a name="l00402"></a>00402 <span class="stringliteral">elements of the other two vectors so that the X, Y and step2_flag</span>
<a name="l00403"></a>00403 <span class="stringliteral">values still match.&lt;/para&gt;</span>
<a name="l00404"></a>00404 <span class="stringliteral"></span>
<a name="l00405"></a>00405 <span class="stringliteral">&lt;para&gt;</span>
<a name="l00406"></a>00406 <span class="stringliteral">Then compute the final curve in one pass:&lt;/para&gt;</span>
<a name="l00407"></a>00407 <span class="stringliteral"></span>
<a name="l00408"></a>00408 <span class="stringliteral">&lt;screen&gt;</span>
<a name="l00409"></a>00409 <span class="stringliteral">  1) [hx] = 0</span>
<a name="l00410"></a>00410 <span class="stringliteral">  2) [lx] = 0</span>
<a name="l00411"></a>00411 <span class="stringliteral">  3) [ly] = vector [floor1_final_Y]&#39;</span> element [0] * [floor1_multiplier]
<a name="l00412"></a>00412   4) iterate [i] over the range 1 ... [floor1_values]-1 {
<a name="l00413"></a>00413 
<a name="l00414"></a>00414        5) <span class="keywordflow">if</span> ( [floor1_step2_flag]<span class="stringliteral">&#39; element [i] is set ) {</span>
<a name="l00415"></a>00415 <span class="stringliteral"></span>
<a name="l00416"></a>00416 <span class="stringliteral">             6) [hy] = [floor1_final_Y]&#39;</span> element [i] * [floor1_multiplier]
<a name="l00417"></a>00417              7) [hx] = [floor1_X_list]<span class="stringliteral">&#39; element [i]</span>
<a name="l00418"></a>00418 <span class="stringliteral">             8) &lt;link linkend=&quot;vorbis-spec-render_line&quot;&gt;render_line&lt;/link&gt;( [lx], [ly], [hx], [hy], [floor] )</span>
<a name="l00419"></a>00419 <span class="stringliteral">             9) [lx] = [hx]</span>
<a name="l00420"></a>00420 <span class="stringliteral">            10) [ly] = [hy]</span>
<a name="l00421"></a>00421 <span class="stringliteral">          }</span>
<a name="l00422"></a>00422 <span class="stringliteral">     }</span>
<a name="l00423"></a>00423 <span class="stringliteral"> </span>
<a name="l00424"></a>00424 <span class="stringliteral"> 11) if ( [hx] is less than [n] ) {</span>
<a name="l00425"></a>00425 <span class="stringliteral"></span>
<a name="l00426"></a>00426 <span class="stringliteral">        12) &lt;link linkend=&quot;vorbis-spec-render_line&quot;&gt;render_line&lt;/link&gt;( [hx], [hy], [n], [hy], [floor] )</span>
<a name="l00427"></a>00427 <span class="stringliteral"></span>
<a name="l00428"></a>00428 <span class="stringliteral">     }</span>
<a name="l00429"></a>00429 <span class="stringliteral"></span>
<a name="l00430"></a>00430 <span class="stringliteral"> 13) if ( [hx] is greater than [n] ) {</span>
<a name="l00431"></a>00431 <span class="stringliteral"></span>
<a name="l00432"></a>00432 <span class="stringliteral">            14) truncate vector [floor] to [n] elements</span>
<a name="l00433"></a>00433 <span class="stringliteral"></span>
<a name="l00434"></a>00434 <span class="stringliteral">     }</span>
<a name="l00435"></a>00435 <span class="stringliteral"> </span>
<a name="l00436"></a>00436 <span class="stringliteral"> 15) for each scalar in vector [floor], perform a lookup substitution using </span>
<a name="l00437"></a>00437 <span class="stringliteral">     the scalar value from [floor] as an offset into the vector &lt;link linkend=&quot;vorbis-spec-floor1_inverse_dB_table&quot;&gt;[floor1_inverse_dB_static_table]&lt;/link&gt;</span>
<a name="l00438"></a>00438 <span class="stringliteral"></span>
<a name="l00439"></a>00439 <span class="stringliteral"> 16) done</span>
<a name="l00440"></a>00440 <span class="stringliteral"></span>
<a name="l00441"></a>00441 <span class="stringliteral">&lt;/screen&gt;</span>
<a name="l00442"></a>00442 <span class="stringliteral"></span>
<a name="l00443"></a>00443 <span class="stringliteral">&lt;/section&gt;</span>
<a name="l00444"></a>00444 <span class="stringliteral"></span>
<a name="l00445"></a>00445 <span class="stringliteral">&lt;/section&gt;</span>
<a name="l00446"></a>00446 <span class="stringliteral"></span>
<a name="l00447"></a>00447 <span class="stringliteral">&lt;/section&gt;</span>
<a name="l00448"></a>00448 <span class="stringliteral">&lt;/section&gt;</span>
<a name="l00449"></a>00449 <span class="stringliteral">&lt;/section&gt;</span>
<a name="l00450"></a>00450 <span class="stringliteral"></span>
</pre></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/src_2libvorbis_2doc_2xml_207-floor1_8xml_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:19:04 GMT -->
</html>
