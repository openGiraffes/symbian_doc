<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/src_2libvorbis_2lib_2mapping0_8c_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:19:05 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Example Code: examples/SFExamples/oggvorbiscodec/src/libvorbis/lib/mapping0.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<h1>examples/SFExamples/oggvorbiscodec/src/libvorbis/lib/mapping0.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/********************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *                                                                  *</span>
<a name="l00003"></a>00003 <span class="comment"> * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *</span>
<a name="l00004"></a>00004 <span class="comment"> * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *</span>
<a name="l00005"></a>00005 <span class="comment"> * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *</span>
<a name="l00006"></a>00006 <span class="comment"> * IN &#39;COPYING&#39;. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *</span>
<a name="l00007"></a>00007 <span class="comment"> *                                                                  *</span>
<a name="l00008"></a>00008 <span class="comment"> * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2002             *</span>
<a name="l00009"></a>00009 <span class="comment"> * by the XIPHOPHORUS Company http://www.xiph.org/                  *</span>
<a name="l00010"></a>00010 <span class="comment"> *                                                                  *</span>
<a name="l00011"></a>00011 <span class="comment"> ********************************************************************</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment"> function: channel mapping 0 implementation</span>
<a name="l00014"></a>00014 <span class="comment"> last mod: $Id: mapping0.c 7187 2004-07-20 07:24:27Z xiphmont $</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> ********************************************************************/</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;ogg/ogg.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;vorbis/codec.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;codec_internal.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;codebook.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;window.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;registry.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;psy.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;misc.h&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment">/* simplistic, wasteful way of doing this (unique lookup for each</span>
<a name="l00032"></a>00032 <span class="comment">   mode/submapping); there should be a central repository for</span>
<a name="l00033"></a>00033 <span class="comment">   identical lookups.  That will require minor work, so I&#39;m putting it</span>
<a name="l00034"></a>00034 <span class="comment">   off as low priority.</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">   Why a lookup for each backend in a given mode?  Because the</span>
<a name="l00037"></a>00037 <span class="comment">   blocksize is set by the mode, and low backend lookups may require</span>
<a name="l00038"></a>00038 <span class="comment">   parameters from other areas of the mode/mapping */</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">static</span> <span class="keywordtype">void</span> mapping0_free_info(vorbis_info_mapping *i){
<a name="l00041"></a>00041   <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *info=(<a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *)i;
<a name="l00042"></a>00042   <span class="keywordflow">if</span>(info){
<a name="l00043"></a>00043     memset(info,0,<span class="keyword">sizeof</span>(*info));
<a name="l00044"></a>00044     _ogg_free(info);
<a name="l00045"></a>00045   }
<a name="l00046"></a>00046 }
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">static</span> <span class="keywordtype">int</span> ilog(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v){
<a name="l00049"></a>00049   <span class="keywordtype">int</span> ret=0;
<a name="l00050"></a>00050   <span class="keywordflow">if</span>(v)--v;
<a name="l00051"></a>00051   <span class="keywordflow">while</span>(v){
<a name="l00052"></a>00052     ret++;
<a name="l00053"></a>00053     v&gt;&gt;=1;
<a name="l00054"></a>00054   }
<a name="l00055"></a>00055   <span class="keywordflow">return</span>(ret);
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">void</span> mapping0_pack(<a class="code" href="structvorbis__info.html">vorbis_info</a> *vi,vorbis_info_mapping *vm,
<a name="l00059"></a>00059                           <a class="code" href="structoggpack__buffer.html">oggpack_buffer</a> *opb){
<a name="l00060"></a>00060   <span class="keywordtype">int</span> i;
<a name="l00061"></a>00061   <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *info=(<a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *)vm;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063   <span class="comment">/* another &#39;we meant to do it this way&#39; hack...  up to beta 4, we</span>
<a name="l00064"></a>00064 <span class="comment">     packed 4 binary zeros here to signify one submapping in use.  We</span>
<a name="l00065"></a>00065 <span class="comment">     now redefine that to mean four bitflags that indicate use of</span>
<a name="l00066"></a>00066 <span class="comment">     deeper features; bit0:submappings, bit1:coupling,</span>
<a name="l00067"></a>00067 <span class="comment">     bit2,3:reserved. This is backward compatable with all actual uses</span>
<a name="l00068"></a>00068 <span class="comment">     of the beta code. */</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070   <span class="keywordflow">if</span>(info-&gt;submaps&gt;1){
<a name="l00071"></a>00071     oggpack_write(opb,1,1);
<a name="l00072"></a>00072     oggpack_write(opb,info-&gt;submaps-1,4);
<a name="l00073"></a>00073   }<span class="keywordflow">else</span>
<a name="l00074"></a>00074     oggpack_write(opb,0,1);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076   <span class="keywordflow">if</span>(info-&gt;coupling_steps&gt;0){
<a name="l00077"></a>00077     oggpack_write(opb,1,1);
<a name="l00078"></a>00078     oggpack_write(opb,info-&gt;coupling_steps-1,8);
<a name="l00079"></a>00079     
<a name="l00080"></a>00080     <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;coupling_steps;i++){
<a name="l00081"></a>00081       oggpack_write(opb,info-&gt;coupling_mag[i],ilog(vi-&gt;channels));
<a name="l00082"></a>00082       oggpack_write(opb,info-&gt;coupling_ang[i],ilog(vi-&gt;channels));
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084   }<span class="keywordflow">else</span>
<a name="l00085"></a>00085     oggpack_write(opb,0,1);
<a name="l00086"></a>00086   
<a name="l00087"></a>00087   oggpack_write(opb,0,2); <span class="comment">/* 2,3:reserved */</span>
<a name="l00088"></a>00088 
<a name="l00089"></a>00089   <span class="comment">/* we don&#39;t write the channel submappings if we only have one... */</span>
<a name="l00090"></a>00090   <span class="keywordflow">if</span>(info-&gt;submaps&gt;1){
<a name="l00091"></a>00091     <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++)
<a name="l00092"></a>00092       oggpack_write(opb,info-&gt;chmuxlist[i],4);
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094   <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;submaps;i++){
<a name="l00095"></a>00095     oggpack_write(opb,0,8); <span class="comment">/* time submap unused */</span>
<a name="l00096"></a>00096     oggpack_write(opb,info-&gt;floorsubmap[i],8);
<a name="l00097"></a>00097     oggpack_write(opb,info-&gt;residuesubmap[i],8);
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">/* also responsible for range checking */</span>
<a name="l00102"></a>00102 <span class="keyword">static</span> vorbis_info_mapping *mapping0_unpack(<a class="code" href="structvorbis__info.html">vorbis_info</a> *vi,<a class="code" href="structoggpack__buffer.html">oggpack_buffer</a> *opb){
<a name="l00103"></a>00103   <span class="keywordtype">int</span> i;
<a name="l00104"></a>00104   <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *info=(<a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a>*)_ogg_calloc(1,<span class="keyword">sizeof</span>(*info));
<a name="l00105"></a>00105   <a class="code" href="structcodec__setup__info.html">codec_setup_info</a>     *ci=(<a class="code" href="structcodec__setup__info.html">codec_setup_info</a>*)vi-&gt;codec_setup;
<a name="l00106"></a>00106   memset(info,0,<span class="keyword">sizeof</span>(*info));
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordflow">if</span>(oggpack_read(opb,1))
<a name="l00109"></a>00109     info-&gt;submaps=oggpack_read(opb,4)+1;
<a name="l00110"></a>00110   <span class="keywordflow">else</span>
<a name="l00111"></a>00111     info-&gt;submaps=1;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <span class="keywordflow">if</span>(oggpack_read(opb,1)){
<a name="l00114"></a>00114     info-&gt;coupling_steps=oggpack_read(opb,8)+1;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;coupling_steps;i++){
<a name="l00117"></a>00117       <span class="keywordtype">int</span> testM=info-&gt;coupling_mag[i]=oggpack_read(opb,ilog(vi-&gt;channels));
<a name="l00118"></a>00118       <span class="keywordtype">int</span> testA=info-&gt;coupling_ang[i]=oggpack_read(opb,ilog(vi-&gt;channels));
<a name="l00119"></a>00119 
<a name="l00120"></a>00120       <span class="keywordflow">if</span>(testM&lt;0 || 
<a name="l00121"></a>00121          testA&lt;0 || 
<a name="l00122"></a>00122          testM==testA || 
<a name="l00123"></a>00123          testM&gt;=vi-&gt;channels ||
<a name="l00124"></a>00124          testA&gt;=vi-&gt;channels) <span class="keywordflow">goto</span> err_out;
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <span class="keywordflow">if</span>(oggpack_read(opb,2)&gt;0)<span class="keywordflow">goto</span> err_out; <span class="comment">/* 2,3:reserved */</span>
<a name="l00130"></a>00130     
<a name="l00131"></a>00131   <span class="keywordflow">if</span>(info-&gt;submaps&gt;1){
<a name="l00132"></a>00132     <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00133"></a>00133       info-&gt;chmuxlist[i]=oggpack_read(opb,4);
<a name="l00134"></a>00134       <span class="keywordflow">if</span>(info-&gt;chmuxlist[i]&gt;=info-&gt;submaps)<span class="keywordflow">goto</span> err_out;
<a name="l00135"></a>00135     }
<a name="l00136"></a>00136   }
<a name="l00137"></a>00137   <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;submaps;i++){
<a name="l00138"></a>00138     oggpack_read(opb,8); <span class="comment">/* time submap unused */</span>
<a name="l00139"></a>00139     info-&gt;floorsubmap[i]=oggpack_read(opb,8);
<a name="l00140"></a>00140     <span class="keywordflow">if</span>(info-&gt;floorsubmap[i]&gt;=ci-&gt;floors)<span class="keywordflow">goto</span> err_out;
<a name="l00141"></a>00141     info-&gt;residuesubmap[i]=oggpack_read(opb,8);
<a name="l00142"></a>00142     <span class="keywordflow">if</span>(info-&gt;residuesubmap[i]&gt;=ci-&gt;residues)<span class="keywordflow">goto</span> err_out;
<a name="l00143"></a>00143   }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="keywordflow">return</span> info;
<a name="l00146"></a>00146 
<a name="l00147"></a>00147  err_out:
<a name="l00148"></a>00148   mapping0_free_info(info);
<a name="l00149"></a>00149   <span class="keywordflow">return</span>(NULL);
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="preprocessor">#include &quot;os.h&quot;</span>
<a name="l00153"></a>00153 <span class="preprocessor">#include &quot;lpc.h&quot;</span>
<a name="l00154"></a>00154 <span class="preprocessor">#include &quot;lsp.h&quot;</span>
<a name="l00155"></a>00155 <span class="preprocessor">#include &quot;envelope.h&quot;</span>
<a name="l00156"></a>00156 <span class="preprocessor">#include &quot;mdct.h&quot;</span>
<a name="l00157"></a>00157 <span class="preprocessor">#include &quot;psy.h&quot;</span>
<a name="l00158"></a>00158 <span class="preprocessor">#include &quot;scales.h&quot;</span>
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="preprocessor">#if 0</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">long</span> seq=0;
<a name="l00162"></a>00162 <span class="keyword">static</span> ogg_int64_t total=0;
<a name="l00163"></a>00163 <span class="keyword">static</span> <span class="keywordtype">float</span> FLOOR1_fromdB_LOOKUP[256]={
<a name="l00164"></a>00164   1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F, 
<a name="l00165"></a>00165   1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F, 
<a name="l00166"></a>00166   1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F, 
<a name="l00167"></a>00167   2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F, 
<a name="l00168"></a>00168   2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F, 
<a name="l00169"></a>00169   3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F, 
<a name="l00170"></a>00170   4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F, 
<a name="l00171"></a>00171   6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F, 
<a name="l00172"></a>00172   7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F, 
<a name="l00173"></a>00173   1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F, 
<a name="l00174"></a>00174   1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F, 
<a name="l00175"></a>00175   1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F, 
<a name="l00176"></a>00176   2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F, 
<a name="l00177"></a>00177   2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F, 
<a name="l00178"></a>00178   3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F, 
<a name="l00179"></a>00179   4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F, 
<a name="l00180"></a>00180   5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F, 
<a name="l00181"></a>00181   7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F, 
<a name="l00182"></a>00182   9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F, 
<a name="l00183"></a>00183   1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F, 
<a name="l00184"></a>00184   1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F, 
<a name="l00185"></a>00185   2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F, 
<a name="l00186"></a>00186   2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F, 
<a name="l00187"></a>00187   3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F, 
<a name="l00188"></a>00188   4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F, 
<a name="l00189"></a>00189   5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F, 
<a name="l00190"></a>00190   7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F, 
<a name="l00191"></a>00191   9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F, 
<a name="l00192"></a>00192   0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F, 
<a name="l00193"></a>00193   0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F, 
<a name="l00194"></a>00194   0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F, 
<a name="l00195"></a>00195   0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F, 
<a name="l00196"></a>00196   0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F, 
<a name="l00197"></a>00197   0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F, 
<a name="l00198"></a>00198   0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F, 
<a name="l00199"></a>00199   0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F, 
<a name="l00200"></a>00200   0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F, 
<a name="l00201"></a>00201   0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F, 
<a name="l00202"></a>00202   0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F, 
<a name="l00203"></a>00203   0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F, 
<a name="l00204"></a>00204   0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F, 
<a name="l00205"></a>00205   0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F, 
<a name="l00206"></a>00206   0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F, 
<a name="l00207"></a>00207   0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F, 
<a name="l00208"></a>00208   0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F, 
<a name="l00209"></a>00209   0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F, 
<a name="l00210"></a>00210   0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F, 
<a name="l00211"></a>00211   0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F, 
<a name="l00212"></a>00212   0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F, 
<a name="l00213"></a>00213   0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F, 
<a name="l00214"></a>00214   0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F, 
<a name="l00215"></a>00215   0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F, 
<a name="l00216"></a>00216   0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F, 
<a name="l00217"></a>00217   0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F, 
<a name="l00218"></a>00218   0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F, 
<a name="l00219"></a>00219   0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F, 
<a name="l00220"></a>00220   0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F, 
<a name="l00221"></a>00221   0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F, 
<a name="l00222"></a>00222   0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F, 
<a name="l00223"></a>00223   0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F, 
<a name="l00224"></a>00224   0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F, 
<a name="l00225"></a>00225   0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F, 
<a name="l00226"></a>00226   0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F, 
<a name="l00227"></a>00227   0.82788260F, 0.88168307F, 0.9389798F, 1.F, 
<a name="l00228"></a>00228 };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="preprocessor">#endif </span>
<a name="l00231"></a>00231 <span class="preprocessor"></span>
<a name="l00232"></a>00232 <span class="keyword">extern</span> <span class="keywordtype">int</span> *floor1_fit(<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb,vorbis_look_floor *look,
<a name="l00233"></a>00233                        <span class="keyword">const</span> <span class="keywordtype">float</span> *logmdct,   <span class="comment">/* in */</span>
<a name="l00234"></a>00234                        <span class="keyword">const</span> <span class="keywordtype">float</span> *logmask);
<a name="l00235"></a>00235 <span class="keyword">extern</span> <span class="keywordtype">int</span> *floor1_interpolate_fit(<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb,vorbis_look_floor *look,
<a name="l00236"></a>00236                                    <span class="keywordtype">int</span> *A,<span class="keywordtype">int</span> *B,
<a name="l00237"></a>00237                                    <span class="keywordtype">int</span> del);
<a name="l00238"></a>00238 <span class="keyword">extern</span> <span class="keywordtype">int</span> floor1_encode(<a class="code" href="structoggpack__buffer.html">oggpack_buffer</a> *opb,<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb,
<a name="l00239"></a>00239                          vorbis_look_floor *look,
<a name="l00240"></a>00240                          <span class="keywordtype">int</span> *post,<span class="keywordtype">int</span> *ilogmask);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keywordtype">int</span> mapping0_forward(<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb){
<a name="l00244"></a>00244   <a class="code" href="structvorbis__dsp__state.html">vorbis_dsp_state</a>      *vd=vb-&gt;vd;
<a name="l00245"></a>00245   <a class="code" href="structvorbis__info.html">vorbis_info</a>           *vi=vd-&gt;vi;
<a name="l00246"></a>00246   <a class="code" href="structcodec__setup__info.html">codec_setup_info</a>      *ci=(<a class="code" href="structcodec__setup__info.html">codec_setup_info</a>*)vi-&gt;codec_setup;
<a name="l00247"></a>00247   <a class="code" href="structprivate__state.html">private_state</a>         *b=(<a class="code" href="structprivate__state.html">private_state</a>*)vb-&gt;vd-&gt;backend_state;
<a name="l00248"></a>00248   <a class="code" href="structvorbis__block__internal.html">vorbis_block_internal</a> *vbi=(<a class="code" href="structvorbis__block__internal.html">vorbis_block_internal</a> *)vb-&gt;internal;
<a name="l00249"></a>00249   <span class="keywordtype">int</span>                    n=vb-&gt;pcmend;
<a name="l00250"></a>00250   <span class="keywordtype">int</span> i,j,k;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">//int    *nonzero    = alloca(sizeof(*nonzero)*vi-&gt;channels);//patch</span>
<a name="l00253"></a>00253   <span class="keywordtype">int</span>    *nonzero    = (<span class="keywordtype">int</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(*nonzero)*vi-&gt;channels); <span class="comment">//patch</span>
<a name="l00254"></a>00254   <span class="keywordtype">int</span> *nonzero_cpy = nonzero; <span class="comment">//patch</span>
<a name="l00255"></a>00255   
<a name="l00256"></a>00256   <span class="keywordtype">float</span>  **gmdct     = (<span class="keywordtype">float</span>**)_vorbis_block_alloc(vb,vi-&gt;channels*<span class="keyword">sizeof</span>(*gmdct));
<a name="l00257"></a>00257   <span class="keywordtype">int</span>    **ilogmaskch= (<span class="keywordtype">int</span>**)_vorbis_block_alloc(vb,vi-&gt;channels*<span class="keyword">sizeof</span>(*ilogmaskch));
<a name="l00258"></a>00258   <span class="keywordtype">int</span> ***floor_posts = (<span class="keywordtype">int</span>***)_vorbis_block_alloc(vb,vi-&gt;channels*<span class="keyword">sizeof</span>(*floor_posts));
<a name="l00259"></a>00259   
<a name="l00260"></a>00260   <span class="keywordtype">float</span> global_ampmax=vbi-&gt;ampmax;
<a name="l00261"></a>00261   <span class="comment">//float *local_ampmax=alloca(sizeof(*local_ampmax)*vi-&gt;channels);//patch</span>
<a name="l00262"></a>00262   <span class="keywordtype">float</span> *local_ampmax=(<span class="keywordtype">float</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(*local_ampmax)*vi-&gt;channels);<span class="comment">//patch</span>
<a name="l00263"></a>00263   <span class="keywordtype">float</span> *local_ampmax_cpy = local_ampmax; <span class="comment">//patch</span>
<a name="l00264"></a>00264   
<a name="l00265"></a>00265   <span class="keywordtype">int</span> blocktype=vbi-&gt;blocktype;
<a name="l00266"></a>00266 
<a name="l00267"></a>00267   <span class="keywordtype">int</span> modenumber=vb-&gt;W;
<a name="l00268"></a>00268   <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *info=(<a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a>*)ci-&gt;map_param[modenumber];
<a name="l00269"></a>00269   <a class="code" href="structvorbis__look__psy.html">vorbis_look_psy</a> *psy_look=
<a name="l00270"></a>00270     b-&gt;psy+blocktype+(vb-&gt;W?2:0);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   vb-&gt;mode=modenumber;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00275"></a>00275     <span class="keywordtype">float</span> scale=4.f/n;
<a name="l00276"></a>00276     <span class="keywordtype">float</span> scale_dB;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="keywordtype">float</span> *pcm     =vb-&gt;pcm[i]; 
<a name="l00279"></a>00279     <span class="keywordtype">float</span> *logfft  =pcm;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     gmdct[i]=(<span class="keywordtype">float</span>*)_vorbis_block_alloc(vb,n/2*<span class="keyword">sizeof</span>(**gmdct));
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     scale_dB=todB(&amp;scale) + .345; <span class="comment">/* + .345 is a hack; the original</span>
<a name="l00284"></a>00284 <span class="comment">                                     todB estimation used on IEEE 754</span>
<a name="l00285"></a>00285 <span class="comment">                                     compliant machines had a bug that</span>
<a name="l00286"></a>00286 <span class="comment">                                     returned dB values about a third</span>
<a name="l00287"></a>00287 <span class="comment">                                     of a decibel too high.  The bug</span>
<a name="l00288"></a>00288 <span class="comment">                                     was harmless because tunings</span>
<a name="l00289"></a>00289 <span class="comment">                                     implicitly took that into</span>
<a name="l00290"></a>00290 <span class="comment">                                     account.  However, fixing the bug</span>
<a name="l00291"></a>00291 <span class="comment">                                     in the estimator requires</span>
<a name="l00292"></a>00292 <span class="comment">                                     changing all the tunings as well.</span>
<a name="l00293"></a>00293 <span class="comment">                                     For now, it&#39;s easier to sync</span>
<a name="l00294"></a>00294 <span class="comment">                                     things back up here, and</span>
<a name="l00295"></a>00295 <span class="comment">                                     recalibrate the tunings in the</span>
<a name="l00296"></a>00296 <span class="comment">                                     next major model upgrade. */</span>
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="preprocessor">#if 0</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(vi-&gt;channels==2)
<a name="l00300"></a>00300       <span class="keywordflow">if</span>(i==0)
<a name="l00301"></a>00301         _analysis_output(<span class="stringliteral">&quot;pcmL&quot;</span>,seq,pcm,n,0,0,total-n/2);
<a name="l00302"></a>00302       <span class="keywordflow">else</span>
<a name="l00303"></a>00303         _analysis_output(<span class="stringliteral">&quot;pcmR&quot;</span>,seq,pcm,n,0,0,total-n/2);
<a name="l00304"></a>00304 <span class="preprocessor">#endif</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span>  
<a name="l00306"></a>00306     <span class="comment">/* window the PCM data */</span>
<a name="l00307"></a>00307     _vorbis_apply_window(pcm,b-&gt;window,ci-&gt;blocksizes,vb-&gt;lW,vb-&gt;W,vb-&gt;nW);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="preprocessor">#if 0</span>
<a name="l00310"></a>00310 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(vi-&gt;channels==2)
<a name="l00311"></a>00311       <span class="keywordflow">if</span>(i==0)
<a name="l00312"></a>00312         _analysis_output(<span class="stringliteral">&quot;windowedL&quot;</span>,seq,pcm,n,0,0,total-n/2);
<a name="l00313"></a>00313       <span class="keywordflow">else</span>
<a name="l00314"></a>00314         _analysis_output(<span class="stringliteral">&quot;windowedR&quot;</span>,seq,pcm,n,0,0,total-n/2);
<a name="l00315"></a>00315 <span class="preprocessor">#endif</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>
<a name="l00317"></a>00317     <span class="comment">/* transform the PCM data */</span>
<a name="l00318"></a>00318     <span class="comment">/* only MDCT right now.... */</span>
<a name="l00319"></a>00319     mdct_forward((<a class="code" href="structmdct__lookup.html">mdct_lookup</a>*)b-&gt;transform[vb-&gt;W][0],pcm,gmdct[i]);
<a name="l00320"></a>00320     
<a name="l00321"></a>00321     <span class="comment">/* FFT yields more accurate tonal estimation (not phase sensitive) */</span>
<a name="l00322"></a>00322     drft_forward(&amp;b-&gt;fft_look[vb-&gt;W],pcm);
<a name="l00323"></a>00323     logfft[0]=scale_dB+todB(pcm)  + .345; <span class="comment">/* + .345 is a hack; the</span>
<a name="l00324"></a>00324 <span class="comment">                                     original todB estimation used on</span>
<a name="l00325"></a>00325 <span class="comment">                                     IEEE 754 compliant machines had a</span>
<a name="l00326"></a>00326 <span class="comment">                                     bug that returned dB values about</span>
<a name="l00327"></a>00327 <span class="comment">                                     a third of a decibel too high.</span>
<a name="l00328"></a>00328 <span class="comment">                                     The bug was harmless because</span>
<a name="l00329"></a>00329 <span class="comment">                                     tunings implicitly took that into</span>
<a name="l00330"></a>00330 <span class="comment">                                     account.  However, fixing the bug</span>
<a name="l00331"></a>00331 <span class="comment">                                     in the estimator requires</span>
<a name="l00332"></a>00332 <span class="comment">                                     changing all the tunings as well.</span>
<a name="l00333"></a>00333 <span class="comment">                                     For now, it&#39;s easier to sync</span>
<a name="l00334"></a>00334 <span class="comment">                                     things back up here, and</span>
<a name="l00335"></a>00335 <span class="comment">                                     recalibrate the tunings in the</span>
<a name="l00336"></a>00336 <span class="comment">                                     next major model upgrade. */</span>
<a name="l00337"></a>00337     local_ampmax[i]=logfft[0];
<a name="l00338"></a>00338     <span class="keywordflow">for</span>(j=1;j&lt;n-1;j+=2){
<a name="l00339"></a>00339       <span class="keywordtype">float</span> temp=pcm[j]*pcm[j]+pcm[j+1]*pcm[j+1];
<a name="l00340"></a>00340       temp=logfft[(j+1)&gt;&gt;1]=scale_dB+.5f*todB(&amp;temp)  + .345; <span class="comment">/* +</span>
<a name="l00341"></a>00341 <span class="comment">                                     .345 is a hack; the original todB</span>
<a name="l00342"></a>00342 <span class="comment">                                     estimation used on IEEE 754</span>
<a name="l00343"></a>00343 <span class="comment">                                     compliant machines had a bug that</span>
<a name="l00344"></a>00344 <span class="comment">                                     returned dB values about a third</span>
<a name="l00345"></a>00345 <span class="comment">                                     of a decibel too high.  The bug</span>
<a name="l00346"></a>00346 <span class="comment">                                     was harmless because tunings</span>
<a name="l00347"></a>00347 <span class="comment">                                     implicitly took that into</span>
<a name="l00348"></a>00348 <span class="comment">                                     account.  However, fixing the bug</span>
<a name="l00349"></a>00349 <span class="comment">                                     in the estimator requires</span>
<a name="l00350"></a>00350 <span class="comment">                                     changing all the tunings as well.</span>
<a name="l00351"></a>00351 <span class="comment">                                     For now, it&#39;s easier to sync</span>
<a name="l00352"></a>00352 <span class="comment">                                     things back up here, and</span>
<a name="l00353"></a>00353 <span class="comment">                                     recalibrate the tunings in the</span>
<a name="l00354"></a>00354 <span class="comment">                                     next major model upgrade. */</span>
<a name="l00355"></a>00355       <span class="keywordflow">if</span>(temp&gt;local_ampmax[i])local_ampmax[i]=temp;
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="keywordflow">if</span>(local_ampmax[i]&gt;0.f)local_ampmax[i]=0.f;
<a name="l00359"></a>00359     <span class="keywordflow">if</span>(local_ampmax[i]&gt;global_ampmax)global_ampmax=local_ampmax[i];
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="preprocessor">#if 0</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00363"></a>00363       <span class="keywordflow">if</span>(i==0){
<a name="l00364"></a>00364         _analysis_output(<span class="stringliteral">&quot;fftL&quot;</span>,seq,logfft,n/2,1,0,0);
<a name="l00365"></a>00365       }<span class="keywordflow">else</span>{
<a name="l00366"></a>00366         _analysis_output(<span class="stringliteral">&quot;fftR&quot;</span>,seq,logfft,n/2,1,0,0);
<a name="l00367"></a>00367       }
<a name="l00368"></a>00368     }
<a name="l00369"></a>00369 <span class="preprocessor">#endif</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>
<a name="l00371"></a>00371   }
<a name="l00372"></a>00372   
<a name="l00373"></a>00373   {
<a name="l00374"></a>00374     <span class="keywordtype">float</span>   *noise        = (<span class="keywordtype">float</span>*)_vorbis_block_alloc(vb,n/2*<span class="keyword">sizeof</span>(*noise));
<a name="l00375"></a>00375     <span class="keywordtype">float</span>   *tone         = (<span class="keywordtype">float</span>*)_vorbis_block_alloc(vb,n/2*<span class="keyword">sizeof</span>(*tone));
<a name="l00376"></a>00376     
<a name="l00377"></a>00377     <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00378"></a>00378       <span class="comment">/* the encoder setup assumes that all the modes used by any</span>
<a name="l00379"></a>00379 <span class="comment">         specific bitrate tweaking use the same floor */</span>
<a name="l00380"></a>00380       
<a name="l00381"></a>00381       <span class="keywordtype">int</span> submap=info-&gt;chmuxlist[i];
<a name="l00382"></a>00382       
<a name="l00383"></a>00383       <span class="comment">/* the following makes things clearer to *me* anyway */</span>
<a name="l00384"></a>00384       <span class="keywordtype">float</span> *mdct    =gmdct[i];
<a name="l00385"></a>00385       <span class="keywordtype">float</span> *logfft  =vb-&gt;pcm[i];
<a name="l00386"></a>00386       
<a name="l00387"></a>00387       <span class="keywordtype">float</span> *logmdct =logfft+n/2;
<a name="l00388"></a>00388       <span class="keywordtype">float</span> *logmask =logfft;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390       vb-&gt;mode=modenumber;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392       floor_posts[i]=(<span class="keywordtype">int</span>**)_vorbis_block_alloc(vb,PACKETBLOBS*<span class="keyword">sizeof</span>(**floor_posts));
<a name="l00393"></a>00393       memset(floor_posts[i],0,<span class="keyword">sizeof</span>(**floor_posts)*PACKETBLOBS);
<a name="l00394"></a>00394       
<a name="l00395"></a>00395       <span class="keywordflow">for</span>(j=0;j&lt;n/2;j++)
<a name="l00396"></a>00396         logmdct[j]=todB(mdct+j)  + .345; <span class="comment">/* + .345 is a hack; the original</span>
<a name="l00397"></a>00397 <span class="comment">                                     todB estimation used on IEEE 754</span>
<a name="l00398"></a>00398 <span class="comment">                                     compliant machines had a bug that</span>
<a name="l00399"></a>00399 <span class="comment">                                     returned dB values about a third</span>
<a name="l00400"></a>00400 <span class="comment">                                     of a decibel too high.  The bug</span>
<a name="l00401"></a>00401 <span class="comment">                                     was harmless because tunings</span>
<a name="l00402"></a>00402 <span class="comment">                                     implicitly took that into</span>
<a name="l00403"></a>00403 <span class="comment">                                     account.  However, fixing the bug</span>
<a name="l00404"></a>00404 <span class="comment">                                     in the estimator requires</span>
<a name="l00405"></a>00405 <span class="comment">                                     changing all the tunings as well.</span>
<a name="l00406"></a>00406 <span class="comment">                                     For now, it&#39;s easier to sync</span>
<a name="l00407"></a>00407 <span class="comment">                                     things back up here, and</span>
<a name="l00408"></a>00408 <span class="comment">                                     recalibrate the tunings in the</span>
<a name="l00409"></a>00409 <span class="comment">                                     next major model upgrade. */</span>
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="preprocessor">#if 0</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00413"></a>00413         <span class="keywordflow">if</span>(i==0)
<a name="l00414"></a>00414           _analysis_output(<span class="stringliteral">&quot;mdctL&quot;</span>,seq,logmdct,n/2,1,0,0);
<a name="l00415"></a>00415         <span class="keywordflow">else</span>
<a name="l00416"></a>00416           _analysis_output(<span class="stringliteral">&quot;mdctR&quot;</span>,seq,logmdct,n/2,1,0,0);
<a name="l00417"></a>00417       }<span class="keywordflow">else</span>{
<a name="l00418"></a>00418         _analysis_output(<span class="stringliteral">&quot;mdct&quot;</span>,seq,logmdct,n/2,1,0,0);
<a name="l00419"></a>00419       }
<a name="l00420"></a>00420 <span class="preprocessor">#endif </span>
<a name="l00421"></a>00421 <span class="preprocessor"></span>      
<a name="l00422"></a>00422       <span class="comment">/* first step; noise masking.  Not only does &#39;noise masking&#39;</span>
<a name="l00423"></a>00423 <span class="comment">         give us curves from which we can decide how much resolution</span>
<a name="l00424"></a>00424 <span class="comment">         to give noise parts of the spectrum, it also implicitly hands</span>
<a name="l00425"></a>00425 <span class="comment">         us a tonality estimate (the larger the value in the</span>
<a name="l00426"></a>00426 <span class="comment">         &#39;noise_depth&#39; vector, the more tonal that area is) */</span>
<a name="l00427"></a>00427 
<a name="l00428"></a>00428       _vp_noisemask(psy_look,
<a name="l00429"></a>00429                     logmdct,
<a name="l00430"></a>00430                     noise); <span class="comment">/* noise does not have by-frequency offset</span>
<a name="l00431"></a>00431 <span class="comment">                               bias applied yet */</span>
<a name="l00432"></a>00432 <span class="preprocessor">#if 0</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00434"></a>00434         <span class="keywordflow">if</span>(i==0)
<a name="l00435"></a>00435           _analysis_output(<span class="stringliteral">&quot;noiseL&quot;</span>,seq,noise,n/2,1,0,0);
<a name="l00436"></a>00436         <span class="keywordflow">else</span>
<a name="l00437"></a>00437           _analysis_output(<span class="stringliteral">&quot;noiseR&quot;</span>,seq,noise,n/2,1,0,0);
<a name="l00438"></a>00438       }
<a name="l00439"></a>00439 <span class="preprocessor">#endif</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>
<a name="l00441"></a>00441       <span class="comment">/* second step: &#39;all the other crap&#39;; all the stuff that isn&#39;t</span>
<a name="l00442"></a>00442 <span class="comment">         computed/fit for bitrate management goes in the second psy</span>
<a name="l00443"></a>00443 <span class="comment">         vector.  This includes tone masking, peak limiting and ATH */</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445       _vp_tonemask(psy_look,
<a name="l00446"></a>00446                    logfft,
<a name="l00447"></a>00447                    tone,
<a name="l00448"></a>00448                    global_ampmax,
<a name="l00449"></a>00449                    local_ampmax[i]);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="preprocessor">#if 0</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00453"></a>00453         <span class="keywordflow">if</span>(i==0)
<a name="l00454"></a>00454           _analysis_output(<span class="stringliteral">&quot;toneL&quot;</span>,seq,tone,n/2,1,0,0);
<a name="l00455"></a>00455         <span class="keywordflow">else</span>
<a name="l00456"></a>00456           _analysis_output(<span class="stringliteral">&quot;toneR&quot;</span>,seq,tone,n/2,1,0,0);
<a name="l00457"></a>00457       }
<a name="l00458"></a>00458 <span class="preprocessor">#endif</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span>
<a name="l00460"></a>00460       <span class="comment">/* third step; we offset the noise vectors, overlay tone</span>
<a name="l00461"></a>00461 <span class="comment">         masking.  We then do a floor1-specific line fit.  If we&#39;re</span>
<a name="l00462"></a>00462 <span class="comment">         performing bitrate management, the line fit is performed</span>
<a name="l00463"></a>00463 <span class="comment">         multiple times for up/down tweakage on demand. */</span>
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="preprocessor">#if 0</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span>      {
<a name="l00467"></a>00467       <span class="keywordtype">float</span> aotuv[psy_look-&gt;n];
<a name="l00468"></a>00468 <span class="preprocessor">#endif</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span>
<a name="l00470"></a>00470         _vp_offset_and_mix(psy_look,
<a name="l00471"></a>00471                            noise,
<a name="l00472"></a>00472                            tone,
<a name="l00473"></a>00473                            1,
<a name="l00474"></a>00474                            logmask,
<a name="l00475"></a>00475                            mdct,
<a name="l00476"></a>00476                            logmdct);
<a name="l00477"></a>00477         
<a name="l00478"></a>00478 <span class="preprocessor">#if 0</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00480"></a>00480           <span class="keywordflow">if</span>(i==0)
<a name="l00481"></a>00481             _analysis_output(<span class="stringliteral">&quot;aotuvM1_L&quot;</span>,seq,aotuv,psy_look-&gt;n,1,1,0);
<a name="l00482"></a>00482           <span class="keywordflow">else</span>
<a name="l00483"></a>00483             _analysis_output(<span class="stringliteral">&quot;aotuvM1_R&quot;</span>,seq,aotuv,psy_look-&gt;n,1,1,0);
<a name="l00484"></a>00484         }
<a name="l00485"></a>00485       }
<a name="l00486"></a>00486 <span class="preprocessor">#endif</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="preprocessor">#if 0</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00491"></a>00491         <span class="keywordflow">if</span>(i==0)
<a name="l00492"></a>00492           _analysis_output(<span class="stringliteral">&quot;mask1L&quot;</span>,seq,logmask,n/2,1,0,0);
<a name="l00493"></a>00493         <span class="keywordflow">else</span>
<a name="l00494"></a>00494           _analysis_output(<span class="stringliteral">&quot;mask1R&quot;</span>,seq,logmask,n/2,1,0,0);
<a name="l00495"></a>00495       }
<a name="l00496"></a>00496 <span class="preprocessor">#endif</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>
<a name="l00498"></a>00498       <span class="comment">/* this algorithm is hardwired to floor 1 for now; abort out if</span>
<a name="l00499"></a>00499 <span class="comment">         we&#39;re *not* floor1.  This won&#39;t happen unless someone has</span>
<a name="l00500"></a>00500 <span class="comment">         broken the encode setup lib.  Guard it anyway. */</span>
<a name="l00501"></a>00501       <span class="keywordflow">if</span>(ci-&gt;floor_type[info-&gt;floorsubmap[submap]]!=1){
<a name="l00502"></a>00502                 free(nonzero_cpy); <span class="comment">//patch              </span>
<a name="l00503"></a>00503                 free(local_ampmax_cpy);<span class="comment">//patch</span>
<a name="l00504"></a>00504         <span class="keywordflow">return</span>(-1);     
<a name="l00505"></a>00505       }
<a name="l00506"></a>00506       
<a name="l00507"></a>00507 
<a name="l00508"></a>00508       floor_posts[i][PACKETBLOBS/2]=
<a name="l00509"></a>00509         floor1_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00510"></a>00510                    logmdct,
<a name="l00511"></a>00511                    logmask);
<a name="l00512"></a>00512       
<a name="l00513"></a>00513       <span class="comment">/* are we managing bitrate?  If so, perform two more fits for</span>
<a name="l00514"></a>00514 <span class="comment">         later rate tweaking (fits represent hi/lo) */</span>
<a name="l00515"></a>00515       <span class="keywordflow">if</span>(vorbis_bitrate_managed(vb) &amp;&amp; floor_posts[i][PACKETBLOBS/2]){
<a name="l00516"></a>00516         <span class="comment">/* higher rate by way of lower noise curve */</span>
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         _vp_offset_and_mix(psy_look,
<a name="l00519"></a>00519                            noise,
<a name="l00520"></a>00520                            tone,
<a name="l00521"></a>00521                            2,
<a name="l00522"></a>00522                            logmask,
<a name="l00523"></a>00523                            mdct,
<a name="l00524"></a>00524                            logmdct);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="preprocessor">#if 0</span>
<a name="l00527"></a>00527 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(vi-&gt;channels==2){
<a name="l00528"></a>00528           <span class="keywordflow">if</span>(i==0)
<a name="l00529"></a>00529             _analysis_output(<span class="stringliteral">&quot;mask2L&quot;</span>,seq,logmask,n/2,1,0,0);
<a name="l00530"></a>00530           <span class="keywordflow">else</span>
<a name="l00531"></a>00531             _analysis_output(<span class="stringliteral">&quot;mask2R&quot;</span>,seq,logmask,n/2,1,0,0);
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533 <span class="preprocessor">#endif</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span>        
<a name="l00535"></a>00535         floor_posts[i][PACKETBLOBS-1]=
<a name="l00536"></a>00536           floor1_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00537"></a>00537                      logmdct,
<a name="l00538"></a>00538                      logmask);
<a name="l00539"></a>00539       
<a name="l00540"></a>00540         <span class="comment">/* lower rate by way of higher noise curve */</span>
<a name="l00541"></a>00541         _vp_offset_and_mix(psy_look,
<a name="l00542"></a>00542                            noise,
<a name="l00543"></a>00543                            tone,
<a name="l00544"></a>00544                            0,
<a name="l00545"></a>00545                            logmask,
<a name="l00546"></a>00546                            mdct,
<a name="l00547"></a>00547                            logmdct);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="preprocessor">#if 0</span>
<a name="l00550"></a>00550 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(vi-&gt;channels==2)
<a name="l00551"></a>00551           <span class="keywordflow">if</span>(i==0)
<a name="l00552"></a>00552             _analysis_output(<span class="stringliteral">&quot;mask0L&quot;</span>,seq,logmask,n/2,1,0,0);
<a name="l00553"></a>00553           <span class="keywordflow">else</span>
<a name="l00554"></a>00554             _analysis_output(<span class="stringliteral">&quot;mask0R&quot;</span>,seq,logmask,n/2,1,0,0);
<a name="l00555"></a>00555 <span class="preprocessor">#endif</span>
<a name="l00556"></a>00556 <span class="preprocessor"></span>
<a name="l00557"></a>00557         floor_posts[i][0]=
<a name="l00558"></a>00558           floor1_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00559"></a>00559                      logmdct,
<a name="l00560"></a>00560                      logmask);
<a name="l00561"></a>00561         
<a name="l00562"></a>00562         <span class="comment">/* we also interpolate a range of intermediate curves for</span>
<a name="l00563"></a>00563 <span class="comment">           intermediate rates */</span>
<a name="l00564"></a>00564         <span class="keywordflow">for</span>(k=1;k&lt;PACKETBLOBS/2;k++)
<a name="l00565"></a>00565           floor_posts[i][k]=
<a name="l00566"></a>00566             floor1_interpolate_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00567"></a>00567                                    floor_posts[i][0],
<a name="l00568"></a>00568                                    floor_posts[i][PACKETBLOBS/2],
<a name="l00569"></a>00569                                    k*65536/(PACKETBLOBS/2));
<a name="l00570"></a>00570         <span class="keywordflow">for</span>(k=PACKETBLOBS/2+1;k&lt;PACKETBLOBS-1;k++)
<a name="l00571"></a>00571           floor_posts[i][k]=
<a name="l00572"></a>00572             floor1_interpolate_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00573"></a>00573                                    floor_posts[i][PACKETBLOBS/2],
<a name="l00574"></a>00574                                    floor_posts[i][PACKETBLOBS-1],
<a name="l00575"></a>00575                                    (k-PACKETBLOBS/2)*65536/(PACKETBLOBS/2));
<a name="l00576"></a>00576       }
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578   }
<a name="l00579"></a>00579   vbi-&gt;ampmax=global_ampmax;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581   <span class="comment">/*</span>
<a name="l00582"></a>00582 <span class="comment">    the next phases are performed once for vbr-only and PACKETBLOB</span>
<a name="l00583"></a>00583 <span class="comment">    times for bitrate managed modes.</span>
<a name="l00584"></a>00584 <span class="comment">    </span>
<a name="l00585"></a>00585 <span class="comment">    1) encode actual mode being used</span>
<a name="l00586"></a>00586 <span class="comment">    2) encode the floor for each channel, compute coded mask curve/res</span>
<a name="l00587"></a>00587 <span class="comment">    3) normalize and couple.</span>
<a name="l00588"></a>00588 <span class="comment">    4) encode residue</span>
<a name="l00589"></a>00589 <span class="comment">    5) save packet bytes to the packetblob vector</span>
<a name="l00590"></a>00590 <span class="comment">    </span>
<a name="l00591"></a>00591 <span class="comment">  */</span>
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="comment">/* iterate over the many masking curve fits we&#39;ve created */</span>
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   {
<a name="l00596"></a>00596     <span class="comment">//-----patch</span>
<a name="l00597"></a>00597     <span class="comment">//float **res_bundle=alloca(sizeof(*res_bundle)*vi-&gt;channels);</span>
<a name="l00598"></a>00598     <span class="comment">//float **couple_bundle=alloca(sizeof(*couple_bundle)*vi-&gt;channels);</span>
<a name="l00599"></a>00599     <span class="comment">//int *zerobundle=alloca(sizeof(*zerobundle)*vi-&gt;channels);</span>
<a name="l00600"></a>00600     <span class="comment">//int **sortindex=alloca(sizeof(*sortindex)*vi-&gt;channels);</span>
<a name="l00601"></a>00601     
<a name="l00602"></a>00602     <span class="keywordtype">float</span> **res_bundle=(<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*res_bundle)*vi-&gt;channels);
<a name="l00603"></a>00603     <span class="keywordtype">float</span> **couple_bundle=(<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*couple_bundle)*vi-&gt;channels);
<a name="l00604"></a>00604     <span class="keywordtype">int</span> *zerobundle=(<span class="keywordtype">int</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(*zerobundle)*vi-&gt;channels);
<a name="l00605"></a>00605     <span class="keywordtype">int</span> **sortindex=(<span class="keywordtype">int</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*sortindex)*vi-&gt;channels);
<a name="l00606"></a>00606     
<a name="l00607"></a>00607     <span class="keywordtype">float</span> **res_bundle_cpy = res_bundle;
<a name="l00608"></a>00608     <span class="keywordtype">float</span> **couple_bundle_cpy = couple_bundle;
<a name="l00609"></a>00609     <span class="keywordtype">int</span> *zerobundle_cpy = zerobundle;
<a name="l00610"></a>00610     <span class="keywordtype">int</span> **sortindex_cpy = sortindex;
<a name="l00611"></a>00611     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> sortindex_elements = 0;
<a name="l00612"></a>00612     <span class="comment">//-------------patch----</span>
<a name="l00613"></a>00613     
<a name="l00614"></a>00614     
<a name="l00615"></a>00615     <span class="keywordtype">float</span> **mag_memo = NULL;
<a name="l00616"></a>00616     <span class="keywordtype">int</span> **mag_sort = NULL;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618     <span class="keywordflow">if</span>(info-&gt;coupling_steps){
<a name="l00619"></a>00619       mag_memo=_vp_quantize_couple_memo(vb,
<a name="l00620"></a>00620                                         &amp;ci-&gt;psy_g_param,
<a name="l00621"></a>00621                                         psy_look,
<a name="l00622"></a>00622                                         info,
<a name="l00623"></a>00623                                         gmdct);    
<a name="l00624"></a>00624       
<a name="l00625"></a>00625       mag_sort=_vp_quantize_couple_sort(vb,
<a name="l00626"></a>00626                                         psy_look,
<a name="l00627"></a>00627                                         info,
<a name="l00628"></a>00628                                         mag_memo);    
<a name="l00629"></a>00629 
<a name="l00630"></a>00630       hf_reduction(&amp;ci-&gt;psy_g_param,
<a name="l00631"></a>00631                    psy_look,
<a name="l00632"></a>00632                    info,
<a name="l00633"></a>00633                    mag_memo);
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636     memset(sortindex,0,<span class="keyword">sizeof</span>(*sortindex)*vi-&gt;channels);
<a name="l00637"></a>00637     <span class="keywordflow">if</span>(psy_look-&gt;vi-&gt;normal_channel_p){
<a name="l00638"></a>00638     sortindex_elements = vi-&gt;channels; <span class="comment">//patch</span>
<a name="l00639"></a>00639       <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00640"></a>00640         <span class="keywordtype">float</span> *mdct    =gmdct[i];
<a name="l00641"></a>00641         sortindex[i]= (<span class="keywordtype">int</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(**sortindex)*n/2);<span class="comment">//alloca(sizeof(**sortindex)*n/2); //patch</span>
<a name="l00642"></a>00642         _vp_noise_normalize_sort(psy_look,mdct,sortindex[i]);
<a name="l00643"></a>00643       }
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="keywordflow">for</span>(k=(vorbis_bitrate_managed(vb)?0:PACKETBLOBS/2);
<a name="l00647"></a>00647         k&lt;=(vorbis_bitrate_managed(vb)?PACKETBLOBS-1:PACKETBLOBS/2);
<a name="l00648"></a>00648         k++){
<a name="l00649"></a>00649       <a class="code" href="structoggpack__buffer.html">oggpack_buffer</a> *opb=vbi-&gt;packetblob[k];
<a name="l00650"></a>00650 
<a name="l00651"></a>00651       <span class="comment">/* start out our new packet blob with packet type and mode */</span>
<a name="l00652"></a>00652       <span class="comment">/* Encode the packet type */</span>
<a name="l00653"></a>00653       oggpack_write(opb,0,1);
<a name="l00654"></a>00654       <span class="comment">/* Encode the modenumber */</span>
<a name="l00655"></a>00655       <span class="comment">/* Encode frame mode, pre,post windowsize, then dispatch */</span>
<a name="l00656"></a>00656       oggpack_write(opb,modenumber,b-&gt;modebits);
<a name="l00657"></a>00657       <span class="keywordflow">if</span>(vb-&gt;W){
<a name="l00658"></a>00658         oggpack_write(opb,vb-&gt;lW,1);
<a name="l00659"></a>00659         oggpack_write(opb,vb-&gt;nW,1);
<a name="l00660"></a>00660       }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662       <span class="comment">/* encode floor, compute masking curve, sep out residue */</span>
<a name="l00663"></a>00663       <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00664"></a>00664         <span class="keywordtype">int</span> submap=info-&gt;chmuxlist[i];
<a name="l00665"></a>00665         <span class="keywordtype">float</span> *mdct    =gmdct[i];
<a name="l00666"></a>00666         <span class="keywordtype">float</span> *res     =vb-&gt;pcm[i];
<a name="l00667"></a>00667         <span class="keywordtype">int</span>   *ilogmask=ilogmaskch[i]=(<span class="keywordtype">int</span>*)
<a name="l00668"></a>00668           _vorbis_block_alloc(vb,n/2*<span class="keyword">sizeof</span>(**gmdct));
<a name="l00669"></a>00669       
<a name="l00670"></a>00670         nonzero[i]=floor1_encode(opb,vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00671"></a>00671                                  floor_posts[i][k],
<a name="l00672"></a>00672                                  ilogmask);
<a name="l00673"></a>00673 <span class="preprocessor">#if 0</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>        {
<a name="l00675"></a>00675           <span class="keywordtype">char</span> buf[80];
<a name="l00676"></a>00676           sprintf(buf,<span class="stringliteral">&quot;maskI%c%d&quot;</span>,i?<span class="charliteral">&#39;R&#39;</span>:<span class="charliteral">&#39;L&#39;</span>,k);
<a name="l00677"></a>00677           <span class="keywordtype">float</span> work[n/2];
<a name="l00678"></a>00678           <span class="keywordflow">for</span>(j=0;j&lt;n/2;j++)
<a name="l00679"></a>00679             work[j]=FLOOR1_fromdB_LOOKUP[ilogmask[j]];
<a name="l00680"></a>00680           _analysis_output(buf,seq,work,n/2,1,1,0);
<a name="l00681"></a>00681         }
<a name="l00682"></a>00682 <span class="preprocessor">#endif</span>
<a name="l00683"></a>00683 <span class="preprocessor"></span>        _vp_remove_floor(psy_look,
<a name="l00684"></a>00684                          mdct,
<a name="l00685"></a>00685                          ilogmask,
<a name="l00686"></a>00686                          res,
<a name="l00687"></a>00687                          ci-&gt;psy_g_param.sliding_lowpass[vb-&gt;W][k]);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         _vp_noise_normalize(psy_look,res,res+n/2,sortindex[i]);
<a name="l00690"></a>00690 
<a name="l00691"></a>00691         
<a name="l00692"></a>00692 <span class="preprocessor">#if 0</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>        {
<a name="l00694"></a>00694           <span class="keywordtype">char</span> buf[80];
<a name="l00695"></a>00695           <span class="keywordtype">float</span> work[n/2];
<a name="l00696"></a>00696           <span class="keywordflow">for</span>(j=0;j&lt;n/2;j++)
<a name="l00697"></a>00697             work[j]=FLOOR1_fromdB_LOOKUP[ilogmask[j]]*(res+n/2)[j];
<a name="l00698"></a>00698           sprintf(buf,<span class="stringliteral">&quot;resI%c%d&quot;</span>,i?<span class="charliteral">&#39;R&#39;</span>:<span class="charliteral">&#39;L&#39;</span>,k);
<a name="l00699"></a>00699           _analysis_output(buf,seq,work,n/2,1,1,0);
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         }
<a name="l00702"></a>00702 <span class="preprocessor">#endif</span>
<a name="l00703"></a>00703 <span class="preprocessor"></span>      }
<a name="l00704"></a>00704       
<a name="l00705"></a>00705       <span class="comment">/* our iteration is now based on masking curve, not prequant and</span>
<a name="l00706"></a>00706 <span class="comment">         coupling.  Only one prequant/coupling step */</span>
<a name="l00707"></a>00707       
<a name="l00708"></a>00708       <span class="comment">/* quantize/couple */</span>
<a name="l00709"></a>00709       <span class="comment">/* incomplete implementation that assumes the tree is all depth</span>
<a name="l00710"></a>00710 <span class="comment">         one, or no tree at all */</span>
<a name="l00711"></a>00711       <span class="keywordflow">if</span>(info-&gt;coupling_steps){
<a name="l00712"></a>00712         _vp_couple(k,
<a name="l00713"></a>00713                    &amp;ci-&gt;psy_g_param,
<a name="l00714"></a>00714                    psy_look,
<a name="l00715"></a>00715                    info,
<a name="l00716"></a>00716                    vb-&gt;pcm,
<a name="l00717"></a>00717                    mag_memo,
<a name="l00718"></a>00718                    mag_sort,
<a name="l00719"></a>00719                    ilogmaskch,
<a name="l00720"></a>00720                    nonzero,
<a name="l00721"></a>00721                    ci-&gt;psy_g_param.sliding_lowpass[vb-&gt;W][k]);
<a name="l00722"></a>00722       }
<a name="l00723"></a>00723       
<a name="l00724"></a>00724       <span class="comment">/* classify and encode by submap */</span>
<a name="l00725"></a>00725       <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;submaps;i++){
<a name="l00726"></a>00726         <span class="keywordtype">int</span> ch_in_bundle=0;
<a name="l00727"></a>00727         <span class="keywordtype">long</span> **classifications;
<a name="l00728"></a>00728         <span class="keywordtype">int</span> resnum=info-&gt;residuesubmap[i];
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="keywordflow">for</span>(j=0;j&lt;vi-&gt;channels;j++){
<a name="l00731"></a>00731           <span class="keywordflow">if</span>(info-&gt;chmuxlist[j]==i){
<a name="l00732"></a>00732             zerobundle[ch_in_bundle]=0;
<a name="l00733"></a>00733             <span class="keywordflow">if</span>(nonzero[j])zerobundle[ch_in_bundle]=1;
<a name="l00734"></a>00734             res_bundle[ch_in_bundle]=vb-&gt;pcm[j];
<a name="l00735"></a>00735             couple_bundle[ch_in_bundle++]=vb-&gt;pcm[j]+n/2;
<a name="l00736"></a>00736           }
<a name="l00737"></a>00737         }
<a name="l00738"></a>00738         
<a name="l00739"></a>00739         classifications=_residue_P[ci-&gt;residue_type[resnum]]-&gt;
<a name="l00740"></a>00740           fpclass(vb,b-&gt;residue[resnum],couple_bundle,zerobundle,ch_in_bundle);
<a name="l00741"></a>00741         
<a name="l00742"></a>00742         _residue_P[ci-&gt;residue_type[resnum]]-&gt;
<a name="l00743"></a>00743           forward(opb,vb,b-&gt;residue[resnum],
<a name="l00744"></a>00744                   couple_bundle,NULL,zerobundle,ch_in_bundle,classifications);
<a name="l00745"></a>00745       }
<a name="l00746"></a>00746       
<a name="l00747"></a>00747       <span class="comment">/* ok, done encoding.  Next protopacket. */</span>
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749         
<a name="l00750"></a>00750         <span class="comment">//-----patch</span>
<a name="l00751"></a>00751         free(res_bundle_cpy);
<a name="l00752"></a>00752         free(couple_bundle_cpy);
<a name="l00753"></a>00753         free(zerobundle_cpy); 
<a name="l00754"></a>00754         
<a name="l00755"></a>00755         <span class="keywordflow">for</span>(i=0; i &lt; sortindex_elements; i++){
<a name="l00756"></a>00756                 free(sortindex[i]);             
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758         free(sortindex_cpy);   
<a name="l00759"></a>00759         <span class="comment">//--------patch</span>
<a name="l00760"></a>00760   }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="preprocessor">#if 0</span>
<a name="l00763"></a>00763 <span class="preprocessor"></span>  seq++;
<a name="l00764"></a>00764   total+=ci-&gt;blocksizes[vb-&gt;W]/4+ci-&gt;blocksizes[vb-&gt;nW]/4;
<a name="l00765"></a>00765 <span class="preprocessor">#endif</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span>  free(nonzero_cpy); <span class="comment">//patch</span>
<a name="l00767"></a>00767   free(local_ampmax_cpy); <span class="comment">//patch</span>
<a name="l00768"></a>00768   <span class="keywordflow">return</span>(0);
<a name="l00769"></a>00769 }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="keyword">static</span> <span class="keywordtype">int</span> mapping0_inverse(<a class="code" href="structvorbis__block.html">vorbis_block</a> *vb,vorbis_info_mapping *l){
<a name="l00772"></a>00772   <a class="code" href="structvorbis__dsp__state.html">vorbis_dsp_state</a>     *vd=vb-&gt;vd;
<a name="l00773"></a>00773   <a class="code" href="structvorbis__info.html">vorbis_info</a>          *vi=vd-&gt;vi;
<a name="l00774"></a>00774   <a class="code" href="structcodec__setup__info.html">codec_setup_info</a>     *ci=(<a class="code" href="structcodec__setup__info.html">codec_setup_info</a>*)vi-&gt;codec_setup;
<a name="l00775"></a>00775   <a class="code" href="structprivate__state.html">private_state</a>        *b=(<a class="code" href="structprivate__state.html">private_state</a>*)vd-&gt;backend_state;
<a name="l00776"></a>00776   <a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *info=(<a class="code" href="structvorbis__info__mapping0.html">vorbis_info_mapping0</a> *)l;
<a name="l00777"></a>00777   <span class="comment">//int hs=ci-&gt;halfrate_flag; </span>
<a name="l00778"></a>00778 
<a name="l00779"></a>00779   <span class="keywordtype">int</span>                   i,j;
<a name="l00780"></a>00780   <span class="keywordtype">long</span>                  n=vb-&gt;pcmend=ci-&gt;blocksizes[vb-&gt;W];
<a name="l00781"></a>00781 
<a name="l00782"></a>00782   <span class="comment">//---------patch      </span>
<a name="l00783"></a>00783   <span class="comment">//float **pcmbundle=alloca(sizeof(*pcmbundle)*vi-&gt;channels);</span>
<a name="l00784"></a>00784   <span class="comment">//int    *zerobundle=alloca(sizeof(*zerobundle)*vi-&gt;channels);</span>
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   <span class="comment">//int   *nonzero  =alloca(sizeof(*nonzero)*vi-&gt;channels);</span>
<a name="l00787"></a>00787   <span class="comment">//void **floormemo=alloca(sizeof(*floormemo)*vi-&gt;channels);</span>
<a name="l00788"></a>00788   
<a name="l00789"></a>00789   <span class="keywordtype">float</span> **pcmbundle=(<span class="keywordtype">float</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*pcmbundle)*vi-&gt;channels);
<a name="l00790"></a>00790   <span class="keywordtype">int</span>    *zerobundle=(<span class="keywordtype">int</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(*zerobundle)*vi-&gt;channels);
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   <span class="keywordtype">int</span>   *nonzero  =(<span class="keywordtype">int</span>*)_ogg_malloc(<span class="keyword">sizeof</span>(*nonzero)*vi-&gt;channels);
<a name="l00793"></a>00793   <span class="keywordtype">void</span> **floormemo=(<span class="keywordtype">void</span>**)_ogg_malloc(<span class="keyword">sizeof</span>(*floormemo)*vi-&gt;channels);
<a name="l00794"></a>00794   
<a name="l00795"></a>00795   <span class="keywordtype">float</span> **pcmbundle_cpy =pcmbundle;
<a name="l00796"></a>00796   <span class="keywordtype">int</span>    *zerobundle_cpy = zerobundle;
<a name="l00797"></a>00797   <span class="keywordtype">int</span>   *nonzero_cpy = nonzero;
<a name="l00798"></a>00798   <span class="keywordtype">void</span> **floormemo_cpy = floormemo;
<a name="l00799"></a>00799   <span class="comment">//check for double pointer free //caution!</span>
<a name="l00800"></a>00800   <span class="comment">//----------patch</span>
<a name="l00801"></a>00801   
<a name="l00802"></a>00802   <span class="comment">/* recover the spectral envelope; store it in the PCM vector for now */</span>
<a name="l00803"></a>00803   <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00804"></a>00804     <span class="keywordtype">int</span> submap=info-&gt;chmuxlist[i];
<a name="l00805"></a>00805     floormemo[i]=_floor_P[ci-&gt;floor_type[info-&gt;floorsubmap[submap]]]-&gt;
<a name="l00806"></a>00806       inverse1(vb,b-&gt;flr[info-&gt;floorsubmap[submap]]);
<a name="l00807"></a>00807     <span class="keywordflow">if</span>(floormemo[i])
<a name="l00808"></a>00808       nonzero[i]=1;
<a name="l00809"></a>00809     <span class="keywordflow">else</span>
<a name="l00810"></a>00810       nonzero[i]=0;      
<a name="l00811"></a>00811     memset(vb-&gt;pcm[i],0,<span class="keyword">sizeof</span>(*vb-&gt;pcm[i])*n/2);
<a name="l00812"></a>00812   }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814   <span class="comment">/* channel coupling can &#39;dirty&#39; the nonzero listing */</span>
<a name="l00815"></a>00815   <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;coupling_steps;i++){
<a name="l00816"></a>00816     <span class="keywordflow">if</span>(nonzero[info-&gt;coupling_mag[i]] ||
<a name="l00817"></a>00817        nonzero[info-&gt;coupling_ang[i]]){
<a name="l00818"></a>00818       nonzero[info-&gt;coupling_mag[i]]=1; 
<a name="l00819"></a>00819       nonzero[info-&gt;coupling_ang[i]]=1; 
<a name="l00820"></a>00820     }
<a name="l00821"></a>00821   }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="comment">/* recover the residue into our working vectors */</span>
<a name="l00824"></a>00824   <span class="keywordflow">for</span>(i=0;i&lt;info-&gt;submaps;i++){
<a name="l00825"></a>00825     <span class="keywordtype">int</span> ch_in_bundle=0;
<a name="l00826"></a>00826     <span class="keywordflow">for</span>(j=0;j&lt;vi-&gt;channels;j++){
<a name="l00827"></a>00827       <span class="keywordflow">if</span>(info-&gt;chmuxlist[j]==i){
<a name="l00828"></a>00828         <span class="keywordflow">if</span>(nonzero[j])
<a name="l00829"></a>00829           zerobundle[ch_in_bundle]=1;
<a name="l00830"></a>00830         <span class="keywordflow">else</span>
<a name="l00831"></a>00831           zerobundle[ch_in_bundle]=0;
<a name="l00832"></a>00832         pcmbundle[ch_in_bundle++]=vb-&gt;pcm[j];
<a name="l00833"></a>00833       }
<a name="l00834"></a>00834     }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836     _residue_P[ci-&gt;residue_type[info-&gt;residuesubmap[i]]]-&gt;
<a name="l00837"></a>00837       inverse(vb,b-&gt;residue[info-&gt;residuesubmap[i]],
<a name="l00838"></a>00838               pcmbundle,zerobundle,ch_in_bundle);
<a name="l00839"></a>00839   }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841   <span class="comment">/* channel coupling */</span>
<a name="l00842"></a>00842   <span class="keywordflow">for</span>(i=info-&gt;coupling_steps-1;i&gt;=0;i--){
<a name="l00843"></a>00843     <span class="keywordtype">float</span> *pcmM=vb-&gt;pcm[info-&gt;coupling_mag[i]];
<a name="l00844"></a>00844     <span class="keywordtype">float</span> *pcmA=vb-&gt;pcm[info-&gt;coupling_ang[i]];
<a name="l00845"></a>00845 
<a name="l00846"></a>00846     <span class="keywordflow">for</span>(j=0;j&lt;n/2;j++){
<a name="l00847"></a>00847       <span class="keywordtype">float</span> mag=pcmM[j];
<a name="l00848"></a>00848       <span class="keywordtype">float</span> ang=pcmA[j];
<a name="l00849"></a>00849 
<a name="l00850"></a>00850       <span class="keywordflow">if</span>(mag&gt;0)
<a name="l00851"></a>00851         <span class="keywordflow">if</span>(ang&gt;0){
<a name="l00852"></a>00852           pcmM[j]=mag;
<a name="l00853"></a>00853           pcmA[j]=mag-ang;
<a name="l00854"></a>00854         }<span class="keywordflow">else</span>{
<a name="l00855"></a>00855           pcmA[j]=mag;
<a name="l00856"></a>00856           pcmM[j]=mag+ang;
<a name="l00857"></a>00857         }
<a name="l00858"></a>00858       <span class="keywordflow">else</span>
<a name="l00859"></a>00859         <span class="keywordflow">if</span>(ang&gt;0){
<a name="l00860"></a>00860           pcmM[j]=mag;
<a name="l00861"></a>00861           pcmA[j]=mag+ang;
<a name="l00862"></a>00862         }<span class="keywordflow">else</span>{
<a name="l00863"></a>00863           pcmA[j]=mag;
<a name="l00864"></a>00864           pcmM[j]=mag-ang;
<a name="l00865"></a>00865         }
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867   }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="comment">/* compute and apply spectral envelope */</span>
<a name="l00870"></a>00870   <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00871"></a>00871     <span class="keywordtype">float</span> *pcm=vb-&gt;pcm[i];
<a name="l00872"></a>00872     <span class="keywordtype">int</span> submap=info-&gt;chmuxlist[i];
<a name="l00873"></a>00873     _floor_P[ci-&gt;floor_type[info-&gt;floorsubmap[submap]]]-&gt;
<a name="l00874"></a>00874       inverse2(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],
<a name="l00875"></a>00875                floormemo[i],pcm);
<a name="l00876"></a>00876   }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="comment">/* transform the PCM data; takes PCM vector, vb; modifies PCM vector */</span>
<a name="l00879"></a>00879   <span class="comment">/* only MDCT right now.... */</span>
<a name="l00880"></a>00880   <span class="keywordflow">for</span>(i=0;i&lt;vi-&gt;channels;i++){
<a name="l00881"></a>00881     <span class="keywordtype">float</span> *pcm=vb-&gt;pcm[i];
<a name="l00882"></a>00882     mdct_backward((<a class="code" href="structmdct__lookup.html">mdct_lookup</a>*)b-&gt;transform[vb-&gt;W][0],pcm,pcm);
<a name="l00883"></a>00883   }
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">//patch---------</span>
<a name="l00886"></a>00886   free(pcmbundle_cpy);
<a name="l00887"></a>00887   free(zerobundle_cpy);
<a name="l00888"></a>00888   free(nonzero_cpy);
<a name="l00889"></a>00889   free(floormemo_cpy);
<a name="l00890"></a>00890   <span class="comment">//patch---------</span>
<a name="l00891"></a>00891   
<a name="l00892"></a>00892   <span class="comment">/* all done! */</span>         
<a name="l00893"></a>00893   <span class="keywordflow">return</span>(0);
<a name="l00894"></a>00894 }
<a name="l00895"></a>00895  
<a name="l00896"></a>00896 <span class="comment">/* export hooks */</span>
<a name="l00897"></a>00897 <a class="code" href="structvorbis__func__mapping.html">vorbis_func_mapping</a> mapping0_exportbundle={
<a name="l00898"></a>00898   &amp;mapping0_pack,
<a name="l00899"></a>00899   &amp;mapping0_unpack,
<a name="l00900"></a>00900   &amp;mapping0_free_info,
<a name="l00901"></a>00901   &amp;mapping0_forward,
<a name="l00902"></a>00902   &amp;mapping0_inverse
<a name="l00903"></a>00903 };
<a name="l00904"></a>00904 
</pre></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/src_2libvorbis_2lib_2mapping0_8c_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:19:05 GMT -->
</html>
