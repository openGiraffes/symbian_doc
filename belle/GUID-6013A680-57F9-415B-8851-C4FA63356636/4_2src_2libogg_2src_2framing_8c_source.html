<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/4_2src_2libogg_2src_2framing_8c_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:17:58 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Example Code: examples/SFExamples/oggvorbiscodec94/src/libogg/src/framing.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<h1>examples/SFExamples/oggvorbiscodec94/src/libogg/src/framing.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/********************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *                                                                  *</span>
<a name="l00003"></a>00003 <span class="comment"> * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *</span>
<a name="l00004"></a>00004 <span class="comment"> * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *</span>
<a name="l00005"></a>00005 <span class="comment"> * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *</span>
<a name="l00006"></a>00006 <span class="comment"> * IN &#39;COPYING&#39;. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *</span>
<a name="l00007"></a>00007 <span class="comment"> *                                                                  *</span>
<a name="l00008"></a>00008 <span class="comment"> * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2002             *</span>
<a name="l00009"></a>00009 <span class="comment"> * by the Xiph.Org Foundation http://www.xiph.org/                  *</span>
<a name="l00010"></a>00010 <span class="comment"> *                                                                  *</span>
<a name="l00011"></a>00011 <span class="comment"> ********************************************************************</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment"> function: code raw [Vorbis] packets into framed OggSquish stream and</span>
<a name="l00014"></a>00014 <span class="comment">           decode Ogg streams back into raw packets</span>
<a name="l00015"></a>00015 <span class="comment"> last mod: $Id: framing.c,v 1.23 2002/09/29 07:10:37 giles Exp $</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment"> note: The CRC code is directly derived from public domain code by</span>
<a name="l00018"></a>00018 <span class="comment"> Ross Williams (ross@guest.adelaide.edu.au).  See docs/framing.html</span>
<a name="l00019"></a>00019 <span class="comment"> for details.</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment"> ********************************************************************/</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;ogg/ogg.h&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* A complete description of Ogg framing exists in docs/framing.html */</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keywordtype">int</span> ogg_page_version(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00030"></a>00030   <span class="keywordflow">return</span>((<span class="keywordtype">int</span>)(og-&gt;header[4]));
<a name="l00031"></a>00031 }
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keywordtype">int</span> ogg_page_continued(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00034"></a>00034   <span class="keywordflow">return</span>((<span class="keywordtype">int</span>)(og-&gt;header[5]&amp;0x01));
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keywordtype">int</span> ogg_page_bos(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00038"></a>00038   <span class="keywordflow">return</span>((<span class="keywordtype">int</span>)(og-&gt;header[5]&amp;0x02));
<a name="l00039"></a>00039 }
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="keywordtype">int</span> ogg_page_eos(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00042"></a>00042   <span class="keywordflow">return</span>((<span class="keywordtype">int</span>)(og-&gt;header[5]&amp;0x04));
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 ogg_int64_t ogg_page_granulepos(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00046"></a>00046   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *page=og-&gt;header;
<a name="l00047"></a>00047   ogg_int64_t granulepos=page[13]&amp;(0xff);
<a name="l00048"></a>00048   granulepos= (granulepos&lt;&lt;8)|(page[12]&amp;0xff);
<a name="l00049"></a>00049   granulepos= (granulepos&lt;&lt;8)|(page[11]&amp;0xff);
<a name="l00050"></a>00050   granulepos= (granulepos&lt;&lt;8)|(page[10]&amp;0xff);
<a name="l00051"></a>00051   granulepos= (granulepos&lt;&lt;8)|(page[9]&amp;0xff);
<a name="l00052"></a>00052   granulepos= (granulepos&lt;&lt;8)|(page[8]&amp;0xff);
<a name="l00053"></a>00053   granulepos= (granulepos&lt;&lt;8)|(page[7]&amp;0xff);
<a name="l00054"></a>00054   granulepos= (granulepos&lt;&lt;8)|(page[6]&amp;0xff);
<a name="l00055"></a>00055   <span class="keywordflow">return</span>(granulepos);
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keywordtype">int</span> ogg_page_serialno(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00059"></a>00059   <span class="keywordflow">return</span>(og-&gt;header[14] |
<a name="l00060"></a>00060          (og-&gt;header[15]&lt;&lt;8) |
<a name="l00061"></a>00061          (og-&gt;header[16]&lt;&lt;16) |
<a name="l00062"></a>00062          (og-&gt;header[17]&lt;&lt;24));
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064  
<a name="l00065"></a>00065 <span class="keywordtype">long</span> ogg_page_pageno(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00066"></a>00066   <span class="keywordflow">return</span>(og-&gt;header[18] |
<a name="l00067"></a>00067          (og-&gt;header[19]&lt;&lt;8) |
<a name="l00068"></a>00068          (og-&gt;header[20]&lt;&lt;16) |
<a name="l00069"></a>00069          (og-&gt;header[21]&lt;&lt;24));
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">/* returns the number of packets that are completed on this page (if</span>
<a name="l00075"></a>00075 <span class="comment">   the leading packet is begun on a previous page, but ends on this</span>
<a name="l00076"></a>00076 <span class="comment">   page, it&#39;s counted */</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">/* NOTE:</span>
<a name="l00079"></a>00079 <span class="comment">If a page consists of a packet begun on a previous page, and a new</span>
<a name="l00080"></a>00080 <span class="comment">packet begun (but not completed) on this page, the return will be:</span>
<a name="l00081"></a>00081 <span class="comment">  ogg_page_packets(page)   ==1, </span>
<a name="l00082"></a>00082 <span class="comment">  ogg_page_continued(page) !=0</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">If a page happens to be a single packet that was begun on a</span>
<a name="l00085"></a>00085 <span class="comment">previous page, and spans to the next page (in the case of a three or</span>
<a name="l00086"></a>00086 <span class="comment">more page packet), the return will be: </span>
<a name="l00087"></a>00087 <span class="comment">  ogg_page_packets(page)   ==0, </span>
<a name="l00088"></a>00088 <span class="comment">  ogg_page_continued(page) !=0</span>
<a name="l00089"></a>00089 <span class="comment">*/</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keywordtype">int</span> ogg_page_packets(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00092"></a>00092   <span class="keywordtype">int</span> i,n=og-&gt;header[26],count=0;
<a name="l00093"></a>00093   <span class="keywordflow">for</span>(i=0;i&lt;n;i++)
<a name="l00094"></a>00094     <span class="keywordflow">if</span>(og-&gt;header[27+i]&lt;255)count++;
<a name="l00095"></a>00095   <span class="keywordflow">return</span>(count);
<a name="l00096"></a>00096 }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor">#if 0</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="comment">/* helper to initialize lookup for direct-table CRC (illustrative; we</span>
<a name="l00101"></a>00101 <span class="comment">   use the static init below) */</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keyword">static</span> ogg_uint32_t _ogg_crc_entry(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> index){
<a name="l00104"></a>00104   <span class="keywordtype">int</span>           i;
<a name="l00105"></a>00105   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> r;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107   r = index &lt;&lt; 24;
<a name="l00108"></a>00108   <span class="keywordflow">for</span> (i=0; i&lt;8; i++)
<a name="l00109"></a>00109     <span class="keywordflow">if</span> (r &amp; 0x80000000UL)
<a name="l00110"></a>00110       r = (r &lt;&lt; 1) ^ 0x04c11db7; <span class="comment">/* The same as the ethernet generator</span>
<a name="l00111"></a>00111 <span class="comment">                                    polynomial, although we use an</span>
<a name="l00112"></a>00112 <span class="comment">                                    unreflected alg and an init/final</span>
<a name="l00113"></a>00113 <span class="comment">                                    of 0, not 0xffffffff */</span>
<a name="l00114"></a>00114     <span class="keywordflow">else</span>
<a name="l00115"></a>00115        r&lt;&lt;=1;
<a name="l00116"></a>00116  <span class="keywordflow">return</span> (r &amp; 0xffffffffUL);
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 <span class="preprocessor">#endif</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>
<a name="l00120"></a>00120 <span class="keyword">const</span> <span class="keyword">static</span> ogg_uint32_t crc_lookup[256]={
<a name="l00121"></a>00121   0x00000000,0x04c11db7,0x09823b6e,0x0d4326d9,
<a name="l00122"></a>00122   0x130476dc,0x17c56b6b,0x1a864db2,0x1e475005,
<a name="l00123"></a>00123   0x2608edb8,0x22c9f00f,0x2f8ad6d6,0x2b4bcb61,
<a name="l00124"></a>00124   0x350c9b64,0x31cd86d3,0x3c8ea00a,0x384fbdbd,
<a name="l00125"></a>00125   0x4c11db70,0x48d0c6c7,0x4593e01e,0x4152fda9,
<a name="l00126"></a>00126   0x5f15adac,0x5bd4b01b,0x569796c2,0x52568b75,
<a name="l00127"></a>00127   0x6a1936c8,0x6ed82b7f,0x639b0da6,0x675a1011,
<a name="l00128"></a>00128   0x791d4014,0x7ddc5da3,0x709f7b7a,0x745e66cd,
<a name="l00129"></a>00129   0x9823b6e0,0x9ce2ab57,0x91a18d8e,0x95609039,
<a name="l00130"></a>00130   0x8b27c03c,0x8fe6dd8b,0x82a5fb52,0x8664e6e5,
<a name="l00131"></a>00131   0xbe2b5b58,0xbaea46ef,0xb7a96036,0xb3687d81,
<a name="l00132"></a>00132   0xad2f2d84,0xa9ee3033,0xa4ad16ea,0xa06c0b5d,
<a name="l00133"></a>00133   0xd4326d90,0xd0f37027,0xddb056fe,0xd9714b49,
<a name="l00134"></a>00134   0xc7361b4c,0xc3f706fb,0xceb42022,0xca753d95,
<a name="l00135"></a>00135   0xf23a8028,0xf6fb9d9f,0xfbb8bb46,0xff79a6f1,
<a name="l00136"></a>00136   0xe13ef6f4,0xe5ffeb43,0xe8bccd9a,0xec7dd02d,
<a name="l00137"></a>00137   0x34867077,0x30476dc0,0x3d044b19,0x39c556ae,
<a name="l00138"></a>00138   0x278206ab,0x23431b1c,0x2e003dc5,0x2ac12072,
<a name="l00139"></a>00139   0x128e9dcf,0x164f8078,0x1b0ca6a1,0x1fcdbb16,
<a name="l00140"></a>00140   0x018aeb13,0x054bf6a4,0x0808d07d,0x0cc9cdca,
<a name="l00141"></a>00141   0x7897ab07,0x7c56b6b0,0x71159069,0x75d48dde,
<a name="l00142"></a>00142   0x6b93dddb,0x6f52c06c,0x6211e6b5,0x66d0fb02,
<a name="l00143"></a>00143   0x5e9f46bf,0x5a5e5b08,0x571d7dd1,0x53dc6066,
<a name="l00144"></a>00144   0x4d9b3063,0x495a2dd4,0x44190b0d,0x40d816ba,
<a name="l00145"></a>00145   0xaca5c697,0xa864db20,0xa527fdf9,0xa1e6e04e,
<a name="l00146"></a>00146   0xbfa1b04b,0xbb60adfc,0xb6238b25,0xb2e29692,
<a name="l00147"></a>00147   0x8aad2b2f,0x8e6c3698,0x832f1041,0x87ee0df6,
<a name="l00148"></a>00148   0x99a95df3,0x9d684044,0x902b669d,0x94ea7b2a,
<a name="l00149"></a>00149   0xe0b41de7,0xe4750050,0xe9362689,0xedf73b3e,
<a name="l00150"></a>00150   0xf3b06b3b,0xf771768c,0xfa325055,0xfef34de2,
<a name="l00151"></a>00151   0xc6bcf05f,0xc27dede8,0xcf3ecb31,0xcbffd686,
<a name="l00152"></a>00152   0xd5b88683,0xd1799b34,0xdc3abded,0xd8fba05a,
<a name="l00153"></a>00153   0x690ce0ee,0x6dcdfd59,0x608edb80,0x644fc637,
<a name="l00154"></a>00154   0x7a089632,0x7ec98b85,0x738aad5c,0x774bb0eb,
<a name="l00155"></a>00155   0x4f040d56,0x4bc510e1,0x46863638,0x42472b8f,
<a name="l00156"></a>00156   0x5c007b8a,0x58c1663d,0x558240e4,0x51435d53,
<a name="l00157"></a>00157   0x251d3b9e,0x21dc2629,0x2c9f00f0,0x285e1d47,
<a name="l00158"></a>00158   0x36194d42,0x32d850f5,0x3f9b762c,0x3b5a6b9b,
<a name="l00159"></a>00159   0x0315d626,0x07d4cb91,0x0a97ed48,0x0e56f0ff,
<a name="l00160"></a>00160   0x1011a0fa,0x14d0bd4d,0x19939b94,0x1d528623,
<a name="l00161"></a>00161   0xf12f560e,0xf5ee4bb9,0xf8ad6d60,0xfc6c70d7,
<a name="l00162"></a>00162   0xe22b20d2,0xe6ea3d65,0xeba91bbc,0xef68060b,
<a name="l00163"></a>00163   0xd727bbb6,0xd3e6a601,0xdea580d8,0xda649d6f,
<a name="l00164"></a>00164   0xc423cd6a,0xc0e2d0dd,0xcda1f604,0xc960ebb3,
<a name="l00165"></a>00165   0xbd3e8d7e,0xb9ff90c9,0xb4bcb610,0xb07daba7,
<a name="l00166"></a>00166   0xae3afba2,0xaafbe615,0xa7b8c0cc,0xa379dd7b,
<a name="l00167"></a>00167   0x9b3660c6,0x9ff77d71,0x92b45ba8,0x9675461f,
<a name="l00168"></a>00168   0x8832161a,0x8cf30bad,0x81b02d74,0x857130c3,
<a name="l00169"></a>00169   0x5d8a9099,0x594b8d2e,0x5408abf7,0x50c9b640,
<a name="l00170"></a>00170   0x4e8ee645,0x4a4ffbf2,0x470cdd2b,0x43cdc09c,
<a name="l00171"></a>00171   0x7b827d21,0x7f436096,0x7200464f,0x76c15bf8,
<a name="l00172"></a>00172   0x68860bfd,0x6c47164a,0x61043093,0x65c52d24,
<a name="l00173"></a>00173   0x119b4be9,0x155a565e,0x18197087,0x1cd86d30,
<a name="l00174"></a>00174   0x029f3d35,0x065e2082,0x0b1d065b,0x0fdc1bec,
<a name="l00175"></a>00175   0x3793a651,0x3352bbe6,0x3e119d3f,0x3ad08088,
<a name="l00176"></a>00176   0x2497d08d,0x2056cd3a,0x2d15ebe3,0x29d4f654,
<a name="l00177"></a>00177   0xc5a92679,0xc1683bce,0xcc2b1d17,0xc8ea00a0,
<a name="l00178"></a>00178   0xd6ad50a5,0xd26c4d12,0xdf2f6bcb,0xdbee767c,
<a name="l00179"></a>00179   0xe3a1cbc1,0xe760d676,0xea23f0af,0xeee2ed18,
<a name="l00180"></a>00180   0xf0a5bd1d,0xf464a0aa,0xf9278673,0xfde69bc4,
<a name="l00181"></a>00181   0x89b8fd09,0x8d79e0be,0x803ac667,0x84fbdbd0,
<a name="l00182"></a>00182   0x9abc8bd5,0x9e7d9662,0x933eb0bb,0x97ffad0c,
<a name="l00183"></a>00183   0xafb010b1,0xab710d06,0xa6322bdf,0xa2f33668,
<a name="l00184"></a>00184   0xbcb4666d,0xb8757bda,0xb5365d03,0xb1f740b4};
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">/* init the encode/decode logical stream state */</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keywordtype">int</span> ogg_stream_init(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<span class="keywordtype">int</span> serialno){
<a name="l00189"></a>00189   <span class="keywordflow">if</span>(os){
<a name="l00190"></a>00190     memset(os,0,<span class="keyword">sizeof</span>(*os));
<a name="l00191"></a>00191     os-&gt;body_storage=16*1024;
<a name="l00192"></a>00192     os-&gt;body_data=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)_ogg_malloc(os-&gt;body_storage*<span class="keyword">sizeof</span>(*os-&gt;body_data));
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     os-&gt;lacing_storage=1024;
<a name="l00195"></a>00195     os-&gt;lacing_vals=(<span class="keywordtype">int</span>*)_ogg_malloc(os-&gt;lacing_storage*<span class="keyword">sizeof</span>(*os-&gt;lacing_vals));
<a name="l00196"></a>00196     os-&gt;granule_vals=(ogg_int64_t*)_ogg_malloc(os-&gt;lacing_storage*<span class="keyword">sizeof</span>(*os-&gt;granule_vals));
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     os-&gt;serialno=serialno;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200     <span class="keywordflow">return</span>(0);
<a name="l00201"></a>00201   }
<a name="l00202"></a>00202   <span class="keywordflow">return</span>(-1);
<a name="l00203"></a>00203 } 
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="comment">/* _clear does not free os, only the non-flat storage within */</span>
<a name="l00206"></a>00206 <span class="keywordtype">int</span> ogg_stream_clear(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os){
<a name="l00207"></a>00207   <span class="keywordflow">if</span>(os){
<a name="l00208"></a>00208     <span class="keywordflow">if</span>(os-&gt;body_data)_ogg_free(os-&gt;body_data);
<a name="l00209"></a>00209     <span class="keywordflow">if</span>(os-&gt;lacing_vals)_ogg_free(os-&gt;lacing_vals);
<a name="l00210"></a>00210     <span class="keywordflow">if</span>(os-&gt;granule_vals)_ogg_free(os-&gt;granule_vals);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     memset(os,0,<span class="keyword">sizeof</span>(*os));    
<a name="l00213"></a>00213   }
<a name="l00214"></a>00214   <span class="keywordflow">return</span>(0);
<a name="l00215"></a>00215 } 
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keywordtype">int</span> ogg_stream_destroy(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os){
<a name="l00218"></a>00218   <span class="keywordflow">if</span>(os){
<a name="l00219"></a>00219     ogg_stream_clear(os);
<a name="l00220"></a>00220     _ogg_free(os);
<a name="l00221"></a>00221   }
<a name="l00222"></a>00222   <span class="keywordflow">return</span>(0);
<a name="l00223"></a>00223 } 
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">/* Helpers for ogg_stream_encode; this keeps the structure and</span>
<a name="l00226"></a>00226 <span class="comment">   what&#39;s happening fairly clear */</span>
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keyword">static</span> <span class="keywordtype">void</span> _os_body_expand(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<span class="keywordtype">int</span> needed){
<a name="l00229"></a>00229   <span class="keywordflow">if</span>(os-&gt;body_storage&lt;=os-&gt;body_fill+needed){
<a name="l00230"></a>00230     os-&gt;body_storage+=(needed+1024);
<a name="l00231"></a>00231     os-&gt;body_data=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)_ogg_realloc(os-&gt;body_data,os-&gt;body_storage*<span class="keyword">sizeof</span>(*os-&gt;body_data));
<a name="l00232"></a>00232   }
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 <span class="keyword">static</span> <span class="keywordtype">void</span> _os_lacing_expand(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<span class="keywordtype">int</span> needed){
<a name="l00236"></a>00236   <span class="keywordflow">if</span>(os-&gt;lacing_storage&lt;=os-&gt;lacing_fill+needed){
<a name="l00237"></a>00237     os-&gt;lacing_storage+=(needed+32);
<a name="l00238"></a>00238     os-&gt;lacing_vals=(<span class="keywordtype">int</span>*)_ogg_realloc(os-&gt;lacing_vals,os-&gt;lacing_storage*<span class="keyword">sizeof</span>(*os-&gt;lacing_vals));
<a name="l00239"></a>00239     os-&gt;granule_vals=(ogg_int64_t*)_ogg_realloc(os-&gt;granule_vals,os-&gt;lacing_storage*<span class="keyword">sizeof</span>(*os-&gt;granule_vals));
<a name="l00240"></a>00240   }
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">/* checksum the page */</span>
<a name="l00244"></a>00244 <span class="comment">/* Direct table CRC; note that this will be faster in the future if we</span>
<a name="l00245"></a>00245 <span class="comment">   perform the checksum silmultaneously with other copies */</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="keywordtype">void</span> ogg_page_checksum_set(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00248"></a>00248   <span class="keywordflow">if</span>(og){
<a name="l00249"></a>00249     ogg_uint32_t crc_reg=0;
<a name="l00250"></a>00250     <span class="keywordtype">int</span> i;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="comment">/* safety; needed for API behavior, but not framing code */</span>
<a name="l00253"></a>00253     og-&gt;header[22]=0;
<a name="l00254"></a>00254     og-&gt;header[23]=0;
<a name="l00255"></a>00255     og-&gt;header[24]=0;
<a name="l00256"></a>00256     og-&gt;header[25]=0;
<a name="l00257"></a>00257     
<a name="l00258"></a>00258     <span class="keywordflow">for</span>(i=0;i&lt;og-&gt;header_len;i++)
<a name="l00259"></a>00259       crc_reg=(crc_reg&lt;&lt;8)^crc_lookup[((crc_reg &gt;&gt; 24)&amp;0xff)^og-&gt;header[i]];
<a name="l00260"></a>00260     <span class="keywordflow">for</span>(i=0;i&lt;og-&gt;body_len;i++)
<a name="l00261"></a>00261       crc_reg=(crc_reg&lt;&lt;8)^crc_lookup[((crc_reg &gt;&gt; 24)&amp;0xff)^og-&gt;body[i]];
<a name="l00262"></a>00262     
<a name="l00263"></a>00263     og-&gt;header[22]=crc_reg&amp;0xff;
<a name="l00264"></a>00264     og-&gt;header[23]=(crc_reg&gt;&gt;8)&amp;0xff;
<a name="l00265"></a>00265     og-&gt;header[24]=(crc_reg&gt;&gt;16)&amp;0xff;
<a name="l00266"></a>00266     og-&gt;header[25]=(crc_reg&gt;&gt;24)&amp;0xff;
<a name="l00267"></a>00267   }
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="comment">/* submit data to the internal buffer of the framing engine */</span>
<a name="l00271"></a>00271 <span class="keywordtype">int</span> ogg_stream_packetin(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<a class="code" href="structogg__packet.html">ogg_packet</a> *op){
<a name="l00272"></a>00272   <span class="keywordtype">int</span> lacing_vals=op-&gt;bytes/255+1,i;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="keywordflow">if</span>(os-&gt;body_returned){
<a name="l00275"></a>00275     <span class="comment">/* advance packet data according to the body_returned pointer. We</span>
<a name="l00276"></a>00276 <span class="comment">       had to keep it around to return a pointer into the buffer last</span>
<a name="l00277"></a>00277 <span class="comment">       call */</span>
<a name="l00278"></a>00278     
<a name="l00279"></a>00279     os-&gt;body_fill-=os-&gt;body_returned;
<a name="l00280"></a>00280     <span class="keywordflow">if</span>(os-&gt;body_fill)
<a name="l00281"></a>00281       memmove(os-&gt;body_data,os-&gt;body_data+os-&gt;body_returned,
<a name="l00282"></a>00282               os-&gt;body_fill);
<a name="l00283"></a>00283     os-&gt;body_returned=0;
<a name="l00284"></a>00284   }
<a name="l00285"></a>00285  
<a name="l00286"></a>00286   <span class="comment">/* make sure we have the buffer storage */</span>
<a name="l00287"></a>00287   _os_body_expand(os,op-&gt;bytes);
<a name="l00288"></a>00288   _os_lacing_expand(os,lacing_vals);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">/* Copy in the submitted packet.  Yes, the copy is a waste; this is</span>
<a name="l00291"></a>00291 <span class="comment">     the liability of overly clean abstraction for the time being.  It</span>
<a name="l00292"></a>00292 <span class="comment">     will actually be fairly easy to eliminate the extra copy in the</span>
<a name="l00293"></a>00293 <span class="comment">     future */</span>
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   memcpy(os-&gt;body_data+os-&gt;body_fill,op-&gt;packet,op-&gt;bytes);
<a name="l00296"></a>00296   os-&gt;body_fill+=op-&gt;bytes;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298   <span class="comment">/* Store lacing vals for this packet */</span>
<a name="l00299"></a>00299   <span class="keywordflow">for</span>(i=0;i&lt;lacing_vals-1;i++){
<a name="l00300"></a>00300     os-&gt;lacing_vals[os-&gt;lacing_fill+i]=255;
<a name="l00301"></a>00301     os-&gt;granule_vals[os-&gt;lacing_fill+i]=os-&gt;granulepos;
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303   os-&gt;lacing_vals[os-&gt;lacing_fill+i]=(op-&gt;bytes)%255;
<a name="l00304"></a>00304   os-&gt;granulepos=os-&gt;granule_vals[os-&gt;lacing_fill+i]=op-&gt;granulepos;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="comment">/* flag the first segment as the beginning of the packet */</span>
<a name="l00307"></a>00307   os-&gt;lacing_vals[os-&gt;lacing_fill]|= 0x100;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309   os-&gt;lacing_fill+=lacing_vals;
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="comment">/* for the sake of completeness */</span>
<a name="l00312"></a>00312   os-&gt;packetno++;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314   <span class="keywordflow">if</span>(op-&gt;e_o_s)os-&gt;e_o_s=1;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordflow">return</span>(0);
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">/* This will flush remaining packets into a page (returning nonzero),</span>
<a name="l00320"></a>00320 <span class="comment">   even if there is not enough data to trigger a flush normally</span>
<a name="l00321"></a>00321 <span class="comment">   (undersized page). If there are no packets or partial packets to</span>
<a name="l00322"></a>00322 <span class="comment">   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will</span>
<a name="l00323"></a>00323 <span class="comment">   try to flush a normal sized page like ogg_stream_pageout; a call to</span>
<a name="l00324"></a>00324 <span class="comment">   ogg_stream_flush does not guarantee that all packets have flushed.</span>
<a name="l00325"></a>00325 <span class="comment">   Only a return value of 0 from ogg_stream_flush indicates all packet</span>
<a name="l00326"></a>00326 <span class="comment">   data is flushed into pages.</span>
<a name="l00327"></a>00327 <span class="comment"></span>
<a name="l00328"></a>00328 <span class="comment">   since ogg_stream_flush will flush the last page in a stream even if</span>
<a name="l00329"></a>00329 <span class="comment">   it&#39;s undersized, you almost certainly want to use ogg_stream_pageout</span>
<a name="l00330"></a>00330 <span class="comment">   (and *not* ogg_stream_flush) unless you specifically need to flush </span>
<a name="l00331"></a>00331 <span class="comment">   an page regardless of size in the middle of a stream. */</span>
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="keywordtype">int</span> ogg_stream_flush(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00334"></a>00334   <span class="keywordtype">int</span> i;
<a name="l00335"></a>00335   <span class="keywordtype">int</span> vals=0;
<a name="l00336"></a>00336   <span class="keywordtype">int</span> maxvals=(os-&gt;lacing_fill&gt;255?255:os-&gt;lacing_fill);
<a name="l00337"></a>00337   <span class="keywordtype">int</span> bytes=0;
<a name="l00338"></a>00338   <span class="keywordtype">long</span> acc=0;
<a name="l00339"></a>00339   ogg_int64_t granule_pos=os-&gt;granule_vals[0];
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="keywordflow">if</span>(maxvals==0)<span class="keywordflow">return</span>(0);
<a name="l00342"></a>00342   
<a name="l00343"></a>00343   <span class="comment">/* construct a page */</span>
<a name="l00344"></a>00344   <span class="comment">/* decide how many segments to include */</span>
<a name="l00345"></a>00345   
<a name="l00346"></a>00346   <span class="comment">/* If this is the initial header case, the first page must only include</span>
<a name="l00347"></a>00347 <span class="comment">     the initial header packet */</span>
<a name="l00348"></a>00348   <span class="keywordflow">if</span>(os-&gt;b_o_s==0){  <span class="comment">/* &#39;initial header page&#39; case */</span>
<a name="l00349"></a>00349     granule_pos=0;
<a name="l00350"></a>00350     <span class="keywordflow">for</span>(vals=0;vals&lt;maxvals;vals++){
<a name="l00351"></a>00351       <span class="keywordflow">if</span>((os-&gt;lacing_vals[vals]&amp;0x0ff)&lt;255){
<a name="l00352"></a>00352         vals++;
<a name="l00353"></a>00353         <span class="keywordflow">break</span>;
<a name="l00354"></a>00354       }
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356   }<span class="keywordflow">else</span>{
<a name="l00357"></a>00357     <span class="keywordflow">for</span>(vals=0;vals&lt;maxvals;vals++){
<a name="l00358"></a>00358       <span class="keywordflow">if</span>(acc&gt;4096)<span class="keywordflow">break</span>;
<a name="l00359"></a>00359       acc+=os-&gt;lacing_vals[vals]&amp;0x0ff;
<a name="l00360"></a>00360       granule_pos=os-&gt;granule_vals[vals];
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362   }
<a name="l00363"></a>00363   
<a name="l00364"></a>00364   <span class="comment">/* construct the header in temp storage */</span>
<a name="l00365"></a>00365   memcpy(os-&gt;header,<span class="stringliteral">&quot;OggS&quot;</span>,4);
<a name="l00366"></a>00366   
<a name="l00367"></a>00367   <span class="comment">/* stream structure version */</span>
<a name="l00368"></a>00368   os-&gt;header[4]=0x00;
<a name="l00369"></a>00369   
<a name="l00370"></a>00370   <span class="comment">/* continued packet flag? */</span>
<a name="l00371"></a>00371   os-&gt;header[5]=0x00;
<a name="l00372"></a>00372   <span class="keywordflow">if</span>((os-&gt;lacing_vals[0]&amp;0x100)==0)os-&gt;header[5]|=0x01;
<a name="l00373"></a>00373   <span class="comment">/* first page flag? */</span>
<a name="l00374"></a>00374   <span class="keywordflow">if</span>(os-&gt;b_o_s==0)os-&gt;header[5]|=0x02;
<a name="l00375"></a>00375   <span class="comment">/* last page flag? */</span>
<a name="l00376"></a>00376   <span class="keywordflow">if</span>(os-&gt;e_o_s &amp;&amp; os-&gt;lacing_fill==vals)os-&gt;header[5]|=0x04;
<a name="l00377"></a>00377   os-&gt;b_o_s=1;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="comment">/* 64 bits of PCM position */</span>
<a name="l00380"></a>00380   <span class="keywordflow">for</span>(i=6;i&lt;14;i++){
<a name="l00381"></a>00381     os-&gt;header[i]=(granule_pos&amp;0xff);
<a name="l00382"></a>00382     granule_pos&gt;&gt;=8;
<a name="l00383"></a>00383   }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">/* 32 bits of stream serial number */</span>
<a name="l00386"></a>00386   {
<a name="l00387"></a>00387     <span class="keywordtype">long</span> serialno=os-&gt;serialno;
<a name="l00388"></a>00388     <span class="keywordflow">for</span>(i=14;i&lt;18;i++){
<a name="l00389"></a>00389       os-&gt;header[i]=(serialno&amp;0xff);
<a name="l00390"></a>00390       serialno&gt;&gt;=8;
<a name="l00391"></a>00391     }
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394   <span class="comment">/* 32 bits of page counter (we have both counter and page header</span>
<a name="l00395"></a>00395 <span class="comment">     because this val can roll over) */</span>
<a name="l00396"></a>00396   <span class="keywordflow">if</span>(os-&gt;pageno==-1)os-&gt;pageno=0; <span class="comment">/* because someone called</span>
<a name="l00397"></a>00397 <span class="comment">                                     stream_reset; this would be a</span>
<a name="l00398"></a>00398 <span class="comment">                                     strange thing to do in an</span>
<a name="l00399"></a>00399 <span class="comment">                                     encode stream, but it has</span>
<a name="l00400"></a>00400 <span class="comment">                                     plausible uses */</span>
<a name="l00401"></a>00401   {
<a name="l00402"></a>00402     <span class="keywordtype">long</span> pageno=os-&gt;pageno++;
<a name="l00403"></a>00403     <span class="keywordflow">for</span>(i=18;i&lt;22;i++){
<a name="l00404"></a>00404       os-&gt;header[i]=(pageno&amp;0xff);
<a name="l00405"></a>00405       pageno&gt;&gt;=8;
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407   }
<a name="l00408"></a>00408   
<a name="l00409"></a>00409   <span class="comment">/* zero for computation; filled in later */</span>
<a name="l00410"></a>00410   os-&gt;header[22]=0;
<a name="l00411"></a>00411   os-&gt;header[23]=0;
<a name="l00412"></a>00412   os-&gt;header[24]=0;
<a name="l00413"></a>00413   os-&gt;header[25]=0;
<a name="l00414"></a>00414   
<a name="l00415"></a>00415   <span class="comment">/* segment table */</span>
<a name="l00416"></a>00416   os-&gt;header[26]=vals&amp;0xff;
<a name="l00417"></a>00417   <span class="keywordflow">for</span>(i=0;i&lt;vals;i++)
<a name="l00418"></a>00418     bytes+=os-&gt;header[i+27]=(os-&gt;lacing_vals[i]&amp;0xff);
<a name="l00419"></a>00419   
<a name="l00420"></a>00420   <span class="comment">/* set pointers in the ogg_page struct */</span>
<a name="l00421"></a>00421   og-&gt;header=os-&gt;header;
<a name="l00422"></a>00422   og-&gt;header_len=os-&gt;header_fill=vals+27;
<a name="l00423"></a>00423   og-&gt;body=os-&gt;body_data+os-&gt;body_returned;
<a name="l00424"></a>00424   og-&gt;body_len=bytes;
<a name="l00425"></a>00425   
<a name="l00426"></a>00426   <span class="comment">/* advance the lacing data and set the body_returned pointer */</span>
<a name="l00427"></a>00427   
<a name="l00428"></a>00428   os-&gt;lacing_fill-=vals;
<a name="l00429"></a>00429   memmove(os-&gt;lacing_vals,os-&gt;lacing_vals+vals,os-&gt;lacing_fill*<span class="keyword">sizeof</span>(*os-&gt;lacing_vals));
<a name="l00430"></a>00430   memmove(os-&gt;granule_vals,os-&gt;granule_vals+vals,os-&gt;lacing_fill*<span class="keyword">sizeof</span>(*os-&gt;granule_vals));
<a name="l00431"></a>00431   os-&gt;body_returned+=bytes;
<a name="l00432"></a>00432   
<a name="l00433"></a>00433   <span class="comment">/* calculate the checksum */</span>
<a name="l00434"></a>00434   
<a name="l00435"></a>00435   ogg_page_checksum_set(og);
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="comment">/* done */</span>
<a name="l00438"></a>00438   <span class="keywordflow">return</span>(1);
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="comment">/* This constructs pages from buffered packet segments.  The pointers</span>
<a name="l00443"></a>00443 <span class="comment">returned are to static buffers; do not free. The returned buffers are</span>
<a name="l00444"></a>00444 <span class="comment">good only until the next call (using the same ogg_stream_state) */</span>
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="keywordtype">int</span> ogg_stream_pageout(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os, <a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="keywordflow">if</span>((os-&gt;e_o_s&amp;&amp;os-&gt;lacing_fill) ||          <span class="comment">/* &#39;were done, now flush&#39; case */</span>
<a name="l00449"></a>00449      os-&gt;body_fill-os-&gt;body_returned &gt; 4096 ||<span class="comment">/* &#39;page nominal size&#39; case */</span>
<a name="l00450"></a>00450      os-&gt;lacing_fill&gt;=255 ||                  <span class="comment">/* &#39;segment table full&#39; case */</span>
<a name="l00451"></a>00451      (os-&gt;lacing_fill&amp;&amp;!os-&gt;b_o_s)){          <span class="comment">/* &#39;initial header page&#39; case */</span>
<a name="l00452"></a>00452         
<a name="l00453"></a>00453     <span class="keywordflow">return</span>(ogg_stream_flush(os,og));
<a name="l00454"></a>00454   }
<a name="l00455"></a>00455   
<a name="l00456"></a>00456   <span class="comment">/* not enough data to construct a page and not end of stream */</span>
<a name="l00457"></a>00457   <span class="keywordflow">return</span>(0);
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="keywordtype">int</span> ogg_stream_eos(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os){
<a name="l00461"></a>00461   <span class="keywordflow">return</span> os-&gt;e_o_s;
<a name="l00462"></a>00462 }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="comment">/* DECODING PRIMITIVES: packet streaming layer **********************/</span>
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 <span class="comment">/* This has two layers to place more of the multi-serialno and paging</span>
<a name="l00467"></a>00467 <span class="comment">   control in the application&#39;s hands.  First, we expose a data buffer</span>
<a name="l00468"></a>00468 <span class="comment">   using ogg_sync_buffer().  The app either copies into the</span>
<a name="l00469"></a>00469 <span class="comment">   buffer, or passes it directly to read(), etc.  We then call</span>
<a name="l00470"></a>00470 <span class="comment">   ogg_sync_wrote() to tell how many bytes we just added.</span>
<a name="l00471"></a>00471 <span class="comment"></span>
<a name="l00472"></a>00472 <span class="comment">   Pages are returned (pointers into the buffer in ogg_sync_state)</span>
<a name="l00473"></a>00473 <span class="comment">   by ogg_sync_pageout().  The page is then submitted to</span>
<a name="l00474"></a>00474 <span class="comment">   ogg_stream_pagein() along with the appropriate</span>
<a name="l00475"></a>00475 <span class="comment">   ogg_stream_state* (ie, matching serialno).  We then get raw</span>
<a name="l00476"></a>00476 <span class="comment">   packets out calling ogg_stream_packetout() with a</span>
<a name="l00477"></a>00477 <span class="comment">   ogg_stream_state.  See the &#39;frame-prog.txt&#39; docs for details and</span>
<a name="l00478"></a>00478 <span class="comment">   example code. */</span>
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 <span class="comment">/* initialize the struct to a known state */</span>
<a name="l00481"></a>00481 <span class="keywordtype">int</span> ogg_sync_init(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy){
<a name="l00482"></a>00482   <span class="keywordflow">if</span>(oy){
<a name="l00483"></a>00483     memset(oy,0,<span class="keyword">sizeof</span>(*oy));
<a name="l00484"></a>00484   }
<a name="l00485"></a>00485   <span class="keywordflow">return</span>(0);
<a name="l00486"></a>00486 }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="comment">/* clear non-flat storage within */</span>
<a name="l00490"></a>00490 <span class="keywordtype">int</span> ogg_sync_clear(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy){
<a name="l00491"></a>00491   <span class="keywordflow">if</span>(oy){
<a name="l00492"></a>00492     <span class="keywordflow">if</span>(oy-&gt;data)_ogg_free(oy-&gt;data);
<a name="l00493"></a>00493     ogg_sync_init(oy);
<a name="l00494"></a>00494   }
<a name="l00495"></a>00495   <span class="keywordflow">return</span>(0);
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 <span class="keywordtype">int</span> ogg_sync_destroy(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy){
<a name="l00499"></a>00499   <span class="keywordflow">if</span>(oy){
<a name="l00500"></a>00500     ogg_sync_clear(oy);
<a name="l00501"></a>00501     _ogg_free(oy);
<a name="l00502"></a>00502   }
<a name="l00503"></a>00503   <span class="keywordflow">return</span>(0);
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="keywordtype">char</span> *ogg_sync_buffer(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy, <span class="keywordtype">long</span> size){
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   <span class="comment">/* first, clear out any space that has been previously returned */</span>
<a name="l00509"></a>00509   <span class="keywordflow">if</span>(oy-&gt;returned){
<a name="l00510"></a>00510     oy-&gt;fill-=oy-&gt;returned;
<a name="l00511"></a>00511     <span class="keywordflow">if</span>(oy-&gt;fill&gt;0)
<a name="l00512"></a>00512       memmove(oy-&gt;data,oy-&gt;data+oy-&gt;returned,oy-&gt;fill);
<a name="l00513"></a>00513     oy-&gt;returned=0;
<a name="l00514"></a>00514   }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="keywordflow">if</span>(size&gt;oy-&gt;storage-oy-&gt;fill){
<a name="l00517"></a>00517     <span class="comment">/* We need to extend the internal buffer */</span>
<a name="l00518"></a>00518     <span class="keywordtype">long</span> newsize=size+oy-&gt;fill+4096; <span class="comment">/* an extra page to be nice */</span>
<a name="l00519"></a>00519 
<a name="l00520"></a>00520     <span class="keywordflow">if</span>(oy-&gt;data)
<a name="l00521"></a>00521       oy-&gt;data=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)_ogg_realloc(oy-&gt;data,newsize);
<a name="l00522"></a>00522     <span class="keywordflow">else</span>
<a name="l00523"></a>00523       oy-&gt;data=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)_ogg_malloc(newsize);
<a name="l00524"></a>00524     oy-&gt;storage=newsize;
<a name="l00525"></a>00525   }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527   <span class="comment">/* expose a segment at least as large as requested at the fill mark */</span>
<a name="l00528"></a>00528   <span class="keywordflow">return</span>((<span class="keywordtype">char</span> *)oy-&gt;data+oy-&gt;fill);
<a name="l00529"></a>00529 }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 <span class="keywordtype">int</span> ogg_sync_wrote(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy, <span class="keywordtype">long</span> bytes){
<a name="l00532"></a>00532   <span class="keywordflow">if</span>(oy-&gt;fill+bytes&gt;oy-&gt;storage)<span class="keywordflow">return</span>(-1);
<a name="l00533"></a>00533   oy-&gt;fill+=bytes;
<a name="l00534"></a>00534   <span class="keywordflow">return</span>(0);
<a name="l00535"></a>00535 }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="comment">/* sync the stream.  This is meant to be useful for finding page</span>
<a name="l00538"></a>00538 <span class="comment">   boundaries.</span>
<a name="l00539"></a>00539 <span class="comment"></span>
<a name="l00540"></a>00540 <span class="comment">   return values for this:</span>
<a name="l00541"></a>00541 <span class="comment">  -n) skipped n bytes</span>
<a name="l00542"></a>00542 <span class="comment">   0) page not ready; more data (no bytes skipped)</span>
<a name="l00543"></a>00543 <span class="comment">   n) page synced at current location; page length n bytes</span>
<a name="l00544"></a>00544 <span class="comment">   </span>
<a name="l00545"></a>00545 <span class="comment">*/</span>
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="keywordtype">long</span> ogg_sync_pageseek(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy,<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00548"></a>00548   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *page=oy-&gt;data+oy-&gt;returned;
<a name="l00549"></a>00549   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *next;
<a name="l00550"></a>00550   <span class="keywordtype">long</span> bytes=oy-&gt;fill-oy-&gt;returned;
<a name="l00551"></a>00551   
<a name="l00552"></a>00552   <span class="keywordflow">if</span>(oy-&gt;headerbytes==0){
<a name="l00553"></a>00553     <span class="keywordtype">int</span> headerbytes,i;
<a name="l00554"></a>00554     <span class="keywordflow">if</span>(bytes&lt;27)<span class="keywordflow">return</span>(0); <span class="comment">/* not enough for a header */</span>
<a name="l00555"></a>00555     
<a name="l00556"></a>00556     <span class="comment">/* verify capture pattern */</span>
<a name="l00557"></a>00557     <span class="keywordflow">if</span>(memcmp(page,<span class="stringliteral">&quot;OggS&quot;</span>,4))<span class="keywordflow">goto</span> sync_fail;
<a name="l00558"></a>00558     
<a name="l00559"></a>00559     headerbytes=page[26]+27;
<a name="l00560"></a>00560     <span class="keywordflow">if</span>(bytes&lt;headerbytes)<span class="keywordflow">return</span>(0); <span class="comment">/* not enough for header + seg table */</span>
<a name="l00561"></a>00561     
<a name="l00562"></a>00562     <span class="comment">/* count up body length in the segment table */</span>
<a name="l00563"></a>00563     
<a name="l00564"></a>00564     <span class="keywordflow">for</span>(i=0;i&lt;page[26];i++)
<a name="l00565"></a>00565       oy-&gt;bodybytes+=page[27+i];
<a name="l00566"></a>00566     oy-&gt;headerbytes=headerbytes;
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568   
<a name="l00569"></a>00569   <span class="keywordflow">if</span>(oy-&gt;bodybytes+oy-&gt;headerbytes&gt;bytes)<span class="keywordflow">return</span>(0);
<a name="l00570"></a>00570   
<a name="l00571"></a>00571   <span class="comment">/* The whole test page is buffered.  Verify the checksum */</span>
<a name="l00572"></a>00572   {
<a name="l00573"></a>00573     <span class="comment">/* Grab the checksum bytes, set the header field to zero */</span>
<a name="l00574"></a>00574     <span class="keywordtype">char</span> chksum[4];
<a name="l00575"></a>00575     <a class="code" href="structogg__page.html">ogg_page</a> log;
<a name="l00576"></a>00576     
<a name="l00577"></a>00577     memcpy(chksum,page+22,4);
<a name="l00578"></a>00578     memset(page+22,0,4);
<a name="l00579"></a>00579     
<a name="l00580"></a>00580     <span class="comment">/* set up a temp page struct and recompute the checksum */</span>
<a name="l00581"></a>00581     log.header=page;
<a name="l00582"></a>00582     log.header_len=oy-&gt;headerbytes;
<a name="l00583"></a>00583     log.body=page+oy-&gt;headerbytes;
<a name="l00584"></a>00584     log.body_len=oy-&gt;bodybytes;
<a name="l00585"></a>00585     ogg_page_checksum_set(&amp;log);
<a name="l00586"></a>00586     
<a name="l00587"></a>00587     <span class="comment">/* Compare */</span>
<a name="l00588"></a>00588     <span class="keywordflow">if</span>(memcmp(chksum,page+22,4)){
<a name="l00589"></a>00589       <span class="comment">/* D&#39;oh.  Mismatch! Corrupt page (or miscapture and not a page</span>
<a name="l00590"></a>00590 <span class="comment">         at all) */</span>
<a name="l00591"></a>00591       <span class="comment">/* replace the computed checksum with the one actually read in */</span>
<a name="l00592"></a>00592       memcpy(page+22,chksum,4);
<a name="l00593"></a>00593       
<a name="l00594"></a>00594       <span class="comment">/* Bad checksum. Lose sync */</span>
<a name="l00595"></a>00595       <span class="keywordflow">goto</span> sync_fail;
<a name="l00596"></a>00596     }
<a name="l00597"></a>00597   }
<a name="l00598"></a>00598   
<a name="l00599"></a>00599   <span class="comment">/* yes, have a whole page all ready to go */</span>
<a name="l00600"></a>00600   {
<a name="l00601"></a>00601     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *page=oy-&gt;data+oy-&gt;returned;
<a name="l00602"></a>00602     <span class="keywordtype">long</span> bytes;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="keywordflow">if</span>(og){
<a name="l00605"></a>00605       og-&gt;header=page;
<a name="l00606"></a>00606       og-&gt;header_len=oy-&gt;headerbytes;
<a name="l00607"></a>00607       og-&gt;body=page+oy-&gt;headerbytes;
<a name="l00608"></a>00608       og-&gt;body_len=oy-&gt;bodybytes;
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     oy-&gt;unsynced=0;
<a name="l00612"></a>00612     oy-&gt;returned+=(bytes=oy-&gt;headerbytes+oy-&gt;bodybytes);
<a name="l00613"></a>00613     oy-&gt;headerbytes=0;
<a name="l00614"></a>00614     oy-&gt;bodybytes=0;
<a name="l00615"></a>00615     <span class="keywordflow">return</span>(bytes);
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617   
<a name="l00618"></a>00618  sync_fail:
<a name="l00619"></a>00619   
<a name="l00620"></a>00620   oy-&gt;headerbytes=0;
<a name="l00621"></a>00621   oy-&gt;bodybytes=0;
<a name="l00622"></a>00622   
<a name="l00623"></a>00623   <span class="comment">/* search for possible capture */</span>
<a name="l00624"></a>00624   next=(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)memchr(page+1,<span class="charliteral">&#39;O&#39;</span>,bytes-1);
<a name="l00625"></a>00625   <span class="keywordflow">if</span>(!next)
<a name="l00626"></a>00626     next=oy-&gt;data+oy-&gt;fill;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628   oy-&gt;returned=next-oy-&gt;data;
<a name="l00629"></a>00629   <span class="keywordflow">return</span>(-(next-page));
<a name="l00630"></a>00630 }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="comment">/* sync the stream and get a page.  Keep trying until we find a page.</span>
<a name="l00633"></a>00633 <span class="comment">   Supress &#39;sync errors&#39; after reporting the first.</span>
<a name="l00634"></a>00634 <span class="comment"></span>
<a name="l00635"></a>00635 <span class="comment">   return values:</span>
<a name="l00636"></a>00636 <span class="comment">   -1) recapture (hole in data)</span>
<a name="l00637"></a>00637 <span class="comment">    0) need more data</span>
<a name="l00638"></a>00638 <span class="comment">    1) page returned</span>
<a name="l00639"></a>00639 <span class="comment"></span>
<a name="l00640"></a>00640 <span class="comment">   Returns pointers into buffered data; invalidated by next call to</span>
<a name="l00641"></a>00641 <span class="comment">   _stream, _clear, _init, or _buffer */</span>
<a name="l00642"></a>00642 
<a name="l00643"></a>00643 <span class="keywordtype">int</span> ogg_sync_pageout(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy, <a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00644"></a>00644 
<a name="l00645"></a>00645   <span class="comment">/* all we need to do is verify a page at the head of the stream</span>
<a name="l00646"></a>00646 <span class="comment">     buffer.  If it doesn&#39;t verify, we look for the next potential</span>
<a name="l00647"></a>00647 <span class="comment">     frame */</span>
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   <span class="keywordflow">while</span>(1){
<a name="l00650"></a>00650     <span class="keywordtype">long</span> ret=ogg_sync_pageseek(oy,og);
<a name="l00651"></a>00651     <span class="keywordflow">if</span>(ret&gt;0){
<a name="l00652"></a>00652       <span class="comment">/* have a page */</span>
<a name="l00653"></a>00653       <span class="keywordflow">return</span>(1);
<a name="l00654"></a>00654     }
<a name="l00655"></a>00655     <span class="keywordflow">if</span>(ret==0){
<a name="l00656"></a>00656       <span class="comment">/* need more data */</span>
<a name="l00657"></a>00657       <span class="keywordflow">return</span>(0);
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659     
<a name="l00660"></a>00660     <span class="comment">/* head did not start a synced page... skipped some bytes */</span>
<a name="l00661"></a>00661     <span class="keywordflow">if</span>(!oy-&gt;unsynced){
<a name="l00662"></a>00662       oy-&gt;unsynced=1;
<a name="l00663"></a>00663       <span class="keywordflow">return</span>(-1);
<a name="l00664"></a>00664     }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666     <span class="comment">/* loop. keep looking */</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   }
<a name="l00669"></a>00669 }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 <span class="comment">/* add the incoming page to the stream state; we decompose the page</span>
<a name="l00672"></a>00672 <span class="comment">   into packet segments here as well. */</span>
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="keywordtype">int</span> ogg_stream_pagein(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os, <a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00675"></a>00675   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *header=og-&gt;header;
<a name="l00676"></a>00676   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *body=og-&gt;body;
<a name="l00677"></a>00677   <span class="keywordtype">long</span>           bodysize=og-&gt;body_len;
<a name="l00678"></a>00678   <span class="keywordtype">int</span>            segptr=0;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="keywordtype">int</span> version=ogg_page_version(og);
<a name="l00681"></a>00681   <span class="keywordtype">int</span> continued=ogg_page_continued(og);
<a name="l00682"></a>00682   <span class="keywordtype">int</span> bos=ogg_page_bos(og);
<a name="l00683"></a>00683   <span class="keywordtype">int</span> eos=ogg_page_eos(og);
<a name="l00684"></a>00684   ogg_int64_t granulepos=ogg_page_granulepos(og);
<a name="l00685"></a>00685   <span class="keywordtype">int</span> serialno=ogg_page_serialno(og);
<a name="l00686"></a>00686   <span class="keywordtype">long</span> pageno=ogg_page_pageno(og);
<a name="l00687"></a>00687   <span class="keywordtype">int</span> segments=header[26];
<a name="l00688"></a>00688   
<a name="l00689"></a>00689   <span class="comment">/* clean up &#39;returned data&#39; */</span>
<a name="l00690"></a>00690   {
<a name="l00691"></a>00691     <span class="keywordtype">long</span> lr=os-&gt;lacing_returned;
<a name="l00692"></a>00692     <span class="keywordtype">long</span> br=os-&gt;body_returned;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     <span class="comment">/* body data */</span>
<a name="l00695"></a>00695     <span class="keywordflow">if</span>(br){
<a name="l00696"></a>00696       os-&gt;body_fill-=br;
<a name="l00697"></a>00697       <span class="keywordflow">if</span>(os-&gt;body_fill)
<a name="l00698"></a>00698         memmove(os-&gt;body_data,os-&gt;body_data+br,os-&gt;body_fill);
<a name="l00699"></a>00699       os-&gt;body_returned=0;
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     <span class="keywordflow">if</span>(lr){
<a name="l00703"></a>00703       <span class="comment">/* segment table */</span>
<a name="l00704"></a>00704       <span class="keywordflow">if</span>(os-&gt;lacing_fill-lr){
<a name="l00705"></a>00705         memmove(os-&gt;lacing_vals,os-&gt;lacing_vals+lr,
<a name="l00706"></a>00706                 (os-&gt;lacing_fill-lr)*<span class="keyword">sizeof</span>(*os-&gt;lacing_vals));
<a name="l00707"></a>00707         memmove(os-&gt;granule_vals,os-&gt;granule_vals+lr,
<a name="l00708"></a>00708                 (os-&gt;lacing_fill-lr)*<span class="keyword">sizeof</span>(*os-&gt;granule_vals));
<a name="l00709"></a>00709       }
<a name="l00710"></a>00710       os-&gt;lacing_fill-=lr;
<a name="l00711"></a>00711       os-&gt;lacing_packet-=lr;
<a name="l00712"></a>00712       os-&gt;lacing_returned=0;
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714   }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="comment">/* check the serial number */</span>
<a name="l00717"></a>00717   <span class="keywordflow">if</span>(serialno!=os-&gt;serialno)<span class="keywordflow">return</span>(-1);
<a name="l00718"></a>00718   <span class="keywordflow">if</span>(version&gt;0)<span class="keywordflow">return</span>(-1);
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   _os_lacing_expand(os,segments+1);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <span class="comment">/* are we in sequence? */</span>
<a name="l00723"></a>00723   <span class="keywordflow">if</span>(pageno!=os-&gt;pageno){
<a name="l00724"></a>00724     <span class="keywordtype">int</span> i;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     <span class="comment">/* unroll previous partial packet (if any) */</span>
<a name="l00727"></a>00727     <span class="keywordflow">for</span>(i=os-&gt;lacing_packet;i&lt;os-&gt;lacing_fill;i++)
<a name="l00728"></a>00728       os-&gt;body_fill-=os-&gt;lacing_vals[i]&amp;0xff;
<a name="l00729"></a>00729     os-&gt;lacing_fill=os-&gt;lacing_packet;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     <span class="comment">/* make a note of dropped data in segment table */</span>
<a name="l00732"></a>00732     <span class="keywordflow">if</span>(os-&gt;pageno!=-1){
<a name="l00733"></a>00733       os-&gt;lacing_vals[os-&gt;lacing_fill++]=0x400;
<a name="l00734"></a>00734       os-&gt;lacing_packet++;
<a name="l00735"></a>00735     }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="comment">/* are we a &#39;continued packet&#39; page?  If so, we&#39;ll need to skip</span>
<a name="l00738"></a>00738 <span class="comment">       some segments */</span>
<a name="l00739"></a>00739     <span class="keywordflow">if</span>(continued){
<a name="l00740"></a>00740       bos=0;
<a name="l00741"></a>00741       <span class="keywordflow">for</span>(;segptr&lt;segments;segptr++){
<a name="l00742"></a>00742         <span class="keywordtype">int</span> val=header[27+segptr];
<a name="l00743"></a>00743         body+=val;
<a name="l00744"></a>00744         bodysize-=val;
<a name="l00745"></a>00745         <span class="keywordflow">if</span>(val&lt;255){
<a name="l00746"></a>00746           segptr++;
<a name="l00747"></a>00747           <span class="keywordflow">break</span>;
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749       }
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751   }
<a name="l00752"></a>00752   
<a name="l00753"></a>00753   <span class="keywordflow">if</span>(bodysize){
<a name="l00754"></a>00754     _os_body_expand(os,bodysize);
<a name="l00755"></a>00755     memcpy(os-&gt;body_data+os-&gt;body_fill,body,bodysize);
<a name="l00756"></a>00756     os-&gt;body_fill+=bodysize;
<a name="l00757"></a>00757   }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759   {
<a name="l00760"></a>00760     <span class="keywordtype">int</span> saved=-1;
<a name="l00761"></a>00761     <span class="keywordflow">while</span>(segptr&lt;segments){
<a name="l00762"></a>00762       <span class="keywordtype">int</span> val=header[27+segptr];
<a name="l00763"></a>00763       os-&gt;lacing_vals[os-&gt;lacing_fill]=val;
<a name="l00764"></a>00764       os-&gt;granule_vals[os-&gt;lacing_fill]=-1;
<a name="l00765"></a>00765       
<a name="l00766"></a>00766       <span class="keywordflow">if</span>(bos){
<a name="l00767"></a>00767         os-&gt;lacing_vals[os-&gt;lacing_fill]|=0x100;
<a name="l00768"></a>00768         bos=0;
<a name="l00769"></a>00769       }
<a name="l00770"></a>00770       
<a name="l00771"></a>00771       <span class="keywordflow">if</span>(val&lt;255)saved=os-&gt;lacing_fill;
<a name="l00772"></a>00772       
<a name="l00773"></a>00773       os-&gt;lacing_fill++;
<a name="l00774"></a>00774       segptr++;
<a name="l00775"></a>00775       
<a name="l00776"></a>00776       <span class="keywordflow">if</span>(val&lt;255)os-&gt;lacing_packet=os-&gt;lacing_fill;
<a name="l00777"></a>00777     }
<a name="l00778"></a>00778   
<a name="l00779"></a>00779     <span class="comment">/* set the granulepos on the last granuleval of the last full packet */</span>
<a name="l00780"></a>00780     <span class="keywordflow">if</span>(saved!=-1){
<a name="l00781"></a>00781       os-&gt;granule_vals[saved]=granulepos;
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784   }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   <span class="keywordflow">if</span>(eos){
<a name="l00787"></a>00787     os-&gt;e_o_s=1;
<a name="l00788"></a>00788     <span class="keywordflow">if</span>(os-&gt;lacing_fill&gt;0)
<a name="l00789"></a>00789       os-&gt;lacing_vals[os-&gt;lacing_fill-1]|=0x200;
<a name="l00790"></a>00790   }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792   os-&gt;pageno=pageno+1;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="keywordflow">return</span>(0);
<a name="l00795"></a>00795 }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="comment">/* clear things to an initial state.  Good to call, eg, before seeking */</span>
<a name="l00798"></a>00798 <span class="keywordtype">int</span> ogg_sync_reset(<a class="code" href="structogg__sync__state.html">ogg_sync_state</a> *oy){
<a name="l00799"></a>00799   oy-&gt;fill=0;
<a name="l00800"></a>00800   oy-&gt;returned=0;
<a name="l00801"></a>00801   oy-&gt;unsynced=0;
<a name="l00802"></a>00802   oy-&gt;headerbytes=0;
<a name="l00803"></a>00803   oy-&gt;bodybytes=0;
<a name="l00804"></a>00804   <span class="keywordflow">return</span>(0);
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="keywordtype">int</span> ogg_stream_reset(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os){
<a name="l00808"></a>00808   os-&gt;body_fill=0;
<a name="l00809"></a>00809   os-&gt;body_returned=0;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811   os-&gt;lacing_fill=0;
<a name="l00812"></a>00812   os-&gt;lacing_packet=0;
<a name="l00813"></a>00813   os-&gt;lacing_returned=0;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   os-&gt;header_fill=0;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817   os-&gt;e_o_s=0;
<a name="l00818"></a>00818   os-&gt;b_o_s=0;
<a name="l00819"></a>00819   os-&gt;pageno=-1;
<a name="l00820"></a>00820   os-&gt;packetno=0;
<a name="l00821"></a>00821   os-&gt;granulepos=0;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="keywordflow">return</span>(0);
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="keywordtype">int</span> ogg_stream_reset_serialno(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<span class="keywordtype">int</span> serialno){
<a name="l00827"></a>00827   ogg_stream_reset(os);
<a name="l00828"></a>00828   os-&gt;serialno=serialno;
<a name="l00829"></a>00829   <span class="keywordflow">return</span>(0);
<a name="l00830"></a>00830 }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="keyword">static</span> <span class="keywordtype">int</span> _packetout(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<a class="code" href="structogg__packet.html">ogg_packet</a> *op,<span class="keywordtype">int</span> adv){
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="comment">/* The last part of decode. We have the stream broken into packet</span>
<a name="l00835"></a>00835 <span class="comment">     segments.  Now we need to group them into packets (or return the</span>
<a name="l00836"></a>00836 <span class="comment">     out of sync markers) */</span>
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <span class="keywordtype">int</span> ptr=os-&gt;lacing_returned;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="keywordflow">if</span>(os-&gt;lacing_packet&lt;=ptr)<span class="keywordflow">return</span>(0);
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="keywordflow">if</span>(os-&gt;lacing_vals[ptr]&amp;0x400){
<a name="l00843"></a>00843     <span class="comment">/* we need to tell the codec there&#39;s a gap; it might need to</span>
<a name="l00844"></a>00844 <span class="comment">       handle previous packet dependencies. */</span>
<a name="l00845"></a>00845     os-&gt;lacing_returned++;
<a name="l00846"></a>00846     os-&gt;packetno++;
<a name="l00847"></a>00847     <span class="keywordflow">return</span>(-1);
<a name="l00848"></a>00848   }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850   <span class="keywordflow">if</span>(!op &amp;&amp; !adv)<span class="keywordflow">return</span>(1); <span class="comment">/* just using peek as an inexpensive way</span>
<a name="l00851"></a>00851 <span class="comment">                               to ask if there&#39;s a whole packet</span>
<a name="l00852"></a>00852 <span class="comment">                               waiting */</span>
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <span class="comment">/* Gather the whole packet. We&#39;ll have no holes or a partial packet */</span>
<a name="l00855"></a>00855   {
<a name="l00856"></a>00856     <span class="keywordtype">int</span> size=os-&gt;lacing_vals[ptr]&amp;0xff;
<a name="l00857"></a>00857     <span class="keywordtype">int</span> bytes=size;
<a name="l00858"></a>00858     <span class="keywordtype">int</span> eos=os-&gt;lacing_vals[ptr]&amp;0x200; <span class="comment">/* last packet of the stream? */</span>
<a name="l00859"></a>00859     <span class="keywordtype">int</span> bos=os-&gt;lacing_vals[ptr]&amp;0x100; <span class="comment">/* first packet of the stream? */</span>
<a name="l00860"></a>00860 
<a name="l00861"></a>00861     <span class="keywordflow">while</span>(size==255){
<a name="l00862"></a>00862       <span class="keywordtype">int</span> val=os-&gt;lacing_vals[++ptr];
<a name="l00863"></a>00863       size=val&amp;0xff;
<a name="l00864"></a>00864       <span class="keywordflow">if</span>(val&amp;0x200)eos=0x200;
<a name="l00865"></a>00865       bytes+=size;
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867 
<a name="l00868"></a>00868     <span class="keywordflow">if</span>(op){
<a name="l00869"></a>00869       op-&gt;e_o_s=eos;
<a name="l00870"></a>00870       op-&gt;b_o_s=bos;
<a name="l00871"></a>00871       op-&gt;packet=os-&gt;body_data+os-&gt;body_returned;
<a name="l00872"></a>00872       op-&gt;packetno=os-&gt;packetno;
<a name="l00873"></a>00873       op-&gt;granulepos=os-&gt;granule_vals[ptr];
<a name="l00874"></a>00874       op-&gt;bytes=bytes;
<a name="l00875"></a>00875     }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877     <span class="keywordflow">if</span>(adv){
<a name="l00878"></a>00878       os-&gt;body_returned+=bytes;
<a name="l00879"></a>00879       os-&gt;lacing_returned=ptr+1;
<a name="l00880"></a>00880       os-&gt;packetno++;
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882   }
<a name="l00883"></a>00883   <span class="keywordflow">return</span>(1);
<a name="l00884"></a>00884 }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="keywordtype">int</span> ogg_stream_packetout(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<a class="code" href="structogg__packet.html">ogg_packet</a> *op){
<a name="l00887"></a>00887   <span class="keywordflow">return</span> _packetout(os,op,1);
<a name="l00888"></a>00888 }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890 <span class="keywordtype">int</span> ogg_stream_packetpeek(<a class="code" href="structogg__stream__state.html">ogg_stream_state</a> *os,<a class="code" href="structogg__packet.html">ogg_packet</a> *op){
<a name="l00891"></a>00891   <span class="keywordflow">return</span> _packetout(os,op,0);
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 <span class="keywordtype">void</span> ogg_packet_clear(<a class="code" href="structogg__packet.html">ogg_packet</a> *op) {
<a name="l00895"></a>00895   _ogg_free(op-&gt;packet);
<a name="l00896"></a>00896   memset(op, 0, <span class="keyword">sizeof</span>(*op));
<a name="l00897"></a>00897 }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 <span class="preprocessor">#ifdef _V_SELFTEST</span>
<a name="l00900"></a>00900 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <a class="code" href="structogg__stream__state.html">ogg_stream_state</a> os_en, os_de;
<a name="l00903"></a>00903 <a class="code" href="structogg__sync__state.html">ogg_sync_state</a> oy;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keywordtype">void</span> checkpacket(<a class="code" href="structogg__packet.html">ogg_packet</a> *op,<span class="keywordtype">int</span> len, <span class="keywordtype">int</span> no, <span class="keywordtype">int</span> pos){
<a name="l00906"></a>00906   <span class="keywordtype">long</span> j;
<a name="l00907"></a>00907   <span class="keywordtype">int</span> sequence=0;
<a name="l00908"></a>00908   <span class="keywordtype">int</span> lastno=0;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <span class="keywordflow">if</span>(op-&gt;bytes!=len){
<a name="l00911"></a>00911     fprintf(stderr,<span class="stringliteral">&quot;incorrect packet length!\n&quot;</span>);
<a name="l00912"></a>00912     exit(1);
<a name="l00913"></a>00913   }
<a name="l00914"></a>00914   <span class="keywordflow">if</span>(op-&gt;granulepos!=pos){
<a name="l00915"></a>00915     fprintf(stderr,<span class="stringliteral">&quot;incorrect packet position!\n&quot;</span>);
<a name="l00916"></a>00916     exit(1);
<a name="l00917"></a>00917   }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="comment">/* packet number just follows sequence/gap; adjust the input number</span>
<a name="l00920"></a>00920 <span class="comment">     for that */</span>
<a name="l00921"></a>00921   <span class="keywordflow">if</span>(no==0){
<a name="l00922"></a>00922     sequence=0;
<a name="l00923"></a>00923   }<span class="keywordflow">else</span>{
<a name="l00924"></a>00924     sequence++;
<a name="l00925"></a>00925     <span class="keywordflow">if</span>(no&gt;lastno+1)
<a name="l00926"></a>00926       sequence++;
<a name="l00927"></a>00927   }
<a name="l00928"></a>00928   lastno=no;
<a name="l00929"></a>00929   <span class="keywordflow">if</span>(op-&gt;packetno!=sequence){
<a name="l00930"></a>00930     fprintf(stderr,<span class="stringliteral">&quot;incorrect packet sequence %ld != %d\n&quot;</span>,
<a name="l00931"></a>00931             (<span class="keywordtype">long</span>)(op-&gt;packetno),sequence);
<a name="l00932"></a>00932     exit(1);
<a name="l00933"></a>00933   }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935   <span class="comment">/* Test data */</span>
<a name="l00936"></a>00936   <span class="keywordflow">for</span>(j=0;j&lt;op-&gt;bytes;j++)
<a name="l00937"></a>00937     <span class="keywordflow">if</span>(op-&gt;packet[j]!=((j+no)&amp;0xff)){
<a name="l00938"></a>00938       fprintf(stderr,<span class="stringliteral">&quot;body data mismatch (1) at pos %ld: %x!=%lx!\n\n&quot;</span>,
<a name="l00939"></a>00939               j,op-&gt;packet[j],(j+no)&amp;0xff);
<a name="l00940"></a>00940       exit(1);
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942 }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944 <span class="keywordtype">void</span> check_page(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data,<span class="keyword">const</span> <span class="keywordtype">int</span> *header,<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00945"></a>00945   <span class="keywordtype">long</span> j;
<a name="l00946"></a>00946   <span class="comment">/* Test data */</span>
<a name="l00947"></a>00947   <span class="keywordflow">for</span>(j=0;j&lt;og-&gt;body_len;j++)
<a name="l00948"></a>00948     <span class="keywordflow">if</span>(og-&gt;body[j]!=data[j]){
<a name="l00949"></a>00949       fprintf(stderr,<span class="stringliteral">&quot;body data mismatch (2) at pos %ld: %x!=%x!\n\n&quot;</span>,
<a name="l00950"></a>00950               j,data[j],og-&gt;body[j]);
<a name="l00951"></a>00951       exit(1);
<a name="l00952"></a>00952     }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   <span class="comment">/* Test header */</span>
<a name="l00955"></a>00955   <span class="keywordflow">for</span>(j=0;j&lt;og-&gt;header_len;j++){
<a name="l00956"></a>00956     <span class="keywordflow">if</span>(og-&gt;header[j]!=header[j]){
<a name="l00957"></a>00957       fprintf(stderr,<span class="stringliteral">&quot;header content mismatch at pos %ld:\n&quot;</span>,j);
<a name="l00958"></a>00958       <span class="keywordflow">for</span>(j=0;j&lt;header[26]+27;j++)
<a name="l00959"></a>00959         fprintf(stderr,<span class="stringliteral">&quot; (%ld)%02x:%02x&quot;</span>,j,header[j],og-&gt;header[j]);
<a name="l00960"></a>00960       fprintf(stderr,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00961"></a>00961       exit(1);
<a name="l00962"></a>00962     }
<a name="l00963"></a>00963   }
<a name="l00964"></a>00964   <span class="keywordflow">if</span>(og-&gt;header_len!=header[26]+27){
<a name="l00965"></a>00965     fprintf(stderr,<span class="stringliteral">&quot;header length incorrect! (%ld!=%d)\n&quot;</span>,
<a name="l00966"></a>00966             og-&gt;header_len,header[26]+27);
<a name="l00967"></a>00967     exit(1);
<a name="l00968"></a>00968   }
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keywordtype">void</span> print_header(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00972"></a>00972   <span class="keywordtype">int</span> j;
<a name="l00973"></a>00973   fprintf(stderr,<span class="stringliteral">&quot;\nHEADER:\n&quot;</span>);
<a name="l00974"></a>00974   fprintf(stderr,<span class="stringliteral">&quot;  capture: %c %c %c %c  version: %d  flags: %x\n&quot;</span>,
<a name="l00975"></a>00975           og-&gt;header[0],og-&gt;header[1],og-&gt;header[2],og-&gt;header[3],
<a name="l00976"></a>00976           (<span class="keywordtype">int</span>)og-&gt;header[4],(<span class="keywordtype">int</span>)og-&gt;header[5]);
<a name="l00977"></a>00977 
<a name="l00978"></a>00978   fprintf(stderr,<span class="stringliteral">&quot;  granulepos: %d  serialno: %d  pageno: %ld\n&quot;</span>,
<a name="l00979"></a>00979           (og-&gt;header[9]&lt;&lt;24)|(og-&gt;header[8]&lt;&lt;16)|
<a name="l00980"></a>00980           (og-&gt;header[7]&lt;&lt;8)|og-&gt;header[6],
<a name="l00981"></a>00981           (og-&gt;header[17]&lt;&lt;24)|(og-&gt;header[16]&lt;&lt;16)|
<a name="l00982"></a>00982           (og-&gt;header[15]&lt;&lt;8)|og-&gt;header[14],
<a name="l00983"></a>00983           ((<span class="keywordtype">long</span>)(og-&gt;header[21])&lt;&lt;24)|(og-&gt;header[20]&lt;&lt;16)|
<a name="l00984"></a>00984           (og-&gt;header[19]&lt;&lt;8)|og-&gt;header[18]);
<a name="l00985"></a>00985 
<a name="l00986"></a>00986   fprintf(stderr,<span class="stringliteral">&quot;  checksum: %02x:%02x:%02x:%02x\n  segments: %d (&quot;</span>,
<a name="l00987"></a>00987           (<span class="keywordtype">int</span>)og-&gt;header[22],(<span class="keywordtype">int</span>)og-&gt;header[23],
<a name="l00988"></a>00988           (<span class="keywordtype">int</span>)og-&gt;header[24],(<span class="keywordtype">int</span>)og-&gt;header[25],
<a name="l00989"></a>00989           (<span class="keywordtype">int</span>)og-&gt;header[26]);
<a name="l00990"></a>00990 
<a name="l00991"></a>00991   <span class="keywordflow">for</span>(j=27;j&lt;og-&gt;header_len;j++)
<a name="l00992"></a>00992     fprintf(stderr,<span class="stringliteral">&quot;%d &quot;</span>,(<span class="keywordtype">int</span>)og-&gt;header[j]);
<a name="l00993"></a>00993   fprintf(stderr,<span class="stringliteral">&quot;)\n\n&quot;</span>);
<a name="l00994"></a>00994 }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 <span class="keywordtype">void</span> copy_page(<a class="code" href="structogg__page.html">ogg_page</a> *og){
<a name="l00997"></a>00997   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *temp=_ogg_malloc(og-&gt;header_len);
<a name="l00998"></a>00998   memcpy(temp,og-&gt;header,og-&gt;header_len);
<a name="l00999"></a>00999   og-&gt;header=temp;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   temp=_ogg_malloc(og-&gt;body_len);
<a name="l01002"></a>01002   memcpy(temp,og-&gt;body,og-&gt;body_len);
<a name="l01003"></a>01003   og-&gt;body=temp;
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="keywordtype">void</span> error(<span class="keywordtype">void</span>){
<a name="l01007"></a>01007   fprintf(stderr,<span class="stringliteral">&quot;error!\n&quot;</span>);
<a name="l01008"></a>01008   exit(1);
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="comment">/* 17 only */</span>
<a name="l01012"></a>01012 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_0[] = {0x4f,0x67,0x67,0x53,0,0x06,
<a name="l01013"></a>01013                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01014"></a>01014                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01015"></a>01015                        0x15,0xed,0xec,0x91,
<a name="l01016"></a>01016                        1,
<a name="l01017"></a>01017                        17};
<a name="l01018"></a>01018 
<a name="l01019"></a>01019 <span class="comment">/* 17, 254, 255, 256, 500, 510, 600 byte, pad */</span>
<a name="l01020"></a>01020 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_1[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01021"></a>01021                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01022"></a>01022                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01023"></a>01023                        0x59,0x10,0x6c,0x2c,
<a name="l01024"></a>01024                        1,
<a name="l01025"></a>01025                        17};
<a name="l01026"></a>01026 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_1[] = {0x4f,0x67,0x67,0x53,0,0x04,
<a name="l01027"></a>01027                        0x07,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01028"></a>01028                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01029"></a>01029                        0x89,0x33,0x85,0xce,
<a name="l01030"></a>01030                        13,
<a name="l01031"></a>01031                        254,255,0,255,1,255,245,255,255,0,
<a name="l01032"></a>01032                        255,255,90};
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 <span class="comment">/* nil packets; beginning,middle,end */</span>
<a name="l01035"></a>01035 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_2[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01036"></a>01036                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01037"></a>01037                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01038"></a>01038                        0xff,0x7b,0x23,0x17,
<a name="l01039"></a>01039                        1,
<a name="l01040"></a>01040                        0};
<a name="l01041"></a>01041 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_2[] = {0x4f,0x67,0x67,0x53,0,0x04,
<a name="l01042"></a>01042                        0x07,0x28,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01043"></a>01043                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01044"></a>01044                        0x5c,0x3f,0x66,0xcb,
<a name="l01045"></a>01045                        17,
<a name="l01046"></a>01046                        17,254,255,0,0,255,1,0,255,245,255,255,0,
<a name="l01047"></a>01047                        255,255,90,0};
<a name="l01048"></a>01048 
<a name="l01049"></a>01049 <span class="comment">/* large initial packet */</span>
<a name="l01050"></a>01050 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_3[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01051"></a>01051                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01052"></a>01052                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01053"></a>01053                        0x01,0x27,0x31,0xaa,
<a name="l01054"></a>01054                        18,
<a name="l01055"></a>01055                        255,255,255,255,255,255,255,255,
<a name="l01056"></a>01056                        255,255,255,255,255,255,255,255,255,10};
<a name="l01057"></a>01057 
<a name="l01058"></a>01058 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_3[] = {0x4f,0x67,0x67,0x53,0,0x04,
<a name="l01059"></a>01059                        0x07,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01060"></a>01060                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01061"></a>01061                        0x7f,0x4e,0x8a,0xd2,
<a name="l01062"></a>01062                        4,
<a name="l01063"></a>01063                        255,4,255,0};
<a name="l01064"></a>01064 
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 <span class="comment">/* continuing packet test */</span>
<a name="l01067"></a>01067 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_4[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01068"></a>01068                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01069"></a>01069                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01070"></a>01070                        0xff,0x7b,0x23,0x17,
<a name="l01071"></a>01071                        1,
<a name="l01072"></a>01072                        0};
<a name="l01073"></a>01073 
<a name="l01074"></a>01074 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_4[] = {0x4f,0x67,0x67,0x53,0,0x00,
<a name="l01075"></a>01075                        0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01076"></a>01076                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01077"></a>01077                        0x34,0x24,0xd5,0x29,
<a name="l01078"></a>01078                        17,
<a name="l01079"></a>01079                        255,255,255,255,255,255,255,255,
<a name="l01080"></a>01080                        255,255,255,255,255,255,255,255,255};
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 <span class="keyword">const</span> <span class="keywordtype">int</span> head3_4[] = {0x4f,0x67,0x67,0x53,0,0x05,
<a name="l01083"></a>01083                        0x07,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01084"></a>01084                        0x01,0x02,0x03,0x04,2,0,0,0,
<a name="l01085"></a>01085                        0xc8,0xc3,0xcb,0xed,
<a name="l01086"></a>01086                        5,
<a name="l01087"></a>01087                        10,255,4,255,0};
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 <span class="comment">/* page with the 255 segment limit */</span>
<a name="l01091"></a>01091 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_5[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01092"></a>01092                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01093"></a>01093                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01094"></a>01094                        0xff,0x7b,0x23,0x17,
<a name="l01095"></a>01095                        1,
<a name="l01096"></a>01096                        0};
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_5[] = {0x4f,0x67,0x67,0x53,0,0x00,
<a name="l01099"></a>01099                        0x07,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,
<a name="l01100"></a>01100                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01101"></a>01101                        0xed,0x2a,0x2e,0xa7,
<a name="l01102"></a>01102                        255,
<a name="l01103"></a>01103                        10,10,10,10,10,10,10,10,
<a name="l01104"></a>01104                        10,10,10,10,10,10,10,10,
<a name="l01105"></a>01105                        10,10,10,10,10,10,10,10,
<a name="l01106"></a>01106                        10,10,10,10,10,10,10,10,
<a name="l01107"></a>01107                        10,10,10,10,10,10,10,10,
<a name="l01108"></a>01108                        10,10,10,10,10,10,10,10,
<a name="l01109"></a>01109                        10,10,10,10,10,10,10,10,
<a name="l01110"></a>01110                        10,10,10,10,10,10,10,10,
<a name="l01111"></a>01111                        10,10,10,10,10,10,10,10,
<a name="l01112"></a>01112                        10,10,10,10,10,10,10,10,
<a name="l01113"></a>01113                        10,10,10,10,10,10,10,10,
<a name="l01114"></a>01114                        10,10,10,10,10,10,10,10,
<a name="l01115"></a>01115                        10,10,10,10,10,10,10,10,
<a name="l01116"></a>01116                        10,10,10,10,10,10,10,10,
<a name="l01117"></a>01117                        10,10,10,10,10,10,10,10,
<a name="l01118"></a>01118                        10,10,10,10,10,10,10,10,
<a name="l01119"></a>01119                        10,10,10,10,10,10,10,10,
<a name="l01120"></a>01120                        10,10,10,10,10,10,10,10,
<a name="l01121"></a>01121                        10,10,10,10,10,10,10,10,
<a name="l01122"></a>01122                        10,10,10,10,10,10,10,10,
<a name="l01123"></a>01123                        10,10,10,10,10,10,10,10,
<a name="l01124"></a>01124                        10,10,10,10,10,10,10,10,
<a name="l01125"></a>01125                        10,10,10,10,10,10,10,10,
<a name="l01126"></a>01126                        10,10,10,10,10,10,10,10,
<a name="l01127"></a>01127                        10,10,10,10,10,10,10,10,
<a name="l01128"></a>01128                        10,10,10,10,10,10,10,10,
<a name="l01129"></a>01129                        10,10,10,10,10,10,10,10,
<a name="l01130"></a>01130                        10,10,10,10,10,10,10,10,
<a name="l01131"></a>01131                        10,10,10,10,10,10,10,10,
<a name="l01132"></a>01132                        10,10,10,10,10,10,10,10,
<a name="l01133"></a>01133                        10,10,10,10,10,10,10,10,
<a name="l01134"></a>01134                        10,10,10,10,10,10,10};
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="keyword">const</span> <span class="keywordtype">int</span> head3_5[] = {0x4f,0x67,0x67,0x53,0,0x04,
<a name="l01137"></a>01137                        0x07,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
<a name="l01138"></a>01138                        0x01,0x02,0x03,0x04,2,0,0,0,
<a name="l01139"></a>01139                        0x6c,0x3b,0x82,0x3d,
<a name="l01140"></a>01140                        1,
<a name="l01141"></a>01141                        50};
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 
<a name="l01144"></a>01144 <span class="comment">/* packet that overspans over an entire page */</span>
<a name="l01145"></a>01145 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_6[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01146"></a>01146                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01147"></a>01147                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01148"></a>01148                        0xff,0x7b,0x23,0x17,
<a name="l01149"></a>01149                        1,
<a name="l01150"></a>01150                        0};
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_6[] = {0x4f,0x67,0x67,0x53,0,0x00,
<a name="l01153"></a>01153                        0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01154"></a>01154                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01155"></a>01155                        0x3c,0xd9,0x4d,0x3f,
<a name="l01156"></a>01156                        17,
<a name="l01157"></a>01157                        100,255,255,255,255,255,255,255,255,
<a name="l01158"></a>01158                        255,255,255,255,255,255,255,255};
<a name="l01159"></a>01159 
<a name="l01160"></a>01160 <span class="keyword">const</span> <span class="keywordtype">int</span> head3_6[] = {0x4f,0x67,0x67,0x53,0,0x01,
<a name="l01161"></a>01161                        0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01162"></a>01162                        0x01,0x02,0x03,0x04,2,0,0,0,
<a name="l01163"></a>01163                        0xbd,0xd5,0xb5,0x8b,
<a name="l01164"></a>01164                        17,
<a name="l01165"></a>01165                        255,255,255,255,255,255,255,255,
<a name="l01166"></a>01166                        255,255,255,255,255,255,255,255,255};
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="keyword">const</span> <span class="keywordtype">int</span> head4_6[] = {0x4f,0x67,0x67,0x53,0,0x05,
<a name="l01169"></a>01169                        0x07,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01170"></a>01170                        0x01,0x02,0x03,0x04,3,0,0,0,
<a name="l01171"></a>01171                        0xef,0xdd,0x88,0xde,
<a name="l01172"></a>01172                        7,
<a name="l01173"></a>01173                        255,255,75,255,4,255,0};
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 <span class="comment">/* packet that overspans over an entire page */</span>
<a name="l01176"></a>01176 <span class="keyword">const</span> <span class="keywordtype">int</span> head1_7[] = {0x4f,0x67,0x67,0x53,0,0x02,
<a name="l01177"></a>01177                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01178"></a>01178                        0x01,0x02,0x03,0x04,0,0,0,0,
<a name="l01179"></a>01179                        0xff,0x7b,0x23,0x17,
<a name="l01180"></a>01180                        1,
<a name="l01181"></a>01181                        0};
<a name="l01182"></a>01182 
<a name="l01183"></a>01183 <span class="keyword">const</span> <span class="keywordtype">int</span> head2_7[] = {0x4f,0x67,0x67,0x53,0,0x00,
<a name="l01184"></a>01184                        0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01185"></a>01185                        0x01,0x02,0x03,0x04,1,0,0,0,
<a name="l01186"></a>01186                        0x3c,0xd9,0x4d,0x3f,
<a name="l01187"></a>01187                        17,
<a name="l01188"></a>01188                        100,255,255,255,255,255,255,255,255,
<a name="l01189"></a>01189                        255,255,255,255,255,255,255,255};
<a name="l01190"></a>01190 
<a name="l01191"></a>01191 <span class="keyword">const</span> <span class="keywordtype">int</span> head3_7[] = {0x4f,0x67,0x67,0x53,0,0x05,
<a name="l01192"></a>01192                        0x07,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
<a name="l01193"></a>01193                        0x01,0x02,0x03,0x04,2,0,0,0,
<a name="l01194"></a>01194                        0xd4,0xe0,0x60,0xe5,
<a name="l01195"></a>01195                        1,0};
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="keywordtype">void</span> test_pack(<span class="keyword">const</span> <span class="keywordtype">int</span> *pl, <span class="keyword">const</span> <span class="keywordtype">int</span> **headers){
<a name="l01198"></a>01198   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data=_ogg_malloc(1024*1024); <span class="comment">/* for scripted test cases only */</span>
<a name="l01199"></a>01199   <span class="keywordtype">long</span> inptr=0;
<a name="l01200"></a>01200   <span class="keywordtype">long</span> outptr=0;
<a name="l01201"></a>01201   <span class="keywordtype">long</span> deptr=0;
<a name="l01202"></a>01202   <span class="keywordtype">long</span> depacket=0;
<a name="l01203"></a>01203   <span class="keywordtype">long</span> granule_pos=7,pageno=0;
<a name="l01204"></a>01204   <span class="keywordtype">int</span> i,j,packets,pageout=0;
<a name="l01205"></a>01205   <span class="keywordtype">int</span> eosflag=0;
<a name="l01206"></a>01206   <span class="keywordtype">int</span> bosflag=0;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   ogg_stream_reset(&amp;os_en);
<a name="l01209"></a>01209   ogg_stream_reset(&amp;os_de);
<a name="l01210"></a>01210   ogg_sync_reset(&amp;oy);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212   <span class="keywordflow">for</span>(packets=0;;packets++)<span class="keywordflow">if</span>(pl[packets]==-1)<span class="keywordflow">break</span>;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214   <span class="keywordflow">for</span>(i=0;i&lt;packets;i++){
<a name="l01215"></a>01215     <span class="comment">/* construct a test packet */</span>
<a name="l01216"></a>01216     <a class="code" href="structogg__packet.html">ogg_packet</a> op;
<a name="l01217"></a>01217     <span class="keywordtype">int</span> len=pl[i];
<a name="l01218"></a>01218     
<a name="l01219"></a>01219     op.packet=data+inptr;
<a name="l01220"></a>01220     op.bytes=len;
<a name="l01221"></a>01221     op.e_o_s=(pl[i+1]&lt;0?1:0);
<a name="l01222"></a>01222     op.granulepos=granule_pos;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     granule_pos+=1024;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     <span class="keywordflow">for</span>(j=0;j&lt;len;j++)data[inptr++]=i+j;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <span class="comment">/* submit the test packet */</span>
<a name="l01229"></a>01229     ogg_stream_packetin(&amp;os_en,&amp;op);
<a name="l01230"></a>01230 
<a name="l01231"></a>01231     <span class="comment">/* retrieve any finished pages */</span>
<a name="l01232"></a>01232     {
<a name="l01233"></a>01233       <a class="code" href="structogg__page.html">ogg_page</a> og;
<a name="l01234"></a>01234       
<a name="l01235"></a>01235       <span class="keywordflow">while</span>(ogg_stream_pageout(&amp;os_en,&amp;og)){
<a name="l01236"></a>01236         <span class="comment">/* We have a page.  Check it carefully */</span>
<a name="l01237"></a>01237 
<a name="l01238"></a>01238         fprintf(stderr,<span class="stringliteral">&quot;%ld, &quot;</span>,pageno);
<a name="l01239"></a>01239 
<a name="l01240"></a>01240         <span class="keywordflow">if</span>(headers[pageno]==NULL){
<a name="l01241"></a>01241           fprintf(stderr,<span class="stringliteral">&quot;coded too many pages!\n&quot;</span>);
<a name="l01242"></a>01242           exit(1);
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244 
<a name="l01245"></a>01245         check_page(data+outptr,headers[pageno],&amp;og);
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         outptr+=og.body_len;
<a name="l01248"></a>01248         pageno++;
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         <span class="comment">/* have a complete page; submit it to sync/decode */</span>
<a name="l01251"></a>01251 
<a name="l01252"></a>01252         {
<a name="l01253"></a>01253           <a class="code" href="structogg__page.html">ogg_page</a> og_de;
<a name="l01254"></a>01254           <a class="code" href="structogg__packet.html">ogg_packet</a> op_de,op_de2;
<a name="l01255"></a>01255           <span class="keywordtype">char</span> *buf=ogg_sync_buffer(&amp;oy,og.header_len+og.body_len);
<a name="l01256"></a>01256           memcpy(buf,og.header,og.header_len);
<a name="l01257"></a>01257           memcpy(buf+og.header_len,og.body,og.body_len);
<a name="l01258"></a>01258           ogg_sync_wrote(&amp;oy,og.header_len+og.body_len);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260           <span class="keywordflow">while</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0){
<a name="l01261"></a>01261             <span class="comment">/* got a page.  Happy happy.  Verify that it&#39;s good. */</span>
<a name="l01262"></a>01262             
<a name="l01263"></a>01263             check_page(data+deptr,headers[pageout],&amp;og_de);
<a name="l01264"></a>01264             deptr+=og_de.body_len;
<a name="l01265"></a>01265             pageout++;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267             <span class="comment">/* submit it to deconstitution */</span>
<a name="l01268"></a>01268             ogg_stream_pagein(&amp;os_de,&amp;og_de);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270             <span class="comment">/* packets out? */</span>
<a name="l01271"></a>01271             <span class="keywordflow">while</span>(ogg_stream_packetpeek(&amp;os_de,&amp;op_de2)&gt;0){
<a name="l01272"></a>01272               ogg_stream_packetpeek(&amp;os_de,NULL);
<a name="l01273"></a>01273               ogg_stream_packetout(&amp;os_de,&amp;op_de); <span class="comment">/* just catching them all */</span>
<a name="l01274"></a>01274               
<a name="l01275"></a>01275               <span class="comment">/* verify peek and out match */</span>
<a name="l01276"></a>01276               <span class="keywordflow">if</span>(memcmp(&amp;op_de,&amp;op_de2,<span class="keyword">sizeof</span>(op_de))){
<a name="l01277"></a>01277                 fprintf(stderr,<span class="stringliteral">&quot;packetout != packetpeek! pos=%ld\n&quot;</span>,
<a name="l01278"></a>01278                         depacket);
<a name="l01279"></a>01279                 exit(1);
<a name="l01280"></a>01280               }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282               <span class="comment">/* verify the packet! */</span>
<a name="l01283"></a>01283               <span class="comment">/* check data */</span>
<a name="l01284"></a>01284               <span class="keywordflow">if</span>(memcmp(data+depacket,op_de.packet,op_de.bytes)){
<a name="l01285"></a>01285                 fprintf(stderr,<span class="stringliteral">&quot;packet data mismatch in decode! pos=%ld\n&quot;</span>,
<a name="l01286"></a>01286                         depacket);
<a name="l01287"></a>01287                 exit(1);
<a name="l01288"></a>01288               }
<a name="l01289"></a>01289               <span class="comment">/* check bos flag */</span>
<a name="l01290"></a>01290               <span class="keywordflow">if</span>(bosflag==0 &amp;&amp; op_de.b_o_s==0){
<a name="l01291"></a>01291                 fprintf(stderr,<span class="stringliteral">&quot;b_o_s flag not set on packet!\n&quot;</span>);
<a name="l01292"></a>01292                 exit(1);
<a name="l01293"></a>01293               }
<a name="l01294"></a>01294               <span class="keywordflow">if</span>(bosflag &amp;&amp; op_de.b_o_s){
<a name="l01295"></a>01295                 fprintf(stderr,<span class="stringliteral">&quot;b_o_s flag incorrectly set on packet!\n&quot;</span>);
<a name="l01296"></a>01296                 exit(1);
<a name="l01297"></a>01297               }
<a name="l01298"></a>01298               bosflag=1;
<a name="l01299"></a>01299               depacket+=op_de.bytes;
<a name="l01300"></a>01300               
<a name="l01301"></a>01301               <span class="comment">/* check eos flag */</span>
<a name="l01302"></a>01302               <span class="keywordflow">if</span>(eosflag){
<a name="l01303"></a>01303                 fprintf(stderr,<span class="stringliteral">&quot;Multiple decoded packets with eos flag!\n&quot;</span>);
<a name="l01304"></a>01304                 exit(1);
<a name="l01305"></a>01305               }
<a name="l01306"></a>01306 
<a name="l01307"></a>01307               <span class="keywordflow">if</span>(op_de.e_o_s)eosflag=1;
<a name="l01308"></a>01308 
<a name="l01309"></a>01309               <span class="comment">/* check granulepos flag */</span>
<a name="l01310"></a>01310               <span class="keywordflow">if</span>(op_de.granulepos!=-1){
<a name="l01311"></a>01311                 fprintf(stderr,<span class="stringliteral">&quot; granule:%ld &quot;</span>,(<span class="keywordtype">long</span>)op_de.granulepos);
<a name="l01312"></a>01312               }
<a name="l01313"></a>01313             }
<a name="l01314"></a>01314           }
<a name="l01315"></a>01315         }
<a name="l01316"></a>01316       }
<a name="l01317"></a>01317     }
<a name="l01318"></a>01318   }
<a name="l01319"></a>01319   _ogg_free(data);
<a name="l01320"></a>01320   <span class="keywordflow">if</span>(headers[pageno]!=NULL){
<a name="l01321"></a>01321     fprintf(stderr,<span class="stringliteral">&quot;did not write last page!\n&quot;</span>);
<a name="l01322"></a>01322     exit(1);
<a name="l01323"></a>01323   }
<a name="l01324"></a>01324   <span class="keywordflow">if</span>(headers[pageout]!=NULL){
<a name="l01325"></a>01325     fprintf(stderr,<span class="stringliteral">&quot;did not decode last page!\n&quot;</span>);
<a name="l01326"></a>01326     exit(1);
<a name="l01327"></a>01327   }
<a name="l01328"></a>01328   <span class="keywordflow">if</span>(inptr!=outptr){
<a name="l01329"></a>01329     fprintf(stderr,<span class="stringliteral">&quot;encoded page data incomplete!\n&quot;</span>);
<a name="l01330"></a>01330     exit(1);
<a name="l01331"></a>01331   }
<a name="l01332"></a>01332   <span class="keywordflow">if</span>(inptr!=deptr){
<a name="l01333"></a>01333     fprintf(stderr,<span class="stringliteral">&quot;decoded page data incomplete!\n&quot;</span>);
<a name="l01334"></a>01334     exit(1);
<a name="l01335"></a>01335   }
<a name="l01336"></a>01336   <span class="keywordflow">if</span>(inptr!=depacket){
<a name="l01337"></a>01337     fprintf(stderr,<span class="stringliteral">&quot;decoded packet data incomplete!\n&quot;</span>);
<a name="l01338"></a>01338     exit(1);
<a name="l01339"></a>01339   }
<a name="l01340"></a>01340   <span class="keywordflow">if</span>(!eosflag){
<a name="l01341"></a>01341     fprintf(stderr,<span class="stringliteral">&quot;Never got a packet with EOS set!\n&quot;</span>);
<a name="l01342"></a>01342     exit(1);
<a name="l01343"></a>01343   }
<a name="l01344"></a>01344   fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01345"></a>01345 }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
<a name="l01348"></a>01348 
<a name="l01349"></a>01349   ogg_stream_init(&amp;os_en,0x04030201);
<a name="l01350"></a>01350   ogg_stream_init(&amp;os_de,0x04030201);
<a name="l01351"></a>01351   ogg_sync_init(&amp;oy);
<a name="l01352"></a>01352 
<a name="l01353"></a>01353   <span class="comment">/* Exercise each code path in the framing code.  Also verify that</span>
<a name="l01354"></a>01354 <span class="comment">     the checksums are working.  */</span>
<a name="l01355"></a>01355 
<a name="l01356"></a>01356   {
<a name="l01357"></a>01357     <span class="comment">/* 17 only */</span>
<a name="l01358"></a>01358     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={17, -1};
<a name="l01359"></a>01359     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_0,NULL};
<a name="l01360"></a>01360     
<a name="l01361"></a>01361     fprintf(stderr,<span class="stringliteral">&quot;testing single page encoding... &quot;</span>);
<a name="l01362"></a>01362     test_pack(packets,headret);
<a name="l01363"></a>01363   }
<a name="l01364"></a>01364 
<a name="l01365"></a>01365   {
<a name="l01366"></a>01366     <span class="comment">/* 17, 254, 255, 256, 500, 510, 600 byte, pad */</span>
<a name="l01367"></a>01367     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={17, 254, 255, 256, 500, 510, 600, -1};
<a name="l01368"></a>01368     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_1,head2_1,NULL};
<a name="l01369"></a>01369     
<a name="l01370"></a>01370     fprintf(stderr,<span class="stringliteral">&quot;testing basic page encoding... &quot;</span>);
<a name="l01371"></a>01371     test_pack(packets,headret);
<a name="l01372"></a>01372   }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374   {
<a name="l01375"></a>01375     <span class="comment">/* nil packets; beginning,middle,end */</span>
<a name="l01376"></a>01376     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={0,17, 254, 255, 0, 256, 0, 500, 510, 600, 0, -1};
<a name="l01377"></a>01377     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_2,head2_2,NULL};
<a name="l01378"></a>01378     
<a name="l01379"></a>01379     fprintf(stderr,<span class="stringliteral">&quot;testing basic nil packets... &quot;</span>);
<a name="l01380"></a>01380     test_pack(packets,headret);
<a name="l01381"></a>01381   }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383   {
<a name="l01384"></a>01384     <span class="comment">/* large initial packet */</span>
<a name="l01385"></a>01385     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={4345,259,255,-1};
<a name="l01386"></a>01386     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_3,head2_3,NULL};
<a name="l01387"></a>01387     
<a name="l01388"></a>01388     fprintf(stderr,<span class="stringliteral">&quot;testing initial-packet lacing &gt; 4k... &quot;</span>);
<a name="l01389"></a>01389     test_pack(packets,headret);
<a name="l01390"></a>01390   }
<a name="l01391"></a>01391 
<a name="l01392"></a>01392   {
<a name="l01393"></a>01393     <span class="comment">/* continuing packet test */</span>
<a name="l01394"></a>01394     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={0,4345,259,255,-1};
<a name="l01395"></a>01395     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_4,head2_4,head3_4,NULL};
<a name="l01396"></a>01396     
<a name="l01397"></a>01397     fprintf(stderr,<span class="stringliteral">&quot;testing single packet page span... &quot;</span>);
<a name="l01398"></a>01398     test_pack(packets,headret);
<a name="l01399"></a>01399   }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   <span class="comment">/* page with the 255 segment limit */</span>
<a name="l01402"></a>01402   {
<a name="l01403"></a>01403 
<a name="l01404"></a>01404     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={0,10,10,10,10,10,10,10,10,
<a name="l01405"></a>01405                    10,10,10,10,10,10,10,10,
<a name="l01406"></a>01406                    10,10,10,10,10,10,10,10,
<a name="l01407"></a>01407                    10,10,10,10,10,10,10,10,
<a name="l01408"></a>01408                    10,10,10,10,10,10,10,10,
<a name="l01409"></a>01409                    10,10,10,10,10,10,10,10,
<a name="l01410"></a>01410                    10,10,10,10,10,10,10,10,
<a name="l01411"></a>01411                    10,10,10,10,10,10,10,10,
<a name="l01412"></a>01412                    10,10,10,10,10,10,10,10,
<a name="l01413"></a>01413                    10,10,10,10,10,10,10,10,
<a name="l01414"></a>01414                    10,10,10,10,10,10,10,10,
<a name="l01415"></a>01415                    10,10,10,10,10,10,10,10,
<a name="l01416"></a>01416                    10,10,10,10,10,10,10,10,
<a name="l01417"></a>01417                    10,10,10,10,10,10,10,10,
<a name="l01418"></a>01418                    10,10,10,10,10,10,10,10,
<a name="l01419"></a>01419                    10,10,10,10,10,10,10,10,
<a name="l01420"></a>01420                    10,10,10,10,10,10,10,10,
<a name="l01421"></a>01421                    10,10,10,10,10,10,10,10,
<a name="l01422"></a>01422                    10,10,10,10,10,10,10,10,
<a name="l01423"></a>01423                    10,10,10,10,10,10,10,10,
<a name="l01424"></a>01424                    10,10,10,10,10,10,10,10,
<a name="l01425"></a>01425                    10,10,10,10,10,10,10,10,
<a name="l01426"></a>01426                    10,10,10,10,10,10,10,10,
<a name="l01427"></a>01427                    10,10,10,10,10,10,10,10,
<a name="l01428"></a>01428                    10,10,10,10,10,10,10,10,
<a name="l01429"></a>01429                    10,10,10,10,10,10,10,10,
<a name="l01430"></a>01430                    10,10,10,10,10,10,10,10,
<a name="l01431"></a>01431                    10,10,10,10,10,10,10,10,
<a name="l01432"></a>01432                    10,10,10,10,10,10,10,10,
<a name="l01433"></a>01433                    10,10,10,10,10,10,10,10,
<a name="l01434"></a>01434                    10,10,10,10,10,10,10,10,
<a name="l01435"></a>01435                    10,10,10,10,10,10,10,50,-1};
<a name="l01436"></a>01436     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_5,head2_5,head3_5,NULL};
<a name="l01437"></a>01437     
<a name="l01438"></a>01438     fprintf(stderr,<span class="stringliteral">&quot;testing max packet segments... &quot;</span>);
<a name="l01439"></a>01439     test_pack(packets,headret);
<a name="l01440"></a>01440   }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   {
<a name="l01443"></a>01443     <span class="comment">/* packet that overspans over an entire page */</span>
<a name="l01444"></a>01444     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={0,100,9000,259,255,-1};
<a name="l01445"></a>01445     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_6,head2_6,head3_6,head4_6,NULL};
<a name="l01446"></a>01446     
<a name="l01447"></a>01447     fprintf(stderr,<span class="stringliteral">&quot;testing very large packets... &quot;</span>);
<a name="l01448"></a>01448     test_pack(packets,headret);
<a name="l01449"></a>01449   }
<a name="l01450"></a>01450 
<a name="l01451"></a>01451   {
<a name="l01452"></a>01452     <span class="comment">/* term only page.  why not? */</span>
<a name="l01453"></a>01453     <span class="keyword">const</span> <span class="keywordtype">int</span> packets[]={0,100,4080,-1};
<a name="l01454"></a>01454     <span class="keyword">const</span> <span class="keywordtype">int</span> *headret[]={head1_7,head2_7,head3_7,NULL};
<a name="l01455"></a>01455     
<a name="l01456"></a>01456     fprintf(stderr,<span class="stringliteral">&quot;testing zero data page (1 nil packet)... &quot;</span>);
<a name="l01457"></a>01457     test_pack(packets,headret);
<a name="l01458"></a>01458   }
<a name="l01459"></a>01459 
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 
<a name="l01462"></a>01462   {
<a name="l01463"></a>01463     <span class="comment">/* build a bunch of pages for testing */</span>
<a name="l01464"></a>01464     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data=_ogg_malloc(1024*1024);
<a name="l01465"></a>01465     <span class="keywordtype">int</span> pl[]={0,100,4079,2956,2057,76,34,912,0,234,1000,1000,1000,300,-1};
<a name="l01466"></a>01466     <span class="keywordtype">int</span> inptr=0,i,j;
<a name="l01467"></a>01467     <a class="code" href="structogg__page.html">ogg_page</a> og[5];
<a name="l01468"></a>01468     
<a name="l01469"></a>01469     ogg_stream_reset(&amp;os_en);
<a name="l01470"></a>01470 
<a name="l01471"></a>01471     <span class="keywordflow">for</span>(i=0;pl[i]!=-1;i++){
<a name="l01472"></a>01472       <a class="code" href="structogg__packet.html">ogg_packet</a> op;
<a name="l01473"></a>01473       <span class="keywordtype">int</span> len=pl[i];
<a name="l01474"></a>01474       
<a name="l01475"></a>01475       op.packet=data+inptr;
<a name="l01476"></a>01476       op.bytes=len;
<a name="l01477"></a>01477       op.e_o_s=(pl[i+1]&lt;0?1:0);
<a name="l01478"></a>01478       op.granulepos=(i+1)*1000;
<a name="l01479"></a>01479 
<a name="l01480"></a>01480       <span class="keywordflow">for</span>(j=0;j&lt;len;j++)data[inptr++]=i+j;
<a name="l01481"></a>01481       ogg_stream_packetin(&amp;os_en,&amp;op);
<a name="l01482"></a>01482     }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484     _ogg_free(data);
<a name="l01485"></a>01485 
<a name="l01486"></a>01486     <span class="comment">/* retrieve finished pages */</span>
<a name="l01487"></a>01487     <span class="keywordflow">for</span>(i=0;i&lt;5;i++){
<a name="l01488"></a>01488       <span class="keywordflow">if</span>(ogg_stream_pageout(&amp;os_en,&amp;og[i])==0){
<a name="l01489"></a>01489         fprintf(stderr,<span class="stringliteral">&quot;Too few pages output building sync tests!\n&quot;</span>);
<a name="l01490"></a>01490         exit(1);
<a name="l01491"></a>01491       }
<a name="l01492"></a>01492       copy_page(&amp;og[i]);
<a name="l01493"></a>01493     }
<a name="l01494"></a>01494 
<a name="l01495"></a>01495     <span class="comment">/* Test lost pages on pagein/packetout: no rollback */</span>
<a name="l01496"></a>01496     {
<a name="l01497"></a>01497       <a class="code" href="structogg__page.html">ogg_page</a> temp;
<a name="l01498"></a>01498       <a class="code" href="structogg__packet.html">ogg_packet</a> test;
<a name="l01499"></a>01499 
<a name="l01500"></a>01500       fprintf(stderr,<span class="stringliteral">&quot;Testing loss of pages... &quot;</span>);
<a name="l01501"></a>01501 
<a name="l01502"></a>01502       ogg_sync_reset(&amp;oy);
<a name="l01503"></a>01503       ogg_stream_reset(&amp;os_de);
<a name="l01504"></a>01504       <span class="keywordflow">for</span>(i=0;i&lt;5;i++){
<a name="l01505"></a>01505         memcpy(ogg_sync_buffer(&amp;oy,og[i].header_len),og[i].header,
<a name="l01506"></a>01506                og[i].header_len);
<a name="l01507"></a>01507         ogg_sync_wrote(&amp;oy,og[i].header_len);
<a name="l01508"></a>01508         memcpy(ogg_sync_buffer(&amp;oy,og[i].body_len),og[i].body,og[i].body_len);
<a name="l01509"></a>01509         ogg_sync_wrote(&amp;oy,og[i].body_len);
<a name="l01510"></a>01510       }
<a name="l01511"></a>01511 
<a name="l01512"></a>01512       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01513"></a>01513       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01514"></a>01514       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01515"></a>01515       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01516"></a>01516       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01517"></a>01517       <span class="comment">/* skip */</span>
<a name="l01518"></a>01518       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01519"></a>01519       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521       <span class="comment">/* do we get the expected results/packets? */</span>
<a name="l01522"></a>01522       
<a name="l01523"></a>01523       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01524"></a>01524       checkpacket(&amp;test,0,0,0);
<a name="l01525"></a>01525       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01526"></a>01526       checkpacket(&amp;test,100,1,-1);
<a name="l01527"></a>01527       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01528"></a>01528       checkpacket(&amp;test,4079,2,3000);
<a name="l01529"></a>01529       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=-1){
<a name="l01530"></a>01530         fprintf(stderr,<span class="stringliteral">&quot;Error: loss of page did not return error\n&quot;</span>);
<a name="l01531"></a>01531         exit(1);
<a name="l01532"></a>01532       }
<a name="l01533"></a>01533       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01534"></a>01534       checkpacket(&amp;test,76,5,-1);
<a name="l01535"></a>01535       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01536"></a>01536       checkpacket(&amp;test,34,6,-1);
<a name="l01537"></a>01537       fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01538"></a>01538     }
<a name="l01539"></a>01539 
<a name="l01540"></a>01540     <span class="comment">/* Test lost pages on pagein/packetout: rollback with continuation */</span>
<a name="l01541"></a>01541     {
<a name="l01542"></a>01542       <a class="code" href="structogg__page.html">ogg_page</a> temp;
<a name="l01543"></a>01543       <a class="code" href="structogg__packet.html">ogg_packet</a> test;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545       fprintf(stderr,<span class="stringliteral">&quot;Testing loss of pages (rollback required)... &quot;</span>);
<a name="l01546"></a>01546 
<a name="l01547"></a>01547       ogg_sync_reset(&amp;oy);
<a name="l01548"></a>01548       ogg_stream_reset(&amp;os_de);
<a name="l01549"></a>01549       <span class="keywordflow">for</span>(i=0;i&lt;5;i++){
<a name="l01550"></a>01550         memcpy(ogg_sync_buffer(&amp;oy,og[i].header_len),og[i].header,
<a name="l01551"></a>01551                og[i].header_len);
<a name="l01552"></a>01552         ogg_sync_wrote(&amp;oy,og[i].header_len);
<a name="l01553"></a>01553         memcpy(ogg_sync_buffer(&amp;oy,og[i].body_len),og[i].body,og[i].body_len);
<a name="l01554"></a>01554         ogg_sync_wrote(&amp;oy,og[i].body_len);
<a name="l01555"></a>01555       }
<a name="l01556"></a>01556 
<a name="l01557"></a>01557       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01558"></a>01558       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01559"></a>01559       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01560"></a>01560       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01561"></a>01561       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01562"></a>01562       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01563"></a>01563       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01564"></a>01564       <span class="comment">/* skip */</span>
<a name="l01565"></a>01565       ogg_sync_pageout(&amp;oy,&amp;temp);
<a name="l01566"></a>01566       ogg_stream_pagein(&amp;os_de,&amp;temp);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568       <span class="comment">/* do we get the expected results/packets? */</span>
<a name="l01569"></a>01569       
<a name="l01570"></a>01570       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01571"></a>01571       checkpacket(&amp;test,0,0,0);
<a name="l01572"></a>01572       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01573"></a>01573       checkpacket(&amp;test,100,1,-1);
<a name="l01574"></a>01574       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01575"></a>01575       checkpacket(&amp;test,4079,2,3000);
<a name="l01576"></a>01576       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01577"></a>01577       checkpacket(&amp;test,2956,3,4000);
<a name="l01578"></a>01578       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=-1){
<a name="l01579"></a>01579         fprintf(stderr,<span class="stringliteral">&quot;Error: loss of page did not return error\n&quot;</span>);
<a name="l01580"></a>01580         exit(1);
<a name="l01581"></a>01581       }
<a name="l01582"></a>01582       <span class="keywordflow">if</span>(ogg_stream_packetout(&amp;os_de,&amp;test)!=1)error();
<a name="l01583"></a>01583       checkpacket(&amp;test,300,13,14000);
<a name="l01584"></a>01584       fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01585"></a>01585     }
<a name="l01586"></a>01586     
<a name="l01587"></a>01587     <span class="comment">/* the rest only test sync */</span>
<a name="l01588"></a>01588     {
<a name="l01589"></a>01589       <a class="code" href="structogg__page.html">ogg_page</a> og_de;
<a name="l01590"></a>01590       <span class="comment">/* Test fractional page inputs: incomplete capture */</span>
<a name="l01591"></a>01591       fprintf(stderr,<span class="stringliteral">&quot;Testing sync on partial inputs... &quot;</span>);
<a name="l01592"></a>01592       ogg_sync_reset(&amp;oy);
<a name="l01593"></a>01593       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header,
<a name="l01594"></a>01594              3);
<a name="l01595"></a>01595       ogg_sync_wrote(&amp;oy,3);
<a name="l01596"></a>01596       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01597"></a>01597       
<a name="l01598"></a>01598       <span class="comment">/* Test fractional page inputs: incomplete fixed header */</span>
<a name="l01599"></a>01599       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header+3,
<a name="l01600"></a>01600              20);
<a name="l01601"></a>01601       ogg_sync_wrote(&amp;oy,20);
<a name="l01602"></a>01602       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01603"></a>01603       
<a name="l01604"></a>01604       <span class="comment">/* Test fractional page inputs: incomplete header */</span>
<a name="l01605"></a>01605       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header+23,
<a name="l01606"></a>01606              5);
<a name="l01607"></a>01607       ogg_sync_wrote(&amp;oy,5);
<a name="l01608"></a>01608       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01609"></a>01609       
<a name="l01610"></a>01610       <span class="comment">/* Test fractional page inputs: incomplete body */</span>
<a name="l01611"></a>01611       
<a name="l01612"></a>01612       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header+28,
<a name="l01613"></a>01613              og[1].header_len-28);
<a name="l01614"></a>01614       ogg_sync_wrote(&amp;oy,og[1].header_len-28);
<a name="l01615"></a>01615       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01616"></a>01616       
<a name="l01617"></a>01617       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body,1000);
<a name="l01618"></a>01618       ogg_sync_wrote(&amp;oy,1000);
<a name="l01619"></a>01619       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01620"></a>01620       
<a name="l01621"></a>01621       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body+1000,
<a name="l01622"></a>01622              og[1].body_len-1000);
<a name="l01623"></a>01623       ogg_sync_wrote(&amp;oy,og[1].body_len-1000);
<a name="l01624"></a>01624       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01625"></a>01625       
<a name="l01626"></a>01626       fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     <span class="comment">/* Test fractional page inputs: page + incomplete capture */</span>
<a name="l01630"></a>01630     {
<a name="l01631"></a>01631       <a class="code" href="structogg__page.html">ogg_page</a> og_de;
<a name="l01632"></a>01632       fprintf(stderr,<span class="stringliteral">&quot;Testing sync on 1+partial inputs... &quot;</span>);
<a name="l01633"></a>01633       ogg_sync_reset(&amp;oy); 
<a name="l01634"></a>01634 
<a name="l01635"></a>01635       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header,
<a name="l01636"></a>01636              og[1].header_len);
<a name="l01637"></a>01637       ogg_sync_wrote(&amp;oy,og[1].header_len);
<a name="l01638"></a>01638 
<a name="l01639"></a>01639       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body,
<a name="l01640"></a>01640              og[1].body_len);
<a name="l01641"></a>01641       ogg_sync_wrote(&amp;oy,og[1].body_len);
<a name="l01642"></a>01642 
<a name="l01643"></a>01643       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header,
<a name="l01644"></a>01644              20);
<a name="l01645"></a>01645       ogg_sync_wrote(&amp;oy,20);
<a name="l01646"></a>01646       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01647"></a>01647       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01648"></a>01648 
<a name="l01649"></a>01649       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header+20,
<a name="l01650"></a>01650              og[1].header_len-20);
<a name="l01651"></a>01651       ogg_sync_wrote(&amp;oy,og[1].header_len-20);
<a name="l01652"></a>01652       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body,
<a name="l01653"></a>01653              og[1].body_len);
<a name="l01654"></a>01654       ogg_sync_wrote(&amp;oy,og[1].body_len);
<a name="l01655"></a>01655       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01656"></a>01656 
<a name="l01657"></a>01657       fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01658"></a>01658     }
<a name="l01659"></a>01659     
<a name="l01660"></a>01660     <span class="comment">/* Test recapture: garbage + page */</span>
<a name="l01661"></a>01661     {
<a name="l01662"></a>01662       <a class="code" href="structogg__page.html">ogg_page</a> og_de;
<a name="l01663"></a>01663       fprintf(stderr,<span class="stringliteral">&quot;Testing search for capture... &quot;</span>);
<a name="l01664"></a>01664       ogg_sync_reset(&amp;oy); 
<a name="l01665"></a>01665       
<a name="l01666"></a>01666       <span class="comment">/* &#39;garbage&#39; */</span>
<a name="l01667"></a>01667       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body,
<a name="l01668"></a>01668              og[1].body_len);
<a name="l01669"></a>01669       ogg_sync_wrote(&amp;oy,og[1].body_len);
<a name="l01670"></a>01670 
<a name="l01671"></a>01671       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header,
<a name="l01672"></a>01672              og[1].header_len);
<a name="l01673"></a>01673       ogg_sync_wrote(&amp;oy,og[1].header_len);
<a name="l01674"></a>01674 
<a name="l01675"></a>01675       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body,
<a name="l01676"></a>01676              og[1].body_len);
<a name="l01677"></a>01677       ogg_sync_wrote(&amp;oy,og[1].body_len);
<a name="l01678"></a>01678 
<a name="l01679"></a>01679       memcpy(ogg_sync_buffer(&amp;oy,og[2].header_len),og[2].header,
<a name="l01680"></a>01680              20);
<a name="l01681"></a>01681       ogg_sync_wrote(&amp;oy,20);
<a name="l01682"></a>01682       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01683"></a>01683       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01684"></a>01684       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01685"></a>01685 
<a name="l01686"></a>01686       memcpy(ogg_sync_buffer(&amp;oy,og[2].header_len),og[2].header+20,
<a name="l01687"></a>01687              og[2].header_len-20);
<a name="l01688"></a>01688       ogg_sync_wrote(&amp;oy,og[2].header_len-20);
<a name="l01689"></a>01689       memcpy(ogg_sync_buffer(&amp;oy,og[2].body_len),og[2].body,
<a name="l01690"></a>01690              og[2].body_len);
<a name="l01691"></a>01691       ogg_sync_wrote(&amp;oy,og[2].body_len);
<a name="l01692"></a>01692       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01693"></a>01693 
<a name="l01694"></a>01694       fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <span class="comment">/* Test recapture: page + garbage + page */</span>
<a name="l01698"></a>01698     {
<a name="l01699"></a>01699       <a class="code" href="structogg__page.html">ogg_page</a> og_de;
<a name="l01700"></a>01700       fprintf(stderr,<span class="stringliteral">&quot;Testing recapture... &quot;</span>);
<a name="l01701"></a>01701       ogg_sync_reset(&amp;oy); 
<a name="l01702"></a>01702 
<a name="l01703"></a>01703       memcpy(ogg_sync_buffer(&amp;oy,og[1].header_len),og[1].header,
<a name="l01704"></a>01704              og[1].header_len);
<a name="l01705"></a>01705       ogg_sync_wrote(&amp;oy,og[1].header_len);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707       memcpy(ogg_sync_buffer(&amp;oy,og[1].body_len),og[1].body,
<a name="l01708"></a>01708              og[1].body_len);
<a name="l01709"></a>01709       ogg_sync_wrote(&amp;oy,og[1].body_len);
<a name="l01710"></a>01710 
<a name="l01711"></a>01711       memcpy(ogg_sync_buffer(&amp;oy,og[2].header_len),og[2].header,
<a name="l01712"></a>01712              og[2].header_len);
<a name="l01713"></a>01713       ogg_sync_wrote(&amp;oy,og[2].header_len);
<a name="l01714"></a>01714 
<a name="l01715"></a>01715       memcpy(ogg_sync_buffer(&amp;oy,og[2].header_len),og[2].header,
<a name="l01716"></a>01716              og[2].header_len);
<a name="l01717"></a>01717       ogg_sync_wrote(&amp;oy,og[2].header_len);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01720"></a>01720 
<a name="l01721"></a>01721       memcpy(ogg_sync_buffer(&amp;oy,og[2].body_len),og[2].body,
<a name="l01722"></a>01722              og[2].body_len-5);
<a name="l01723"></a>01723       ogg_sync_wrote(&amp;oy,og[2].body_len-5);
<a name="l01724"></a>01724 
<a name="l01725"></a>01725       memcpy(ogg_sync_buffer(&amp;oy,og[3].header_len),og[3].header,
<a name="l01726"></a>01726              og[3].header_len);
<a name="l01727"></a>01727       ogg_sync_wrote(&amp;oy,og[3].header_len);
<a name="l01728"></a>01728 
<a name="l01729"></a>01729       memcpy(ogg_sync_buffer(&amp;oy,og[3].body_len),og[3].body,
<a name="l01730"></a>01730              og[3].body_len);
<a name="l01731"></a>01731       ogg_sync_wrote(&amp;oy,og[3].body_len);
<a name="l01732"></a>01732 
<a name="l01733"></a>01733       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&gt;0)error();
<a name="l01734"></a>01734       <span class="keywordflow">if</span>(ogg_sync_pageout(&amp;oy,&amp;og_de)&lt;=0)error();
<a name="l01735"></a>01735 
<a name="l01736"></a>01736       fprintf(stderr,<span class="stringliteral">&quot;ok.\n&quot;</span>);
<a name="l01737"></a>01737     }
<a name="l01738"></a>01738   }    
<a name="l01739"></a>01739 
<a name="l01740"></a>01740   <span class="keywordflow">return</span>(0);
<a name="l01741"></a>01741 }
<a name="l01742"></a>01742 
<a name="l01743"></a>01743 <span class="preprocessor">#endif</span>
<a name="l01744"></a>01744 <span class="preprocessor"></span>
<a name="l01745"></a>01745 
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 
</pre></div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-6013A680-57F9-415B-8851-C4FA63356636/4_2src_2libogg_2src_2framing_8c_source.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 08:17:58 GMT -->
</html>
