
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-80F2DEC8-152F-4681-A9D0-8EB776131313.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:56:07 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="String Conversions" /><meta name="abstract" content="In case the developer is developing applications where P.I.P.S.-based functionality is called from a Symbian/S60 application, the need for conversions between Symbian descriptors and different string types provided by P.I.P.S. is needed." /><meta name="description" content="In case the developer is developing applications where P.I.P.S.-based functionality is called from a Symbian/S60 application, the need for conversions between Symbian descriptors and different string types provided by P.I.P.S. is needed." /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-5072BE46-B1B4-5C3A-BF55-BEA7443E7657" /><meta name="DC.Relation" scheme="URI" content="GUID-E2DE2C6F-E071-5E88-96F1-D71DDED84609" /><meta name="DC.Relation" scheme="URI" content="GUID-D79380CF-22B5-5865-9366-44118E8ECA2E" /><meta name="DC.Relation" scheme="URI" content="GUID-C4C85189-BA6F-5F11-ABB3-727D8C1F5984" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-80F2DEC8-152F-4681-A9D0-8EB776131313" /><meta name="DC.Language" content="en" /><title>String
Conversions </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-80F2DEC8-152F-4681-A9D0-8EB776131313">String
Conversions</h1><div><p>In case the developer is developing applications where P.I.P.S.-based
functionality is called from a Symbian/S60 application, the need for conversions
between Symbian descriptors and different string types provided by P.I.P.S.
is needed. </p>
<div id="GUID-A6479BB3-0176-4321-8D33-1465DCCAB049-GENID-GUID-4DA9C2FB-FBA2-4AFB-B373-DA9479CEFABF"><h3 class="section-title">Symbian
descriptors and C strings compared</h3> <p>The main difference between
Symbian descriptors and C strings is that the Symbian descriptors know how
many characters are in a data array. A C string does not know its length,
so when length is needed the NULL character that indicates the end of the
string has to be scanned.  </p><p>Another difference arises with buffers.
When C code reserves a buffer from the heap or stack, it has to keep the maximum
length somewhere. Many C methods that alter the buffer contents do not respect
the maximum size of the buffer and can override the reserved memory, causing
unknown behavior. Some methods take the maximum length as a parameter but
it is difficult to use those types in functions, since a pointer to an array
and maximum length have to be passed separately. Buffer descriptors can tell
the maximum length, and all the methods they provide respect the buffer limits.
 </p><p>When using neutral descriptor types there is no need to worry about
character widths. In a C program, the programmer has to explicitly specify
which method to use, for example <code class="codeph">strcat</code> or <code class="codeph">wcscat</code>.</p><p>The
table below contains a comparison of standard C string functions and Symbian
counter parts:</p><div class="tablenoborder"><a name="GUID-0580FD76-A651-4F23-81FF-4460DAF1992E"><!-- --></a><table cellpadding="4" cellspacing="0" summary="" id="GUID-0580FD76-A651-4F23-81FF-4460DAF1992E" frame="border" border="1" rules="all">
<tbody>
<tr class="">
<td class="cellrowborder" valign="top"><p><strong>C function</strong></p></td>
<td class="cellrowborder" valign="top"><p><strong>Symbian</strong></p></td>
<td class="cellrowborder" valign="top"><p><strong>Description</strong></p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">sprintf, swprintf</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDes::Format</code></td>
<td class="cellrowborder" valign="top"><p>Write formatted data to a string.</p></td>
</tr>
<tr class="">
<td class="cellrowborder" valign="top"><code class="codeph">strcat, wcscat, strncat, wcsncat </code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDes::Append</code></td>
<td class="cellrowborder" valign="top"><p>Append a string to another. </p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">strcmp, strncmp, wcsncmp </code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDesC::Compare</code></td>
<td class="cellrowborder" valign="top"><p>Compare strings lexicographically. </p></td>
</tr>
<tr class="">
<td class="cellrowborder" valign="top"><code class="codeph">strcpy, wcscpy strncpy, wcsncpy </code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDes::Copy </code></td>
<td class="cellrowborder" valign="top"><p>Copy a string to another. </p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">strchr, wcschr</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDesC::Locate </code></td>
<td class="cellrowborder" valign="top"><p>Find a character in a string. </p></td>
</tr>
<tr class="">
<td class="cellrowborder" valign="top"><code class="codeph">strrchr, wcsrchr</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDesC:: LocateReverse </code></td>
<td class="cellrowborder" valign="top"><p>Scan the index of the first character from a string that does not
exist in the alphabet array. </p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">strspn, wcsspn</code></td>
<td class="cellrowborder" valign="top"><p>None </p></td>
<td class="cellrowborder" valign="top"><p>Scan index of the first character from string that doesn't exist
in alphabet array. </p></td>
</tr>
<tr class="">
<td class="cellrowborder" valign="top"><code class="codeph">strcspn, wcscspn</code></td>
<td class="cellrowborder" valign="top"><p>None </p></td>
<td class="cellrowborder" valign="top"><p>Scan the index of the first occurrence of a character in a string
that belongs to the set of characters. </p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">strstr, wcsstr</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDesC::Find </code></td>
<td class="cellrowborder" valign="top"><p>Find a substring. </p></td>
</tr>
<tr class="">
<td class="cellrowborder" valign="top"><code class="codeph">strtok, wcstok</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TLex::</code></td>
<td class="cellrowborder" valign="top"><p>Find the next token in a string. </p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">strlen, wcslen</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDesC::Length</code></td>
<td class="cellrowborder" valign="top"><p>Get the length of a string. </p></td>
</tr>
<tr class="">
<td class="cellrowborder" valign="top"><code class="codeph">strcoll, wcscoll</code></td>
<td class="cellrowborder" valign="top"><code class="codeph">TDesC::CompareC </code></td>
<td class="cellrowborder" valign="top"><p>Compare strings using locale-specific information. </p></td>
</tr>
<tr class="bg ">
<td class="cellrowborder" valign="top"><code class="codeph">strftime, wcsftime</code></td>
<td class="cellrowborder" valign="top"><p>Using <code class="codeph">TDes::Format</code> and <code class="codeph">TTime </code></p></td>
<td class="cellrowborder" valign="top"><p>Format a time string. </p></td>
</tr>
</tbody>
</table></div> </div>
<div id="GUID-A6479BB3-0176-4321-8D33-1465DCCAB049-GENID-GUID-4DA9C2FB-FBA2-4AFB-B373-DA9479CEFABF"><h3 class="section-title">How
to convert <code class="codeph">TBuf16</code> to a <code class="codeph">char</code> buffer</h3>
<p>A <code class="codeph">TBuf16</code> buffer can be converted to a <code class="codeph">char</code> buffer
using the <code class="codeph">wcstombs</code> API. The example below illustrates how
the conversion can be done.</p><pre class="codeblock">#include &lt;e32base.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wchar.h&gt;

#define SIZE 20
_LIT(KData,"hello");
  
int main (void)
{
    TBuf16&lt;SIZE&gt; buf(KData);
    size_t ret;
    char carray[SIZE];
   
    ret = wcstombs(carray, (const wchar_t *)buf.PtrZ(), SIZE );
    printf("TBuf converted to char buffer : %s\n",carray);
    getchar();
    return (1);
}
</pre> </div>
<div id="GUID-A6479BB3-0176-4321-8D33-1465DCCAB049-GENID-GUID-4DA9C2FB-FBA2-4AFB-B373-DA9479CEFABF"><h3 class="section-title">How
to convert <code class="codeph">TBuf8</code> to <code class="codeph">wchar_t</code></h3>
<p>A <code class="codeph">TBuf8</code> buffer can be converted to <code class="codeph">wchar_t</code> using
the <code class="codeph">mbstowcs</code> API.</p><pre class="codeblock">#include &lt;e32base.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wchar.h&gt;

#define SIZE 20
 
 int main (void)
 {
     TBuf8&lt;SIZE&gt; buf(_L8("hello"));
     size_t ret;
     wchar_t warray[SIZE];
  
     ret = mbstowcs(warray, (const char *)buf.PtrZ(), SIZE );
     printf("TBuf8 converted to wchar buffer : %ls\n",warray);
     getchar();
     
     return (1);
 }
</pre> </div>
<div id="GUID-A6479BB3-0176-4321-8D33-1465DCCAB049-GENID-GUID-4DA9C2FB-FBA2-4AFB-B373-DA9479CEFABF"><h3 class="section-title">How
to convert <code class="codeph">TText16</code> to <code class="codeph">char</code></h3>
<p>The <code class="codeph">wcstombs</code> API can be used to convert a <code class="codeph">TText16</code> buffer
to a <code class="codeph">char</code> buffer. This is one of the examples of converting
from a Symbian data type to a C data type.</p><pre class="codeblock">#include &lt;e32def.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wchar.h&gt;

#define SIZE 32

int main (void)
{
   TText arr[SIZE] = L"abcdef";
   char carray[SIZE];
   size_t ret;

   ret = wcstombs(carray, (const wchar_t *)arr, SIZE);
   printf("TText converted to char buffer : %s",carray);
   getchar();

   return (1);
}
</pre> </div>
<div id="GUID-A6479BB3-0176-4321-8D33-1465DCCAB049-GENID-GUID-4DA9C2FB-FBA2-4AFB-B373-DA9479CEFABF"><h3 class="section-title">How
to convert a <code class="codeph">char</code> array and a <code class="codeph">wide char</code> array</h3>
<p>To use both <code class="codeph">char</code> and <code class="codeph">wide char</code> pointers
or array in the program, the user must convert buffers from a <code class="codeph">char</code> to
a <code class="codeph">wide char</code> and vice versa. Wide character APIs provide methods
to: </p><ul>
<li><p>convert a <code class="codeph">char</code> array to a <code class="codeph">wide char</code> array</p></li>
<li><p>convert a <code class="codeph">wide char</code> array to a <code class="codeph">char</code> array </p></li>
</ul><p><strong>Converting a <code class="codeph">char</code> array to a <code class="codeph">wide char</code> array</strong></p><p>The <code class="codeph">mbstowcs</code> API
can be used to convert a <code class="codeph">char</code> array to a <code class="codeph">wide char</code> array.</p><pre class="codeblock">#include &lt;stdlib.h&gt;
#include &lt;wchar.h&gt;

#define ARRAY_SIZE 32

int main(void)
{
   char *carray = "char array";
   wchar_t warray[ARRAY_SIZE];
   size_t ret;

   ret = mbstowcs(warray, (const char *)carray, ARRAY_SIZE);
   wprintf(L"character array contents : %s\n",carray);
   wprintf(L"wide char array contents : %ls\n",warray);
   getwchar();

   return (1);
}
</pre><p><strong>Converting a <code class="codeph">wide char</code> array to a <code class="codeph">char</code> array </strong></p><p>The <code class="codeph">wcstombs</code> API
can be used to convert a <code class="codeph">wide char</code> array to a <code class="codeph">char</code> array. </p><pre class="codeblock">#include &lt;stdlib.h&gt;
#include &lt;wchar.h&gt;

#define ARRAY_SIZE 32

int main(void)
{
   wchar_t *warray = L"wide array";
   char carray[ARRAY_SIZE];
   size_t ret;

   ret = wcstombs(carray, (const wchar_t *)warray, ARRAY_SIZE);
   wprintf(L"wide char array contents : %ls\n",warray);
   wprintf(L"character array contents : %s\n",carray);
   getwchar();

   return (1);
}
</pre> </div>
<div id="GUID-A6479BB3-0176-4321-8D33-1465DCCAB049-GENID-GUID-4DA9C2FB-FBA2-4AFB-B373-DA9479CEFABF"><h3 class="section-title">How
to declare a <code class="codeph">wide-char</code> string</h3> <p>To declare
a <code class="codeph">wide-char</code> string, prefix the string with 'L'
[Capital L].  </p><pre class="codeblock">#include &lt;wchar.h&gt;

int main(void)
{
     wchar_t *wptr = L"This is a wide char string";
  
     wprintf(L"%ls\n",wptr);
     getwchar(); 
}
</pre> </div>
</div></div></div><div class="footer"><p class="metadata">Last updated January 7th, 2010</p><hr /><div class="copy">© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-80F2DEC8-152F-4681-A9D0-8EB776131313.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:56:07 GMT -->
</html>