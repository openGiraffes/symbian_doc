
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C75726D3-E815-503D-8267-26DA27AD4787.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:07:58 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Big integers" /><meta name="abstract" content="This section explains the key concepts of big integer library." /><meta name="description" content="This section explains the key concepts of big integer library." /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-315452C2-A1E2-5888-A694-6D2DE73A3F5E" /><meta name="DC.Relation" scheme="URI" content="GUID-5B112A34-1CBA-5B28-A941-27847FC1D30A" /><meta name="DC.Relation" scheme="URI" content="GUID-1E1B040A-1C18-4F62-95F9-CE0ECE39C430" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-C75726D3-E815-503D-8267-26DA27AD4787" /><meta name="DC.Language" content="en" /><title>Big integers </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-C75726D3-E815-503D-8267-26DA27AD4787">Big integers</h1><div><p>This section explains the key concepts of big integer library.</p>
<div id="GUID-E105FD3A-2600-504A-842E-E75ABFB6FD31"><h3 class="section-title">Purpose
of big integer</h3><p>Some types of cryptography require the handling
of finite arbitrary length integers. This big integer library attempts
to provide support for that requirement. </p><p>It is capable of representing
both negative and positive integers with an absolute value of less
than 2^(2<sup>37</sup>). </p> </div>
<div id="GUID-324AFDAC-314C-5CC5-B322-E908AA6F53C3"><h3 class="section-title">Using
the big integer library</h3><p>There are four categories of exposed
APIs: </p> <ol id="GUID-93981CBD-4B6D-5E95-BD02-44492535C517">
<li id="GUID-3374E318-C0C5-5E7D-92D4-0F541F0F6B61"><a name="GUID-3374E318-C0C5-5E7D-92D4-0F541F0F6B61"><!-- --></a><p>Creation of
new integers given some other representation (descriptor, TUint, etc). <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-B5E4DBDC-2C7D-30BD-A3D3-8ADE6265CFD2"><code class="apiname">RInteger::NewL()</code></a> </p> </li>
<li id="GUID-808268B2-FF70-522B-92BD-5B5EA67DA61B"><a name="GUID-808268B2-FF70-522B-92BD-5B5EA67DA61B"><!-- --></a><p>Creation of
new integers given some criteria (range, bitcount, prime). <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-3F59160C-AE87-32A1-8138-C28F977C7607"><code class="apiname">RInteger::NewRandomL()</code></a>, <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-612D2DC1-69D5-3AAE-83AE-6DA5D9983072"><code class="apiname">RInteger::NewPrimeL()</code></a> </p> </li>
<li id="GUID-3F7FD594-479E-5631-87DE-95D0AC843A0C"><a name="GUID-3F7FD594-479E-5631-87DE-95D0AC843A0C"><!-- --></a><p>Exporting of
previously created integers to descriptors. <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-E3D3C429-EA8C-34C1-9D1D-9062BC3D4F16.html#GUID-2E9955F7-9219-37B0-84EA-62A3F3327EE8"><code class="apiname">TInteger::BufferLC()</code></a> </p> </li>
<li id="GUID-7D5C5166-15D1-5219-B085-E5D5513E50CE"><a name="GUID-7D5C5166-15D1-5219-B085-E5D5513E50CE"><!-- --></a><p>Querying attributes
about the size of a previously created integer. <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-E3D3C429-EA8C-34C1-9D1D-9062BC3D4F16.html#GUID-F990DD4D-0886-3BF6-B9EE-D48E086D8C78"><code class="apiname">TInteger::BitCount()</code></a>, <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-E3D3C429-EA8C-34C1-9D1D-9062BC3D4F16.html#GUID-11AB504D-2919-3F39-A0B6-EA79B498074B"><code class="apiname">TInteger::ByteCount()</code></a>, <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-E3D3C429-EA8C-34C1-9D1D-9062BC3D4F16.html#GUID-99874A2D-37D5-3A05-8275-351E29972FA8"><code class="apiname">TInteger::WordCount()</code></a>. </p> </li>
</ol> <p>The following code demonstrates how to create an <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> from a bit string representation of a big integer. </p> <pre class="codeblock">
//This creates an RInteger from the following binary hexadecimal (base 16)
//descriptor.  Note that the number is written overall in big endian (most
//significant digit is first, least significant digit (ones digit) is last).  
//P.S. The hexadecimal binary descriptor below is the base 16 representation
//of the base 10 number 123456789012345678901234567890.
RInteger integer = RInteger::NewL(_L8("18EE90FF6C373E0EE4E3F0AD2")); 
CleanupStack::PushL(integer);

//This next line converts the number stored by an RInteger into a binary, big
//endian, hexadecimal descriptor.
HBufC8* descriptor = integer.BufferLC();
CleanupStack::Pop(descriptor);
CleanupStack::PopAndDestroy(integer);
//descriptor is the same as the original _L8 input value now.
</pre> <p>For more information on integers, including important
memory management information and additional creation overloads, see <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> in the Cryptography API Reference material. </p> </div>
<div id="GUID-268F2081-4385-5D43-8ADA-4F17BAA4B0BC"><h3 class="section-title">Base
classes and their derived classes</h3> <p>The following diagram
shows the main classes used in bigint and which are implemented in <code>cryptography.dll</code>. The color of the boxes indicates the
type of Symbian class, that is, <code class="codeph">M</code>, <code class="codeph">C</code>, <code class="codeph">R</code> or <code class="codeph">T</code> class. </p> <div class="figure" id="GUID-45174FC0-A4B0-572E-801F-EC6CD5A96127"><img src="GUID-598140D3-6C92-5D8E-B204-C7197C6E404D_d0e448881_href.png" /><p class="figure-title"><strong>Figure: </strong>The inheritance diagram for <code class="codeph">TInteger</code> and <code class="codeph">RInteger</code> classes.</p></div> <p id="GUID-FE43C9B9-7F50-5311-A2AF-7BA9785A68BC"><a name="GUID-FE43C9B9-7F50-5311-A2AF-7BA9785A68BC"><!-- --></a><strong>RInteger
class</strong> </p><p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> is a <code class="codeph">TInteger</code> derived class allowing the construction of variable length big integers. </p><p>This class follows standard <code class="codeph">R</code> class rules. As
a quick refresher, the following rules apply to <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> s: </p><ul>
<li id="GUID-07C1504B-0A75-5FAF-BCFC-11E0C6977DD4"><a name="GUID-07C1504B-0A75-5FAF-BCFC-11E0C6977DD4"><!-- --></a><p>You can construct
an empty <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a>. </p> <pre class="codeblock">
RInteger integer;
</pre> <p>This is a constructed, but uninitialized integer.
It does not own memory and no operations can be performed on it. It
is useful, mostly, to assign the result of another integer operation
to. <code class="codeph">Push</code> ing and then <code class="codeph">PopAndDestroy</code> ing an empty <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> works, although it's not
needed. </p> </li>
<li id="GUID-CB62909E-910A-5C29-81E1-6DFD17081B6D"><a name="GUID-CB62909E-910A-5C29-81E1-6DFD17081B6D"><!-- --></a><p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> s can be bitwised copied (the default assignment operator and copy
constructor are valid), but you need to be careful you don't lose
your original memory in the process. You should only use the assignment
operator on a newly declared integer. To set an <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> to another value without losing memory see <code class="codeph">TInteger::Set()</code>. </p> <pre class="codeblock">
RInteger a = anotherInteger; // OK -- you now have two integers that point to the same memory
RInteger b = RInteger::NewL(aDesc); // OK 
b = a; // NOT OK, b's original memory has been lost
</pre> </li>
<li id="GUID-D6F49AA0-5C91-5054-A59A-C01757D53AD9"><a name="GUID-D6F49AA0-5C91-5054-A59A-C01757D53AD9"><!-- --></a><p>You own any <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> returned by value from a <code class="codeph">TInteger</code> function. </p> <pre class="codeblock">
RInteger integer = a.MinusL(b); // We now own integer
CleanupStack::PushL(integer); 
</pre> </li>
<li id="GUID-076C4F7F-8EC7-5E5E-833C-DD3E32996DCE"><a name="GUID-076C4F7F-8EC7-5E5E-833C-DD3E32996DCE"><!-- --></a><p>You must call <code class="codeph">Close()</code> on all <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> s that own memory
before they go out of scope. (The cleanup stack can do this for you
as well, see further bullet points below). </p> <pre class="codeblock">
void foo(void)
    {
    RInteger integer = a.TimesL(TInteger::Two);
    //&lt; all sorts of non-leaving code here &gt;
    integer.Close();
    }
</pre> </li>
<li id="GUID-0C2577CE-0336-553F-8D7C-9F731BECDDC5"><a name="GUID-0C2577CE-0336-553F-8D7C-9F731BECDDC5"><!-- --></a><p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> has a operator <code class="codeph">TCleanupItem()</code> cast function that
allows you to call <code class="codeph">CleanupStack::PushL(RInteger&amp;)</code>. Use this in preference to <code class="codeph">CleanupClosePushL(RInteger&amp;)</code>, which although it does the same thing, generates more code. </p> <pre class="codeblock">
RInteger integer = a.ModularExponentiateL(b, p);
CleanupStack::PushL(integer);
//&lt; all sorts of leaving code here &gt;
CleanupStack::PopAndDestroy(&amp;integer);
</pre> </li>
<li id="GUID-6FF78282-6B29-5094-8D6B-C2D0FCDFC9E7"><a name="GUID-6FF78282-6B29-5094-8D6B-C2D0FCDFC9E7"><!-- --></a><p>Be careful calling <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-E3D3C429-EA8C-34C1-9D1D-9062BC3D4F16.html#GUID-F2E2C416-D2F2-31C1-942B-256F74A4075C"><code class="apiname">TInteger::Set()</code></a>. After calling this, two <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-8C8CA735-6B76-3204-AFBF-F95496EDCD91.html"><code class="apiname">RInteger</code></a> s have a pointer to the same heap-based integer. Calling <code class="codeph">Close()</code> on one, either explicitly or through the cleanup
stack, leaves a dangling pointer to the other. You probably want to
use code similar to the following: </p> <pre class="codeblock">
RInteger first = RInteger::NewL(298728);
CleanupStack::PushL(first);
//&lt; all sorts of leaving code here &gt;
RInteger second.Set(first);
CleanupStack::Pop(first);
CleanupStack::PushL(second);
</pre> </li>
</ul> </div>
</div></div></div><div class="footer"><p class="metadata">Last updated October 22nd, 2010</p><hr /><div class="copy">© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C75726D3-E815-503D-8267-26DA27AD4787.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:07:59 GMT -->
</html>