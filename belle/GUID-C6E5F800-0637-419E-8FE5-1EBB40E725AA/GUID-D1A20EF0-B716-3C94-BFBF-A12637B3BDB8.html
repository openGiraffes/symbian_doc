<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:18:41 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta name="DC.Type" content="cxxClass" />
<meta name="DC.Title" content="SysUtil" />
<meta name="abstract" content="" />
<meta name="description" content="" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8" />
<title>SysUtil</title>
<meta name="keywords" content="api" /><link rel="stylesheet" type="text/css" href="css/nokiacxxref.css" />
<link href="css/s60/style.css" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp3.html" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category-cover_cpp3.html" rel="stylesheet" type="text/css" /></head>
<body id="GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8"><a name="GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8"><!-- --></a><div class="body"><div class="contentLeft prTxt">
<h1 class="sectiontitle">SysUtil Class Reference</h1>
<div class="state state apiQualifier apiQualifier cxxClassDeclarationFile section include"><p>#include 
            
                    &lt;bafl/sysutil.h&gt;
                </p></div>
<div class="p section linkagainst"><p>Link against: sysutil.lib</p></div>
<div class="section signature"><table class="signature"><tr><td>class SysUtil</td></tr></table></div><div class="section member-index"><table class="member-index"><thead><tr><th colspan="2">Public Member Functions</th></tr></thead><tbody><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-3D24F1DC-99A2-3AEA-8BE9-E0A1E9D70E19">DiskSpaceBelowCriticalLevelL</a>(RFs *, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt64</a>, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a>)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-2DD49C4A-616A-3B9B-B72D-B3DEAECFFC4A">FFSSpaceBelowCriticalLevelL</a>(RFs *, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt64</a>)</td></tr><tr><td align="right" class="code">IMPORT_C CDeviceTypeInformation *</td><td><a href="#GUID-4684E939-2F5B-3ECF-917F-B653C506E9C3">GetDeviceTypeInfoL</a>()</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-357C7DFA-2629-3014-9333-36DEC6E381C8">GetFFSDriveLetter</a>(RFs &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-459A7DAA-1BC9-3C70-9CB9-9ECFE7B13296">GetLangSWVersion</a>(<a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-8150B9E2-29AF-3D39-BB86-8879BD824AF1">GetLangVersion</a>(<a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-63537940-000C-3246-8291-E910CD6DC990">GetMMCDriveLetter</a>(RFs &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-4ED1D829-DEAF-3A69-ADE6-4A16A24B3847">GetPRInformation</a>(<a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-A97D63BA-3BD1-3F9A-9D40-158003D9CAD1">GetSWVersion</a>(<a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-B512EEDB-9B9C-3877-A3C6-43C8FCFBC5F1">MMCSpaceBelowCriticalLevelL</a>(RFs *, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt64</a>)</td></tr></tbody></table></div><div class="section section apiDesc section apidesc"><h2 class="sectiontitle">Detailed Description</h2>
<div class="p">
<a class="xref" href="GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8.html#GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8">SysUtil</a> provides various system utility methods, as follows:<ul class="ul"><li class="li"><p class="p">Functions for applications to retrieve SW and language package versions strings for display purposes</p>
</li>
<li class="li"><p class="p">Functions to check whether there is free space on a disk drive before file creation or writing.</p>
</li>
<li class="li"><p class="p">Functions to retrieve Device Type information (e.g. phone model) for display purposes.</p>
</li>
</ul>
</div>
<p class="p">Version, Attribute strings and free space thresholds are provisioned by the device creator into the ROM. For details on this see the 'SGL.TS0017.324 BAFL How-To FAQ Document' in the OS Developer Library.</p>
</div>
<h2 class="sectiontitle">Member Function Documentation</h2><div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-3D24F1DC-99A2-3AEA-8BE9-E0A1E9D70E19"><a name="GUID-3D24F1DC-99A2-3AEA-8BE9-E0A1E9D70E19"><!-- --></a>
<a name="GUID-EA844E21-0F9D-3A97-8C33-A2745B64E325"><!-- --></a><h3 class="sectiontitle">DiskSpaceBelowCriticalLevelL ( RFs *, TInt64, TInt )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>DiskSpaceBelowCriticalLevelL</td><td>(</td><td>RFs *</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt64</a></td><td><span class="parameter">aBytesToWrite</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><span class="parameter">aDrive</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if free disk drive storage space is or will fall below critical level.</p>
<p class="p">To calculate if a critical level has been reached the critical level threshold setting will be used. This setting is available in the patchable data.</p>
<p class="p">RAM drives and non-RAM drives have different threshold levels, so the corresponding setting will be used for the calculation depending on the drive type.</p>
<p class="p">RAM drives are defined to be drives that have the media type of EMediaRam as returned by RFs. </p>
<p class="p">See also: RFs::Drive</p>
<p class="p">To set the patchdata for the RAM drive threshold set the MACRO SYMBIAN_BAFL_SYSUTIL_RAM_DRIVE_CRITICAL_THRESHOLD at ROM build time to an appropriate level. To set the patchdata for the non-RAM drive threshold set the MACRO SYMBIAN_BAFL_SYSUTIL_OTHER_DISK_CRITICAL_THRESHOLD at ROM build time to an appropriate level.</p>
<div class="p">Usage example: <pre class="pre codeblock">TInt64 dataSize = 500000000;
if ( SysUtil::DiskSpaceBelowCriticalLevelL( &amp;iFsSession, dataSize, EDriveC ) )
    {
    // Can not write the data, there's not enough free space on disk.
    ...
    }
else
    {
    // It's ok to actually write the data.
    ...
    }</pre>
</div>
<p class="p">See also: TDriveNumber in f32file.h. </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session. Must be given if available, e.g. from EIKON environment. If NULL, this method will create a temporary session, which causes the method to consume more time and system resources.  </td></tr><tr class="bg"><td class="parameter">aBytesToWrite</td><td>Number of bytes the caller is about to write to disk. If value 0 is given, this method checks if the current disk space is already below critical level.  </td></tr><tr><td class="parameter">aDrive</td><td>Identifies the disk drive to be checked. Numeric values for identifying disk drives are defined in TDriveNumber enumeration.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>ETrue if disk space would go below critical level after writing aBytesToWrite more data, EFalse otherwise. </dd></dl></div>
<div class="section leave"><table class="leave"><tr><th class="leave">Leave Codes</th></tr><tr><td class="leavecode">System</td><td class="leavevalue">wide error codes</td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-2DD49C4A-616A-3B9B-B72D-B3DEAECFFC4A"><a name="GUID-2DD49C4A-616A-3B9B-B72D-B3DEAECFFC4A"><!-- --></a>
<a name="GUID-6448D357-C1DE-30F2-85ED-3E45ADA45D22"><!-- --></a><h3 class="sectiontitle">FFSSpaceBelowCriticalLevelL ( RFs *, TInt64 )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>FFSSpaceBelowCriticalLevelL</td><td>(</td><td>RFs *</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt64</a></td><td><span class="parameter">aBytesToWrite</span> = 0</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if free system drive storage space is or will fall below critical level. The system drive (internal, read/write, persistent drive) is also known as the FFS (internal flash file system).</p>
<p class="p">To calculate if a critical level has been reached the critical level threshold setting will be used. This setting is available in the patchable data.</p>
<p class="p">RAM drives and non-RAM drives have different threshold levels, so the corresponding setting will be used for the calculation depending on the drive type.</p>
<p class="p">RAM drives are defined to be drives that have the media type of EMediaRam as returned by RFs. </p>
<p class="p">See also: RFs::Drive</p>
<p class="p">To set the patchdata for the RAM drive threshold set the MACRO SYMBIAN_BAFL_SYSUTIL_RAM_DRIVE_CRITICAL_THRESHOLD at ROM build time to an appropriate level. To set the patchdata for the non-RAM drive threshold set the MACRO SYMBIAN_BAFL_SYSUTIL_OTHER_DISK_CRITICAL_THRESHOLD at ROM build time to an appropriate level.</p>
<p class="p">This method also needs to determine which drive is the FFS drive. To do this patchable data has been provided. If the patchable data has not been set, then RFs::GetSystemDrive() will be used to determine the FFS drive.</p>
<p class="p">To set the patchdata to the FFS drive set the MACRO SYMBIAN_BAFL_SYSUTIL_DEFAULT_FFS_DRIVE to the appropriate drive letter. </p>
<p class="p">See also: TDriveNumber</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session. Must be given if available, e.g. from EIKON environment. If NULL, this method will create a temporary session, which causes the method to consume more time and system resources.  </td></tr><tr class="bg"><td class="parameter">aBytesToWrite</td><td>Number of bytes the caller is about to write to the system drive. If value 0 is given, this method checks if the current system drive space is already below critical level.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>ETrue if system drive space would go below critical level after writing aBytesToWrite more data, EFalse otherwise. </dd></dl></div>
<div class="section leave"><table class="leave"><tr><th class="leave">Leave Codes</th></tr><tr><td class="leavecode">System</td><td class="leavevalue">wide error codes</td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-4684E939-2F5B-3ECF-917F-B653C506E9C3"><a name="GUID-4684E939-2F5B-3ECF-917F-B653C506E9C3"><!-- --></a>
<h3 class="sectiontitle">GetDeviceTypeInfoL (  )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C CDeviceTypeInformation *</td><td>GetDeviceTypeInfoL</td><td>(</td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Creates and returns a populated CDeviceTypeInformation object which is used to access the device type information attributes.</p>
<p class="p">All the attributes are provisioned by the device creator.</p>
<p class="p">The returned object is owned by the calling code and so it is the calling codes responsibility to delete this object when it no longer requires it.</p>
<div class="p">
</div>
<p class="p">See also: CDeviceTypeInformation </p>
</div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>CDeviceTypeInformation* A pointer to an instance of CDeviceTypeInformation. </dd></dl></div>
<div class="section leave"><table class="leave"><tr><th class="leave">Leave Codes</th></tr><tr><td class="leavecode">KErrNoMemory</td><td class="leavevalue">If there is not enough memory to create the object.</td></tr><tr><td class="leavecode">KErrNotReady</td><td class="leavevalue">If there was a problem retrieving the device type information attributes.</td></tr><tr><td class="leavecode"></td><td class="leavevalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-357C7DFA-2629-3014-9333-36DEC6E381C8"><a name="GUID-357C7DFA-2629-3014-9333-36DEC6E381C8"><!-- --></a>
<a name="GUID-41C403F6-596B-391F-87F7-5834E12421C0"><!-- --></a><h3 class="sectiontitle">GetFFSDriveLetter ( RFs &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetFFSDriveLetter</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Returns the FFS drive letter</p>
<p class="p">This method determines which drive is the FFS drive. To do this a patchable data has been provided. If the patchable data has not been set, then the drive will be fetched via a call to GetSystemDrive().</p>
<p class="p">To set the patchdata to the FFS drive set the MACRO SYMBIAN_BAFL_SYSUTIL_DEFAULT_FFS_DRIVE to the appropriate drive letter. </p>
<p class="p">See also: TDriveNumber</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>TInt the integer value equivalent of the TDriveNumber </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-459A7DAA-1BC9-3C70-9CB9-9ECFE7B13296"><a name="GUID-459A7DAA-1BC9-3C70-9CB9-9ECFE7B13296"><!-- --></a>
<a name="GUID-F56C115C-4F05-385B-8C35-269D27B7BB15"><!-- --></a><h3 class="sectiontitle">GetLangSWVersion ( TDes &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetLangSWVersion</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;</td><td><span class="parameter">aValue</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Returns displayable software version which the currently installed language package is compatible with.</p>
<p class="p">This version text is provisioned by the device creator into the ROM as a Unicode UTF16 format displayable string, for example:</p>
<p class="p">
<tt class="ph tt">V 1.0\n29-07-07\nBuild12345\n(c) Symbian Software</tt>
</p>
<p class="p">This provisioned text string contains only one line of text with "\n" sequences in the text which indicate a new line. This API will parse the text and remove any "\n" sequences that it finds and replace it with the Unicode newline sequence - 0x000A. The resulting buffer is then a unicode string with newline sequences built in. This then can for example, allow the buffer to be displayed directly to the screen already formatted on multiple lines.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aValue</td><td>On return, contains the software version string. The buffer should have space for KSysUtilVersionTextLength characters. If the buffer is insufficient the descriptor is filled to its maximum length. If a buffer is provided that is longer than 64 characters, and the provisioned text is larger than 64 characters, the returned buffer is truncated at 64 characters (see error codes below).  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone on success, KErrTooBig if the maximum length of the descriptor is insufficient to hold the provisioned text, or has been truncated (see above). In both cases new-line processing is done on the buffers. If a zero length text string has been provisioned KErrEof is returned, and the length of the buffer is set to zero. If none of these cases apply then one of the Symbian error codes is returned if reading the version string fails. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-8150B9E2-29AF-3D39-BB86-8879BD824AF1"><a name="GUID-8150B9E2-29AF-3D39-BB86-8879BD824AF1"><!-- --></a>
<a name="GUID-7593B4EA-F22B-359B-85BE-6A776F4DD980"><!-- --></a><h3 class="sectiontitle">GetLangVersion ( TDes &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetLangVersion</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;</td><td><span class="parameter">aValue</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Obtains the displayable version of the currently installed language package. This does NOT do any newline processing on the version text. (unlike, for example <a class="xref" href="GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8.html#GUID-459A7DAA-1BC9-3C70-9CB9-9ECFE7B13296">GetLangSWVersion()</a> or <a class="xref" href="GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8.html#GUID-A97D63BA-3BD1-3F9A-9D40-158003D9CAD1">GetSWVersion()</a>).</p>
<p class="p">This version text is provisioned by the device creator into the ROM as a Unicode UTF16 format displayable string.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aValue</td><td>On return, contains the software version string. The buffer should have space for KSysUtilVersionTextLength characters. If the buffer is insufficient the descriptor is filled to its maximum length. If a buffer is provided that is longer than 64 characters, and the provisioned text is larger than 64 characters, the returned buffer is truncated at 64 characters (see error codes below).  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone on success, KErrTooBig if the maximum length of the descriptor is insufficient to hold the provisioned text, or has been truncated (see above). In both cases new-line processing is done on the buffers. If a zero length text string has been provisioned KErrEof is returned, and the length of the buffer is set to zero. If none of these cases apply then one of the Symbian error codes is returned if reading the version string fails. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-63537940-000C-3246-8291-E910CD6DC990"><a name="GUID-63537940-000C-3246-8291-E910CD6DC990"><!-- --></a>
<a name="GUID-3DCDAD1F-CFB6-37D0-ABA5-580E0DCBF410"><!-- --></a><h3 class="sectiontitle">GetMMCDriveLetter ( RFs &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetMMCDriveLetter</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Returns the MMC drive letter</p>
<p class="p">This method determines which drive is the MMC drive. To do this a patchable data has been provided.</p>
<p class="p">To set the patchdata to the MMC drive set the MACRO SYMBIAN_BAFL_SYSUTIL_DEFAULT_MMC_DRIVE to the appropriate drive letter. </p>
<p class="p">See also: TDriveNumber</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>TInt the integer value equivalent of the TDriveNumber </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-4ED1D829-DEAF-3A69-ADE6-4A16A24B3847"><a name="GUID-4ED1D829-DEAF-3A69-ADE6-4A16A24B3847"><!-- --></a>
<a name="GUID-30C7C47C-FE6D-394C-8B4D-09DCB4F0451F"><!-- --></a><h3 class="sectiontitle">GetPRInformation ( TDes &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetPRInformation</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;</td><td><span class="parameter">aValue</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Obtains the displayable product release information string.</p>
<div class="p">Usage example: <pre class="pre codeblock">TBuf&lt;KSysUtilVersionTextLength&gt; prInfo;
if ( SysUtil::GetPRInformation( prInfo ) == KErrNone )
    {
    // Use the version string.
    ...
    }</pre>
 The product release information is provisioned by the device creator into the ROM as a Unicode UTF16 format displayable string, for example:</div>
<p class="p">
<tt class="ph tt">custom build fix xyz</tt> or <tt class="ph tt">PR1.0</tt> or <tt class="ph tt">PR1.1</tt></p>
<p class="p">This provisioned text string contains only one line of text with "\n" sequences in the text which indicate a new line. This API will parse the text and remove any "\n" sequences that it finds and replace it with the Unicode newline sequence - 0x000A. The resulting buffer is then a unicode string with newline sequences built in. This then can for example, allow the buffer to be displayed directly to the screen already formatted on multiple lines.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aValue</td><td>On return, contains the product release information string. The buffer should have space for KSysUtilVersionTextLength characters. If the buffer is insufficient the descriptor is filled to its maximum length. If a buffer is provided that is longer than 64 characters, and the provisioned text is larger than 64 characters, the returned buffer is truncated at 64 characters.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone on success, KErrTooBig if the maximum length of the descriptor is insufficient to hold the provisioned text, or has been truncated. In both cases new-line processing is done on the buffers. If a zero length text string has been provisioned KErrEof is returned, and the length of the buffer is set to zero. If none of these cases apply then one of the Symbian error codes is returned if reading the product release string fails. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-A97D63BA-3BD1-3F9A-9D40-158003D9CAD1"><a name="GUID-A97D63BA-3BD1-3F9A-9D40-158003D9CAD1"><!-- --></a>
<a name="GUID-DE5F37C9-90B3-3619-AAFA-D3663384E067"><!-- --></a><h3 class="sectiontitle">GetSWVersion ( TDes &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetSWVersion</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;</td><td><span class="parameter">aValue</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Obtains the displayable software version string.</p>
<div class="p">Usage example: <pre class="pre codeblock">TBuf&lt;KSysUtilVersionTextLength&gt; version;
if ( SysUtil::GetSWVersion( version ) == KErrNone )
	{
	// Use the version string.
	...
	}</pre>
 The software version is provisioned by the device creator into the ROM as a Unicode UTF16 format displayable string, for example:</div>
<p class="p">
<tt class="ph tt">V 1.0\n29-07-07\nBuild12345\n(c) Symbian Software</tt>
</p>
<p class="p">This provisioned text string contains only one line of text with "\n" sequences in the text which indicate a new line. This API will parse the text and remove any "\n" sequences that it finds and replace it with the Unicode newline sequence - 0x000A. The resulting buffer is then a unicode string with newline sequences built in. This then can for example, allow the buffer to be displayed directly to the screen already formatted on multiple lines.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aValue</td><td>On return, contains the software version string. The buffer should have space for KSysUtilVersionTextLength characters. If the buffer is insufficient the descriptor is filled to its maximum length. If a buffer is provided that is longer than 64 characters, and the provisioned text is larger than 64 characters, the returned buffer is truncated at 64 characters (see error codes below).  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone on success, KErrTooBig if the maximum length of the descriptor is insufficient to hold the provisioned text, or has been truncated (see above). In both cases new-line processing is done on the buffers. If a zero length text string has been provisioned KErrEof is returned, and the length of the buffer is set to zero. If none of these cases apply then one of the Symbian error codes is returned if reading the version string fails. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-B512EEDB-9B9C-3877-A3C6-43C8FCFBC5F1"><a name="GUID-B512EEDB-9B9C-3877-A3C6-43C8FCFBC5F1"><!-- --></a>
<a name="GUID-DCD0332A-D883-3717-A3CB-1BDA2CA30049"><!-- --></a><h3 class="sectiontitle">MMCSpaceBelowCriticalLevelL ( RFs *, TInt64 )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>MMCSpaceBelowCriticalLevelL</td><td>(</td><td>RFs *</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt64</a></td><td><span class="parameter">aBytesToWrite</span> = 0</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if free MMC storage space is or will fall below critical level.</p>
<p class="p">To calculate if a critical level has been reached the critical level threshold setting will be used. This setting is available in the patchable data.</p>
<p class="p">RAM drives and non-RAM drives have different threshold levels, so the corresponding setting will be used for the calculation depending on the drive type.</p>
<p class="p">RAM drives are defined to be drives that have the media type of EMediaRam as returned by RFs. </p>
<p class="p">See also: RFs::Drive</p>
<p class="p">This method also needs to determine which drive is the MMC drive. To do this a patchable data has been provided. If the patchable data has not been set, then the drive will be fetched using BSUL. </p>
<p class="p">See also: CCachedDriveInfo</p>
<p class="p">To set the patchdata for the RAM drive threshold set the MACRO SYMBIAN_BAFL_SYSUTIL_RAM_DRIVE_CRITICAL_THRESHOLD at ROM build time to an appropriate level. To set the patchdata for the non-RAM drive threshold set the MACRO SYMBIAN_BAFL_SYSUTIL_OTHER_DISK_CRITICAL_THRESHOLD at ROM build time to an appropriate level.</p>
<p class="p">To set the patchdata to the MMC drive set the MACRO SYMBIAN_BAFL_SYSUTIL_DEFAULT_MMC_DRIVE to the appropriate drive letter. </p>
<p class="p">See also: TDriveNumber</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session. Must be given if available, e.g. from EIKON environment. If NULL, this method will create a temporary session, which causes the method to consume more time and system resources.  </td></tr><tr class="bg"><td class="parameter">aBytesToWrite</td><td>Number of bytes the caller is about to write to MMC. If value 0 is given, this method checks if the current MMC space is already below critical level.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>ETrue if MMC space would go below critical level after writing aBytesToWrite more data, EFalse otherwise. </dd></dl></div>
<div class="section leave"><table class="leave"><tr><th class="leave">Leave Codes</th></tr><tr><td class="leavecode">KErrNotFound</td><td class="leavevalue">if the MMC drive cannot be found, otherwise one of the system-wide error codes.</td></tr></table></div></div>
</div>
</div></div><div class="footer"><hr /><div class="copy">© Nokia 2005.</div></div>
</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D1A20EF0-B716-3C94-BFBF-A12637B3BDB8.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:18:41 GMT -->
</html>