<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:19:49 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta name="DC.Type" content="cxxFile" />
<meta name="DC.Title" content="socket.html" />
<meta name="abstract" content="" />
<meta name="description" content="" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41" />
<title>socket.h</title>
<meta name="keywords" content="api" /><link rel="stylesheet" type="text/css" href="css/nokiacxxref.css" />
<link href="css/s60/style.css" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp3.html" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category-cover_cpp3.html" rel="stylesheet" type="text/css" /></head>
<body id="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41"><a name="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41"><!-- --></a><div class="body"><div class="contentLeft prTxt">
<h1 class="sectiontitle">socket.h File Reference</h1>
<div class="body refbody apiDetail apiClassifierDetail cxxFileDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-F4527132-3F40-331D-AB0F-BFF17519DA47"><a name="GUID-F4527132-3F40-331D-AB0F-BFF17519DA47"><!-- --></a>
<h3 class="sectiontitle">_NO_NAMESPACE_POLLUTION</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiValue cxxTypedef nested1" id="GUID-2774CB4C-187C-3CDA-A350-E4F122A42264"><a name="GUID-2774CB4C-187C-3CDA-A350-E4F122A42264"><!-- --></a>
<h3 class="sectiontitle">Typedef sa_family_t</h3>
<div class="section signature"><table class="signature"><tr><td>typedef 
					<a class="xref xref apiRelation" href="GUID-6B9FA9E3-BBBA-3B9F-8538-94583F2D3BA4.html">__sa_family_t</a>
</td><td>sa_family_t</td></tr></table></div><div class="section section apiDesc section apidesc">
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-1ED2F85E-857D-3668-9532-6A109926D90F"><a name="GUID-1ED2F85E-857D-3668-9532-6A109926D90F"><!-- --></a>
<h3 class="sectiontitle">_SA_FAMILY_T_DECLARED</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiValue cxxTypedef nested1" id="GUID-163D1F85-4DFA-3CDB-9799-AA286305EDE9"><a name="GUID-163D1F85-4DFA-3CDB-9799-AA286305EDE9"><!-- --></a>
<h3 class="sectiontitle">Typedef socklen_t</h3>
<div class="section signature"><table class="signature"><tr><td>typedef 
					<a class="xref xref apiRelation" href="GUID-6B9FA9E3-BBBA-3B9F-8538-94583F2D3BA4.html">__socklen_t</a>
</td><td>socklen_t</td></tr></table></div><div class="section section apiDesc section apidesc">
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-DE1064DE-64C1-3EE3-A895-58CE5D6FD842"><a name="GUID-DE1064DE-64C1-3EE3-A895-58CE5D6FD842"><!-- --></a>
<h3 class="sectiontitle">_SOCKLEN_T_DECLARED</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiValue cxxTypedef nested1" id="GUID-D8609951-BC69-3A34-B01A-92FDBCC6CA0C"><a name="GUID-D8609951-BC69-3A34-B01A-92FDBCC6CA0C"><!-- --></a>
<h3 class="sectiontitle">Typedef ssize_t</h3>
<div class="section signature"><table class="signature"><tr><td>typedef 
					<a class="xref xref apiRelation" href="GUID-6B9FA9E3-BBBA-3B9F-8538-94583F2D3BA4.html">__ssize_t</a>
</td><td>ssize_t</td></tr></table></div><div class="section section apiDesc section apidesc">
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-2E3DF392-81C9-3CF9-A975-29D90AE331AC"><a name="GUID-2E3DF392-81C9-3CF9-A975-29D90AE331AC"><!-- --></a>
<h3 class="sectiontitle">_SSIZE_T_DECLARED</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-F1D2FEE5-EFCD-3514-93DC-6108B049BB33"><a name="GUID-F1D2FEE5-EFCD-3514-93DC-6108B049BB33"><!-- --></a>
<h3 class="sectiontitle">SOCK_STREAM</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">stream socket</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-CD1137E1-F5EC-3BB8-86B9-FAB6AD088CF2"><a name="GUID-CD1137E1-F5EC-3BB8-86B9-FAB6AD088CF2"><!-- --></a>
<h3 class="sectiontitle">SOCK_DGRAM</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">datagram socket</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-F8A9946A-5B0E-31BC-889D-C6CBC882C251"><a name="GUID-F8A9946A-5B0E-31BC-889D-C6CBC882C251"><!-- --></a>
<h3 class="sectiontitle">SOCK_RAW</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">raw-protocol interface</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-8A0759F2-6FCA-343A-93AF-D69A58DD067B"><a name="GUID-8A0759F2-6FCA-343A-93AF-D69A58DD067B"><!-- --></a>
<h3 class="sectiontitle">SOCK_SEQPACKET</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">sequenced packet stream</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-00EC1D8E-CC9E-382D-9252-4A0DD5460FCC"><a name="GUID-00EC1D8E-CC9E-382D-9252-4A0DD5460FCC"><!-- --></a>
<h3 class="sectiontitle">SO_DEBUG</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">turn on debugging info recording KSODebug</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-C82BD32F-2FED-388C-81C4-2012D4607C85"><a name="GUID-C82BD32F-2FED-388C-81C4-2012D4607C85"><!-- --></a>
<h3 class="sectiontitle">SO_ACCEPTCONN</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">socket has had listen()</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-43EF7AFE-A08D-3022-B7CA-9CF5F2301F3D"><a name="GUID-43EF7AFE-A08D-3022-B7CA-9CF5F2301F3D"><!-- --></a>
<h3 class="sectiontitle">SO_REUSEADDR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">Allow a socket to be bound to an local address that is already in use.</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-D71B9C02-8FAF-3F95-950A-B2BA153DE908"><a name="GUID-D71B9C02-8FAF-3F95-950A-B2BA153DE908"><!-- --></a>
<h3 class="sectiontitle">SO_KEEPALIVE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">keep connections alive KSoTcpKeepAlive</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-52A32544-703B-345B-8FED-C6509D032EF6"><a name="GUID-52A32544-703B-345B-8FED-C6509D032EF6"><!-- --></a>
<h3 class="sectiontitle">SO_DONTROUTE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">just use interface addresses</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-AB24BDA1-CE30-3129-B666-CDD9697A1A68"><a name="GUID-AB24BDA1-CE30-3129-B666-CDD9697A1A68"><!-- --></a>
<h3 class="sectiontitle">SO_BROADCAST</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">permit sending of broadcast msgs</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-B0A521F2-742B-3AE5-8010-BB701AD2DBC5"><a name="GUID-B0A521F2-742B-3AE5-8010-BB701AD2DBC5"><!-- --></a>
<h3 class="sectiontitle">SO_LINGER</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">linger on close if data present</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-B2BF8CFB-A1D3-3639-A23B-AC6F1797C3BE"><a name="GUID-B2BF8CFB-A1D3-3639-A23B-AC6F1797C3BE"><!-- --></a>
<h3 class="sectiontitle">SO_OOBINLINE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">leave received OOB data in line KSoTcpOobInline</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-54ED7467-763C-321E-944B-321AFB450F4A"><a name="GUID-54ED7467-763C-321E-944B-321AFB450F4A"><!-- --></a>
<h3 class="sectiontitle">SO_SNDBUF</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">send buffer size KSOSendBuf</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-E1B5D654-797A-3B24-8FFF-AE6065DD77ED"><a name="GUID-E1B5D654-797A-3B24-8FFF-AE6065DD77ED"><!-- --></a>
<h3 class="sectiontitle">SO_RCVBUF</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">receive buffer size KSORecvBuf</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-333474BE-009E-306B-A65B-3FA5241B002E"><a name="GUID-333474BE-009E-306B-A65B-3FA5241B002E"><!-- --></a>
<h3 class="sectiontitle">SO_SNDLOWAT</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">send low-water mark</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-F3732E4C-A592-3244-8907-5D4F92603925"><a name="GUID-F3732E4C-A592-3244-8907-5D4F92603925"><!-- --></a>
<h3 class="sectiontitle">SO_RCVLOWAT</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">receive low-water mark</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-C57ACE8E-81B6-31BF-9411-3AD7EFCFDB46"><a name="GUID-C57ACE8E-81B6-31BF-9411-3AD7EFCFDB46"><!-- --></a>
<h3 class="sectiontitle">SO_SNDTIMEO</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">send timeout</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-55D3A489-76CD-3B5E-9BF6-1B1F7672BF19"><a name="GUID-55D3A489-76CD-3B5E-9BF6-1B1F7672BF19"><!-- --></a>
<h3 class="sectiontitle">SO_RCVTIMEO</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">receive timeout</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-4D0F3A94-D67B-3C61-96E7-A1C72EADE5E5"><a name="GUID-4D0F3A94-D67B-3C61-96E7-A1C72EADE5E5"><!-- --></a>
<h3 class="sectiontitle">SO_ERROR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">get error status and clear</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-AC983837-D0D6-33ED-87EA-0CABBE1BA8DE"><a name="GUID-AC983837-D0D6-33ED-87EA-0CABBE1BA8DE"><!-- --></a>
<h3 class="sectiontitle">SO_TYPE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">get socket type</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-E4BD7F0C-0C0F-3FE4-85F7-664FE6B133E9"><a name="GUID-E4BD7F0C-0C0F-3FE4-85F7-664FE6B133E9"><!-- --></a>
<h3 class="sectiontitle">SOL_SOCKET</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">options for socket level KSOLSocket</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-37612845-B475-32AF-A718-2E092AEADB28"><a name="GUID-37612845-B475-32AF-A718-2E092AEADB28"><!-- --></a>
<h3 class="sectiontitle">AF_UNSPEC</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">Address family. Unspecified.</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-94676826-B76A-3F23-A5BD-132862CB4A90"><a name="GUID-94676826-B76A-3F23-A5BD-132862CB4A90"><!-- --></a>
<h3 class="sectiontitle">AF_UNIX</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">local to host (pipes, portals)</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-3F78B5FE-0B7D-3A7E-9D02-459A397C5D6E"><a name="GUID-3F78B5FE-0B7D-3A7E-9D02-459A397C5D6E"><!-- --></a>
<h3 class="sectiontitle">AF_INET</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">internetwork: UDP, TCP, etc.</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-6BB94D7C-7B9C-3062-9AC8-AC088D033CC7"><a name="GUID-6BB94D7C-7B9C-3062-9AC8-AC088D033CC7"><!-- --></a>
<h3 class="sectiontitle">AF_INET6</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-0CEB3713-D4DE-39C0-84F0-2B4176DAAE72"><a name="GUID-0CEB3713-D4DE-39C0-84F0-2B4176DAAE72"><!-- --></a>
<h3 class="sectiontitle">AF_IRDA</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-FF30D66E-4FE6-3A5E-97F5-CC376E092AB0"><a name="GUID-FF30D66E-4FE6-3A5E-97F5-CC376E092AB0"><!-- --></a>
<h3 class="sectiontitle">AF_PLP</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-13265233-2011-3348-AFFE-5485C0CBF27F"><a name="GUID-13265233-2011-3348-AFFE-5485C0CBF27F"><!-- --></a>
<h3 class="sectiontitle">_SS_MAXSIZE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-7F3DCE54-6B40-37DA-855E-5F2E3461DE9A"><a name="GUID-7F3DCE54-6B40-37DA-855E-5F2E3461DE9A"><!-- --></a>
<h3 class="sectiontitle">_SS_ALIGNSIZE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-B13A4E7F-1DE5-3BEF-B125-E72AD2D0BF20"><a name="GUID-B13A4E7F-1DE5-3BEF-B125-E72AD2D0BF20"><!-- --></a>
<h3 class="sectiontitle">_SS_PAD1SIZE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-5F573322-63B7-3AF6-8848-D8A6B342C977"><a name="GUID-5F573322-63B7-3AF6-8848-D8A6B342C977"><!-- --></a>
<h3 class="sectiontitle">_SS_PAD2SIZE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-249A8B46-0FA0-317D-9827-135E0FF58AB4"><a name="GUID-249A8B46-0FA0-317D-9827-135E0FF58AB4"><!-- --></a>
<h3 class="sectiontitle">SOMAXCONN</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-F7C20770-D41A-3742-9055-EEEA60563E9F"><a name="GUID-F7C20770-D41A-3742-9055-EEEA60563E9F"><!-- --></a>
<h3 class="sectiontitle">MSG_OOB</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">process out-of-band data</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-CF2B4002-D6AC-3421-AF17-93026E355934"><a name="GUID-CF2B4002-D6AC-3421-AF17-93026E355934"><!-- --></a>
<h3 class="sectiontitle">MSG_PEEK</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">peek at incoming message</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-15617A9A-D9BF-3670-BAB3-FDE569C1088F"><a name="GUID-15617A9A-D9BF-3670-BAB3-FDE569C1088F"><!-- --></a>
<h3 class="sectiontitle">MSG_DONTROUTE</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">send without using routing tables</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-BF5F2DF5-483A-3CF3-B5C7-1C4DC4F4E89F"><a name="GUID-BF5F2DF5-483A-3CF3-B5C7-1C4DC4F4E89F"><!-- --></a>
<h3 class="sectiontitle">MSG_EOR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">data completes record</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-CFE661F8-3F17-3384-9DEF-1BC4638690CA"><a name="GUID-CFE661F8-3F17-3384-9DEF-1BC4638690CA"><!-- --></a>
<h3 class="sectiontitle">MSG_TRUNC</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">data discarded before delivery</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-1D56F561-5F18-3289-A3E9-1B4E9C37B436"><a name="GUID-1D56F561-5F18-3289-A3E9-1B4E9C37B436"><!-- --></a>
<h3 class="sectiontitle">MSG_CTRUNC</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">control data lost before delivery</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-0579CD59-FC2E-3458-B99B-09EDB7168CAC"><a name="GUID-0579CD59-FC2E-3458-B99B-09EDB7168CAC"><!-- --></a>
<h3 class="sectiontitle">MSG_WAITALL</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">wait for full request or error</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-ED2DFD86-9D78-3BEC-81A2-DCAE63E8071A"><a name="GUID-ED2DFD86-9D78-3BEC-81A2-DCAE63E8071A"><!-- --></a>
<h3 class="sectiontitle">CMSG_DATA</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">given pointer to struct cmsghdr, return pointer to data</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-5DF360C4-51B5-3475-8EA8-57741E304BA6"><a name="GUID-5DF360C4-51B5-3475-8EA8-57741E304BA6"><!-- --></a>
<h3 class="sectiontitle">CMSG_NXTHDR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">given pointer to struct cmsghdr, return pointer to next cmsghdr</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-91BBE2F8-4E4B-3D3A-9D4E-D19F02329D11"><a name="GUID-91BBE2F8-4E4B-3D3A-9D4E-D19F02329D11"><!-- --></a>
<h3 class="sectiontitle">CMSG_FIRSTHDR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">RFC 2292 requires to check msg_controllen, in case that the kernel returns an empty list for some reasons.</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-A42B1675-A046-309F-A629-F33A2DB7C81B"><a name="GUID-A42B1675-A046-309F-A629-F33A2DB7C81B"><!-- --></a>
<h3 class="sectiontitle">SCM_RIGHTS</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
</p></div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-37C50304-BA30-3FD4-85A1-91D00978D754"><a name="GUID-37C50304-BA30-3FD4-85A1-91D00978D754"><!-- --></a>
<h3 class="sectiontitle">SHUT_RD</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">shut down the reading side</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-4E9E14EE-408E-33E7-B1CE-11CB38EB5AAD"><a name="GUID-4E9E14EE-408E-33E7-B1CE-11CB38EB5AAD"><!-- --></a>
<h3 class="sectiontitle">SHUT_WR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">shut down the writing side</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxDefine nested1" id="GUID-DA8FD378-FBDB-32E7-9B01-293E0B8962A6"><a name="GUID-DA8FD378-FBDB-32E7-9B01-293E0B8962A6"><!-- --></a>
<h3 class="sectiontitle">SHUT_RDWR</h3>
<div class="body refbody apiDetail apiOperationDetail cxxDefineDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
<p class="p">shut down both sides</p>
</div>
</p></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-337DC7FE-8D08-342D-BE28-C6F77508E7FA"><a name="GUID-337DC7FE-8D08-342D-BE28-C6F77508E7FA"><!-- --></a>
<a name="GUID-8B08EBCD-937C-3704-8E6A-08A45881F70D"><!-- --></a><h3 class="sectiontitle">accept ( int, struct sockaddr *, socklen_t * )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>accept</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">__restrict</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a> *</td><td><span class="parameter">__restrict</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">If no pending connections are present on the queue, and the original socket is not marked as non-blocking, accept blocks the caller until a connection is present. If the original socket is marked non-blocking and no pending connections are present on the queue, accept returns an error as described below.</p>
<p class="p">The accepted socket may not be used to accept more connections. The original socket s remains open.</p>
<p class="p">The argument addr is a result argument that is filled-in with the address of the connecting entity as it is known to the communications layer. The exact format of the addr argument is determined by the domain in which the communication is occurring. A null pointer may be specified for addr if the address information is not required. In this case addrlen is not used and should also be null. Otherwise, the addrlen argument is a value-result argument: It should initially contain the amount of space pointed to by addr and on return will contain the actual length (in bytes) of the address returned. This call is used with connection-based socket types, currently with SOCK_STREAM.</p>
<p class="p">It is possible to select a socket for the purposes of doing an accept by selecting it for read.</p>
<p class="p">For certain protocols, such as ISO or DATAKIT which require an explicit confirmation, accept can be thought of as merely dequeueing the next connection request and not implying confirmation. Confirmation can be implied by a normal read or write on the new file descriptor, and rejection can be implied by closing the new socket.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void GetSockName()
{
   int sock_fd;
   int newsock_fd;
   struct sockaddr_in addr;
   struct sockaddr_in ss;
   struct sockaddr_in new_socket;
   unsigned int len;
   unsigned int addr_len;
   
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port = htons(5000);
   bind(sock_fd,(sockaddr*)&amp;addr;,sizeof(addr));
   listen(sock_fd,1);
   newsock_fd = accept(sock_fd,(sockaddr*)&amp;new;_socket,&amp;addr;_len); // Code blocks here
   if (newsock_fd &lt;= 0)
   {
                perror("accept:");
   }
   close(newsock_fd);
   close(sock_fd);
}</pre>
</div>
<p class="p">See also: bind() connect() getpeername() listen() select() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">__restrict</td><td>The argument s is a socket that has been created with socket, bound to an address with bind and is listening for connections after a listen . The accept system call extracts the first connection request on the queue of pending connections and creates a new socket which it allocates a new file descriptor. The new socket inherits the state of the O_NONBLOCK property from the original socket s. </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The call returns -1 on error. If it succeeds, it returns a non-negative integer that is a descriptor for the accepted socket.</dd></dl></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-8067EF67-F58E-3FEE-B34A-6A76A5D2BCCB"><a name="GUID-8067EF67-F58E-3FEE-B34A-6A76A5D2BCCB"><!-- --></a>
<a name="GUID-DD961B2B-AAEE-3A83-81E2-0B9F7BE58BE6"><!-- --></a><h3 class="sectiontitle">bind ( int, const struct sockaddr *, socklen_t )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>bind</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a></td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
TInt GetSockName()
{
   int sock_fd;
   struct sockaddr_in addr,ss;
   unsigned int len;   
   
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port = htons(5000);
   bind(sock_fd,(struct sockaddr*)&amp;addr;,sizeof(addr));
   close(sock_fd);
}</pre>
</div>
<p class="p">Notes:</p>
<p class="p">For maximum portability always initialise the socket address structure to zero before populating it and passing it to bind.</p>
<p class="p">
</p><p class="p">See also: connect() getsockname() listen() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter"></td><td>The bind system call assigns the local protocol address to a socket. When a socket is created with socket it exists in an address family space but has no protocol address assigned. The bind system call requests that addr be assigned to the socket. </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The bind() function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-6E1913DA-D456-3357-B466-22D3D25FCF8C"><a name="GUID-6E1913DA-D456-3357-B466-22D3D25FCF8C"><!-- --></a>
<a name="GUID-B1E46044-267D-3F35-9712-F1A0D7E8F03F"><!-- --></a><h3 class="sectiontitle">connect ( int, const struct sockaddr *, socklen_t )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>connect</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a></td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">If the socket is of type SOCK_STREAM, this call attempts to make a connection to another socket. The other socket is specified by name, which is an address in the communications space of the socket. Each communications space interprets the name argument in its own way.</p>
<p class="p">Generally, stream sockets may successfully connect only once and datagram sockets may use connect multiple times to change their association. Datagram sockets may dissolve the association by connecting to an invalid address, such as a null address.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void Connect()
{
   struct sockaddr_in serv_addr;
   int sock_fd;
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   serv_addr.sin_port = htons(5000);
   sock_fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   connect(sock_fd,(struct sockaddr*)&amp;serv;_addr,sizeof(serv_addr));
   
   close(sock_fd);
}</pre>
</div>
<p class="p">See also: accept() getpeername() getsockname() select() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter"></td><td>The s argument is a socket. If it is of type SOCK_DGRAM name specifies the peer with which the socket is to be associated. It specifiies the address to which datagrams are to be sent and the only address from which datagrams are to be received. </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The connect() function returns the value 0 if successful; otherwise it returns the value -1 and the sets global variable errno to indicate the error.</dd></dl></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-48E1B15F-B568-3C55-8F0E-B0B36139793D"><a name="GUID-48E1B15F-B568-3C55-8F0E-B0B36139793D"><!-- --></a>
<a name="GUID-E84C2ABF-F6A9-375E-A759-5F15476D68A3"><!-- --></a><h3 class="sectiontitle">getpeername ( int, struct sockaddr *, socklen_t * )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>getpeername</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">__restrict</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a> *</td><td><span class="parameter">__restrict</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">The getpeername system call returns the name of the peer connected to socket s. The namelen argument should be initialized to indicate the amount of space pointed to by name. On return it contains the actual size of the name returned (in bytes). The name is truncated if the buffer provided is too small.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void GetSockName()
{
   int sock_fd;
   int newsock_fd;
   struct sockaddr_in addr;
   struct sockaddr_in ss;
   struct sockaddr_in new_socket;
   unsigned int len;
   unsigned int addr_len;
    
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port = htons(5000);
   bind(sock_fd,(struct sockaddr*)&amp;addr;,sizeof(addr));
   listen(sock_fd,1);
   newsock_fd = accept(sock_fd,(struct sockaddr*)&amp;new;_socket,&amp;addr;_len); // Code blocks here
  
   // Assuming client has connected to the server. 
   len = sizeof(ss);
   getpeername(sock_fd,(struct sockaddr*)&amp;ss;,&amp;len;);
   close(newsock_fd);
   close(sock_fd);
 }</pre>
</div>
<p class="p">See also: accept() bind() getsockname() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The getpeername() function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-BB182924-B3A9-38F9-AC41-CAF1E1BE0720"><a name="GUID-BB182924-B3A9-38F9-AC41-CAF1E1BE0720"><!-- --></a>
<a name="GUID-41BCB4CC-FB5C-3C01-ADDC-975832DC0FDB"><!-- --></a><h3 class="sectiontitle">getsockname ( int, struct sockaddr *, socklen_t * )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>getsockname</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">__restrict</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a> *</td><td><span class="parameter">__restrict</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">The getsockname system call returns the current name for the specified socket. The namelen argument should be initialized to indicate the amount of space pointed to by name. On return it contains the actual size of the name returned (in bytes).</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
TInt GetSockName()
{
   int sock_fd;
   struct sockaddr_in addr,ss;
   unsigned int len;   
   
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port = htons(5000);
   bind(sock_fd,(struct sockaddr*)&amp;addr;,sizeof(addr));
 
  len=sizeof(ss);
  getsockname(sock_fd,(struct sockaddr*)&amp;ss;,&amp;len;);
  close(sock_fd);
}</pre>
</div>
<p class="p">See also: bind() getpeername() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The getsockname() function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-918E6C11-AE1E-3EDA-A391-23E613A1BFF9"><a name="GUID-918E6C11-AE1E-3EDA-A391-23E613A1BFF9"><!-- --></a>
<a name="GUID-0AF19F0A-7EAE-31FD-A92C-C26E98776EF5"><!-- --></a><h3 class="sectiontitle">getsockopt ( int, int, int, void *, socklen_t * )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>getsockopt</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>void *</td><td><span class="parameter">__restrict</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a> *</td><td><span class="parameter">__restrict</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">The getsockopt and setsockopt system calls manipulate the options associated with a socket. Options may exist at multiple protocol levels; they are always present at the uppermost "socket" level. When manipulating socket options the level at which the option resides and the name of the option must be specified. To manipulate options at the socket level, level is specified as SOL_SOCKET. To manipulate options at any other level the protocol number of the appropriate protocol controlling the option is supplied. For example, to indicate that an option is to be interpreted by the TCP protocol, level should be set to the protocol number of TCP;</p>
<p class="p">The optval and optlen arguments are used to access option values for setsockopt. For getsockopt they identify a buffer in which the value for the requested option(s) are to be returned. For getsockopt, optlen is a value-result argument, initially containing the size of the buffer pointed to by optval, and modified on return to indicate the actual size of the value returned. If no option value is to be supplied or returned, optval may be NULL.</p>
<div class="p">The optname argument and any specified options are passed uninterpreted to the appropriate protocol module for interpretation. The include file #include &lt;<a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41">sys/socket.h</a>&gt;contains definitions for socket level options, described below. Options at other protocol levels vary in format and name; consult the appropriate entries in section 4 of the manual. Most socket-level options utilize an int argument for optval. For setsockopt, the argument should be non-zero to enable a boolean option, or zero if the option is to be disabled. SO_LINGER uses a struct linger argument, defined in <pre class="pre codeblock">  #include &lt;sys/socket.h,&gt; which specifies the desired state of the option and the linger interval (see below). SO_SNDTIMEO and SO_RCVTIMEO use a struct timeval argument, defined in  
  #include &lt;sys/time.h.&gt; 
The following options are recognized at the socket level. Except as noted, each may be examined with getsockopt and set with setsockopt. SO_DEBUG            enables recording of debugging information 
SO_REUSEADDR       Allows a socket to be bound to an local address that is already in use. 
SO_REUSEPORT       enables duplicate address and port bindings 
SO_KEEPALIVE       enables keep connections alive 
SO_DONTROUTE       enables routing bypass for outgoing messages 
SO_BROADCAST       enables permission to transmit broadcast messages (enable only)
SO_OOBINLINE       enables reception of out-of-band data in band 
SO_SNDBUF          set buffer size for output 
SO_RCVBUF          set buffer size for input 
SO_SNDLOWAT        set minimum count for output 
SO_RCVLOWAT        set minimum count for input 
SO_SNDTIMEO        set timeout value for output 
SO_RCVTIMEO        set timeout value for input 
SO_ACCEPTFILTER            set accept filter on listening socket 
SO_TYPE            get the type of the socket (get only) 
SO_ERROR           get and clear error on the socket (get only)  </pre>
</div>
<p class="p">SO_DEBUG enables debugging in the underlying protocol modules. SO_REUSEADDR indicates that the rules used in validating addresses supplied in a bind system call should allow reuse of local addresses. SO_REUSEPORT allows completely duplicate bindings by multiple processes if they all set SO_REUSEPORT before binding the port. This option permits multiple instances of a program to each receive UDP/IP multicast or broadcast datagrams destined for the bound port. SO_KEEPALIVE enables the periodic transmission of messages on a connected socket. SO_DONTROUTE indicates that outgoing messages should bypass the standard routing facilities. Instead, messages are directed to the appropriate network interface according to the network portion of the destination address.</p>
<p class="p">The option SO_BROADCAST requests permission to send broadcast datagrams on the socket. Broadcast was a privileged operation in earlier versions of the system. With protocols that support out-of-band data, the SO_OOBINLINE option requests that out-of-band data be placed in the normal data input queue as received; it will then be accessible with recv or read calls without the MSG_OOB flag. Some protocols always behave as if this option is set. SO_SNDBUF and SO_RCVBUF are options to adjust the normal buffer sizes allocated for output and input buffers, respectively. The buffer size may be increased for high-volume connections, or may be decreased to limit the possible backlog of incoming data. The system places an absolute maximum on these values, which is accessible through the sysctl MIB variable "kern.ipc.maxsockbuf."</p>
<p class="p">SO_SNDLOWAT is an option to set the minimum count for output operations. Most output operations process all of the data supplied by the call, delivering data to the protocol for transmission and blocking as necessary for flow control. Nonblocking output operations will process as much data as permitted subject to flow control without blocking, but will process no data if flow control does not allow the smaller of the low water mark value or the entire request to be processed. A select operation testing the ability to write to a socket will return true only if the low water mark amount could be processed. The default value for SO_SNDLOWAT is set to a convenient size for network efficiency, often 1024. SO_RCVLOWAT is an option to set the minimum count for input operations. In general, receive calls will block until any (non-zero) amount of data is received, then return with the smaller of the amount available or the amount requested. The default value for SO_RCVLOWAT is 1. If SO_RCVLOWAT is set to a larger value, blocking receive calls normally wait until they have received the smaller of the low water mark value or the requested amount.</p>
<p class="p">SO_SNDTIMEO is an option to set a timeout value for output operations. It accepts a struct timeval argument with the number of seconds and microseconds used to limit waits for output operations to complete. If a send operation has blocked for this much time, it returns with a partial count or with the error EWOULDBLOCK if no data were sent. In the current implementation, this timer is restarted each time additional data are delivered to the protocol, implying that the limit applies to output portions ranging in size from the low water mark to the high water mark for output. SO_RCVTIMEO is an option to set a timeout value for input operations. It accepts a struct timeval argument with the number of seconds and microseconds used to limit waits for input operations to complete. In the current implementation, this timer is restarted each time additional data are received by the protocol, and thus the limit is in effect an inactivity timer. If a receive operation has been blocked for this much time without receiving additional data, it returns with a short count or with the error EWOULDBLOCK if no data were received.</p>
<p class="p">SO_ACCEPTFILTER places an accept_filter on the socket, which will filter incoming connections on a listening stream socket before being presented for accept. Once more, listen must be called on the socket before trying to install the filter on it, or else the setsockopt system call will fail.</p>
<p class="p">SO_LINGER option is not supported by this api.</p>
<div class="p">
<pre class="pre codeblock">struct  accept_filter_arg {
        char    af_name[16];
        char    af_arg[256-16];
};</pre>
</div>
<p class="p">The optval argument should point to a struct accept_filter_arg that will select and configure the accept_filter. The af_name argument should be filled with the name of the accept filter that the application wishes to place on the listening socket. The optional argument af_arg can be passed to the accept filter specified by af_name to provide additional configuration options at attach time. Passing in an optval of NULL will remove the filter.</p>
<p class="p">Finally, SO_TYPE and SO_ERROR are options used only with getsockopt. SO_TYPE returns the type of the socket, such as SOCK_STREAM; it is useful for servers that inherit sockets on startup. SO_ERROR returns any pending error on the socket and clears the error status. It may be used to check for asynchronous errors on connected datagram sockets or for other asynchronous errors.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void SocketOptions()
{
   int sock_fd;
   int optval = 1;
   unsigned int optlen = sizeof(optval);
   int rdoptval;
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   setsockopt(sock_fd,SOL_SOCKET,SO_KEEPALIVE,&amp;optval;,optlen);
   getsockopt(sock_fd,SOL_SOCKET,SO_KEEPALIVE,(void*)&amp;rdoptval;,&amp;optlen;);
close(sock_fd);
}</pre>
</div>
<p class="p">See also: ioctl() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">__restrict</td><td>Note: This description also covers the following functions - setsockopt() </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>Upon successful completion, the value 0 is returned; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-30C49982-44D8-3AE4-BD4A-574996DFAEA6"><a name="GUID-30C49982-44D8-3AE4-BD4A-574996DFAEA6"><!-- --></a>
<a name="GUID-00E2D3E5-7BC6-3E72-9833-A85A7392D3E9"><!-- --></a><h3 class="sectiontitle">listen ( int, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>listen</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">To accept connections a socket is first created with socket . A willingness to accept incoming connections and a queue limit for incoming connections are specified with listen and then the connections are accepted with accept . The listen system call applies only to sockets of type SOCK_STREAM or SOCK_SEQPACKET.</p>
<p class="p">The n argument defines the maximum length the queue of pending connections may grow to. The real maximum queue length will be 1.5 times more than the value specified in the n argument. A subsequent listen system call on the listening socket allows the caller to change the maximum queue length using a new n argument. If a connection request arrives with the queue full the client may receive an error with an indication of ECONNREFUSED , or, in the case of TCP, the connection will be silently dropped.</p>
<p class="p">Note that before BSD 4.5 and the introduction of the syncache the n argument also determined the length of the incomplete connection queue, which held TCP sockets in the process of completing TCP's 3-way handshake. These incomplete connections are now held entirely in the syncache, which is unaffected by queue lengths. Inflated n values to help handle denial of service attacks are no longer necessary.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void listen_example()
{
   int sock_fd;
   int newsock_fd;
   struct sockaddr_in addr;
   struct sockaddr_in ss;
   struct sockaddr_in new_socket;
   unsigned int len;
   unsigned int addr_len;
   
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port = htons(5000);
   bind(sock_fd,(struct sockaddr*)&amp;addr;,sizeof(addr));
   listen(sock_fd,1);
   close(sock_fd);
}</pre>
</div>
<p class="p">See also: accept() connect() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The listen() function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-93004357-1C15-3C11-8975-0A04067016B5"><a name="GUID-93004357-1C15-3C11-8975-0A04067016B5"><!-- --></a>
<a name="GUID-4BE12A23-0E4D-37CC-891C-6B9931CA2E7A"><!-- --></a><h3 class="sectiontitle">recv ( int, void *, size_t, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-A3742116-1D59-315C-9989-D2FC1E8E755C.html">ssize_t</a></td><td>recv</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>void *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-381654FC-8996-3621-93A3-636F88EE7207.html">size_t</a></td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="p">
<pre class="pre codeblock"> MSG_OOB                process out-of-band data</pre>
</div>
<p class="p">The recvfrom and recvmsg system calls are used to receive messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented.</p>
<p class="p">If from is not a null pointer and the socket is not connection-oriented, the source address of the message is filled in. The fromlen argument is a value-result argument, initialized to the size of the buffer associated with from, and modified on return to indicate the actual size of the address stored there.</p>
<p class="p">The recv function is normally used only on a connected socket (see connect ) and is identical to recvfrom with a null pointer passed as its from argument. As it is redundant, it may not be supported in future releases.</p>
<p class="p">All three routines return the length of the message on successful completion. If a message is too long to fit in the supplied buffer, excess bytes may be discarded depending on the type of socket the message is received from (see socket )</p>
<p class="p">If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is nonblocking (see fcntl ) in which case the value -1 is returned and the external variable errno set to EAGAIN. The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the socket-level options SO_RCVLOWAT and SO_RCVTIMEO described in getsockopt .</p>
<p class="p">The select system call may be used to determine when more data arrive.</p>
<p class="p">The flags argument to a recv function is formed by or Ap ing one or more of the values: MSG_OOB process out-of-band data MSG_PEEK peek at incoming message MSG_WAITALL wait for full request or error MSG_DONTWAIT do not block</p>
<p class="p">The MSG_OOB flag requests receipt of out-of-band data that would not be received in the normal data stream. Some protocols place expedited data at the head of the normal data queue, and thus this flag cannot be used with such protocols. The MSG_PEEK flag causes the receive operation to return data from the beginning of the receive queue without removing that data from the queue. Thus, a subsequent receive call will return the same data. The MSG_WAITALL flag requests that the operation block until the full request is satisfied. The MSG_DONTWAIT flag requests the call to return when it would block otherwise. If no data is available, errno is set to EAGAIN.</p>
<p class="p">The flags MSG_OOB, MSG_PEEK, MSG_WAITALL and MSG_DONTWAIT are not supported for local sockets(AF_LOCAL, AF_LINUX etc..).</p>
<div class="p">The recvmsg system call uses a msghdr structure to minimize the number of directly supplied arguments. This structure has the following form, as defined in #include &lt;<a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41">sys/socket.h</a>&gt; <pre class="pre codeblock"> struct msghdr {
caddr_tmsg_name;/* optional address */
u_intmsg_namelen;/* size of address */
structiovec *msg_iov;/* scatter/gather array */
u_intmsg_iovlen;/* # elements in msg_iov */
caddr_tmsg_control;/* ancillary data, see below */
u_intmsg_controllen; /* ancillary data buffer len */
intmsg_flags;/* flags on received message */
};</pre>
</div>
<div class="p">Here msg_name and msg_namelen specify the destination address if the socket is unconnected; msg_name may be given as a null pointer if no names are desired or required. The msg_iov and msg_iovlen arguments describe scatter gather locations, as discussed in read . The msg_control argument, which has length msg_controllen, points to a buffer for other protocol control related messages or other miscellaneous ancillary data. The messages are of the form: <pre class="pre codeblock">struct cmsghdr {
u_intcmsg_len;/* data byte count, including hdr */
intcmsg_level;/* originating protocol */
intcmsg_type;/* protocol-specific type */
/* followed by
u_charcmsg_data[]; */
};</pre>
</div>
<p class="p">As an example, one could use this to learn of changes in the data-stream in XNS/SPP, or in ISO, to obtain user-connection-request data by requesting a recvmsg with no data buffer provided immediately after an accept system call.</p>
<p class="p">Open file descriptors are now passed as ancillary data for AF_UNIX domain sockets, with cmsg_level set to SOL_SOCKET and cmsg_type set to SCM_RIGHTS.</p>
<div class="p">Process credentials can also be passed as ancillary data for AF_UNIX domain sockets using a cmsg_type of SCM_CREDS. In this case, cmsg_data should be a structure of type cmsgcred, which is defined in #include &lt;<a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41">sys/socket.h</a>&gt; as follows: <pre class="pre codeblock"> struct cmsgcred {
pid_tcmcred_pid;/* PID of sending process */
uid_tcmcred_uid;/* real UID of sending process */
uid_tcmcred_euid;/* effective UID of sending process */
gid_tcmcred_gid;/* real GID of sending process */
shortcmcred_ngroups;/* number or groups */
gid_tcmcred_groups[CMGROUP_MAX];/* groups */
};</pre>
</div>
<p class="p">The kernel will fill in the credential information of the sending process and deliver it to the receiver.</p>
<p class="p">The msg_flags field is set on return according to the message received. MSG_EOR indicates end-of-record; the data returned completed a record (generally used with sockets of type SOCK_SEQPACKET). MSG_TRUNC indicates that the trailing portion of a datagram was discarded because the datagram was larger than the buffer supplied. MSG_CTRUNC indicates that some control data were discarded due to lack of space in the buffer for ancillary data. MSG_OOB is returned to indicate that expedited or out-of-band data were received.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void Recv()
{
   struct sockaddr_in serv_addr;
   int sock_fd;
   char line[10];
   int size = 10;
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   serv_addr.sin_port = htons(5000);
   sock_fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   connect(sock_fd,(struct sockaddr*)&amp;serv;_addr,sizeof(serv_addr));
   recv(sock_fd, line, size, 0);
   close(sock_fd);
}</pre>
<pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void Sendto()
{
   struct sockaddr_in sender_addr;
   int sock_fd;
   char line[15] = "Hello World!";
   unsigned int size = sizeof(sender_addr);
   sock_fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
   sender_addr.sin_family = AF_INET;
   sender_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   sender_addr.sin_port = htons(5000);
   recvfrom(sock_fd,line,13,0,(struct sockaddr*)&amp;sender;_addr,&amp;size;);
   close(sock_fd);
}</pre>
<pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void SendMsgRecvMsg()
{
   int sock_fd;
   unsigned int sender_len;
   struct msghdr msg;
   struct iovec iov;
   struct sockaddr_in receiver_addr,sender_addr;
   char line[10];
   sock_fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
   receiver_addr.sin_family = AF_INET;
   receiver_addr.sin_addr.s_addr = htonl(INADDR_ANY);
   receiver_addr.sin_port = htons(5000);
   bind(sock_fd,(struct sockaddr*)&amp;receiver;_addr,sizeof(receiver_addr));
   sender_len = sizeof(sender_addr);
   msg.msg_name = &amp;sender;_addr;
   msg.msg_namelen = sender_len;
   msg.msg_iov = &amp;iov;
   msg.msg_iovlen = 1;
   msg.msg_iov-&gt;iov_base = line;
   msg.msg_iov-&gt;iov_len = 10;
   msg.msg_control = 0;
   msg.msg_controllen = 0;
   msg.msg_flags = 0;
   recvmsg(sock_fd,&amp;msg;,0);
   close(sock_fd);
}</pre>
</div>
<p class="p">See also: fcntl() getsockopt() read() select() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr class="bg"><td class="parameter"></td><td>Note: This description also covers the following functions - recvfrom() recvmsg() </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>These calls return the number of bytes received, or -1 if an error occurred.</dd></dl></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-00050C6F-0A3B-32A2-8ECC-8DB23541D93C"><a name="GUID-00050C6F-0A3B-32A2-8ECC-8DB23541D93C"><!-- --></a>
<a name="GUID-45F73DAA-7E14-307A-BE55-FFCAEA898A86"><!-- --></a><h3 class="sectiontitle">recvfrom ( int, void *, size_t, int, struct sockaddr *, socklen_t * )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-A3742116-1D59-315C-9989-D2FC1E8E755C.html">ssize_t</a></td><td>recvfrom</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>void *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-381654FC-8996-3621-93A3-636F88EE7207.html">size_t</a></td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">__restrict</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a> *</td><td><span class="parameter">__restrict</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">
</p><p class="p">See also: fcntl() getsockopt() read() select() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr class="bg"><td class="parameter">__restrict</td><td>Refer to recv() for the documentation </td></tr></table></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-63B12A32-6792-3E2F-A063-DC834EC0B0C8"><a name="GUID-63B12A32-6792-3E2F-A063-DC834EC0B0C8"><!-- --></a>
<a name="GUID-CCE203C4-7985-3FF7-829B-CF3873D62098"><!-- --></a><h3 class="sectiontitle">recvmsg ( int, struct msghdr *, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-A3742116-1D59-315C-9989-D2FC1E8E755C.html">ssize_t</a></td><td>recvmsg</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>struct <a class="xref xref apiRelation" href="GUID-6BC2607A-0238-3B53-A252-61E9D80673B1.html">msghdr</a> *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">
</p><p class="p">See also: fcntl() getsockopt() read() select() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter"></td><td>Refer to recv() for the documentation </td></tr></table></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-86640361-7309-3D49-8820-5DBB494AD9B2"><a name="GUID-86640361-7309-3D49-8820-5DBB494AD9B2"><!-- --></a>
<a name="GUID-0D328B4A-15D0-36EB-B92E-E285A11F1ABC"><!-- --></a><h3 class="sectiontitle">send ( int, const void *, size_t, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-A3742116-1D59-315C-9989-D2FC1E8E755C.html">ssize_t</a></td><td>send</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const void *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-381654FC-8996-3621-93A3-636F88EE7207.html">size_t</a></td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">The send function, and sendto and sendmsg system calls are used to transmit a message to another socket. The send function may be used only when the socket is in a connected state, while sendto and sendmsg may be used at any time.</p>
<p class="p">The address of the target is given by to with tolen specifying its size. The length of the message is given by len. If the message is too long to pass atomically through the underlying protocol, the error EMSGSIZE is returned, and the message is not transmitted.</p>
<p class="p">No indication of failure to deliver is implicit in a send. Locally detected errors are indicated by a return value of -1.</p>
<p class="p">If no messages space is available at the socket to hold the message to be transmitted, then send normally blocks, unless the socket has been placed in non-blocking I/O mode. The select system call may be used to determine when it is possible to send more data.</p>
<div class="p">The flags argument may include one or more of the following: <pre class="pre codeblock">#defineMSG_OOB0x00001 //process out-of-band data 
#defineMSG_PEEK0x00002 // peek at incoming message 
#defineMSG_DONTROUTE0x00004 // bypass routing, use direct interface 
#define MSG_EOR0x00008 // data completes record 
#defineMSG_EOF0x00100 // data completes transaction</pre>
</div>
<p class="p">The flag MSG_OOB is used to send "out-of-band" data on sockets that support this notion (e.g. SOCK_STREAM); the underlying protocol must also support "out-of-band" data. MSG_EOR is used to indicate a record mark for protocols which support the concept. MSG_EOF requests that the sender side of a socket be shut down, and that an appropriate indication be sent at the end of the specified data; this flag is only implemented for SOCK_STREAM sockets in the PF_INET protocol family, and is used to implement Transaction TCP MSG_DONTROUTE is usually used only by diagnostic or routing programs.</p>
<p class="p">See recv for a description of the msghdr structure.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void Recv()
{
   struct sockaddr_in serv_addr;
   int sock_fd;
   char line[15] = "Hello world!";
   int size = 13;
   serv_addr.sin_family = AF_INET;
   serv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   serv_addr.sin_port = htons(5000);
   sock_fd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   connect(sock_fd,(struct sockaddr*)&amp;serv;_addr,sizeof(serv_addr));
   send(sock_fd, line, size, 0);
   close(sock_fd);
}</pre>
<pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void Sendto()
{
   sockaddr_in receiver_addr;
   int sock_fd;
   char line[15] = "Hello World!";
   sock_fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
   receiver_addr.sin_family = AF_INET;
   receiver_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   receiver_addr.sin_port = htons(5000);
   sendto(sock_fd, line, 13, 0,(struct sockaddr*)&amp;receiver;_addr,sizeof(receiver_addr));
   close(sock_fd);
}</pre>
<pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void sendmsg()
{
   struct sockaddr_in receiver_addr;
   int sock_fd;
   char line[15] = "Hello World!";
   struct msghdr msg;
   struct iovec iov;
   sock_fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
    
   receiver_addr.sin_family = AF_INET;
   receiver_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
   receiver_addr.sin_port = htons(5000);
   msg.msg_name = &amp;receiver;_addr;
   msg.msg_namelen = sizeof(receiver_addr);
   msg.msg_iov = &amp;iov;
   msg.msg_iovlen = 1;
   msg.msg_iov-&gt;iov_base = line;
   msg.msg_iov-&gt;iov_len = 13;
   msg.msg_control = 0;
   msg.msg_controllen = 0;
   msg.msg_flags = 0;
   sendmsg(sock_fd,&amp;msg;,0);
   close(sock_fd);
}</pre>
</div>
<p class="p">See also: fcntl() getsockopt() <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-93004357-1C15-3C11-8975-0A04067016B5">recv()</a> select() socket() write()</p>
<p class="p">Bugs:</p>
<p class="p">Because sendmsg does not necessarily block until the data has been transferred, it is possible to transfer an open file descriptor across an AF_UNIX domain socket (see recv then close it before it has actually been sent, the result being that the receiver gets a closed file descriptor. It is left to the application to implement an acknowledgment mechanism to prevent this from happening.</p>
<div class="p">
</div>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr class="bg"><td class="parameter"></td><td>Note: This description also covers the following functions - sendto() sendmsg() </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>This function call returns the number of characters sent; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-0082C18A-0AF8-3773-B975-2C0B3A3D9FC0"><a name="GUID-0082C18A-0AF8-3773-B975-2C0B3A3D9FC0"><!-- --></a>
<a name="GUID-2E55A695-EE36-37F3-A088-2BA282B8EA9F"><!-- --></a><h3 class="sectiontitle">sendto ( int, const void *, size_t, int, const struct sockaddr *, socklen_t )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-A3742116-1D59-315C-9989-D2FC1E8E755C.html">ssize_t</a></td><td>sendto</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const void *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-381654FC-8996-3621-93A3-636F88EE7207.html">size_t</a></td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const struct <a class="xref xref apiRelation" href="GUID-CDC86871-3323-3065-983C-B4A6FC34CF7E.html">sockaddr</a> *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a></td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">
</p><p class="p">See also: fcntl() getsockopt() <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-93004357-1C15-3C11-8975-0A04067016B5">recv()</a> select() socket() write()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr class="bg"><td class="parameter"></td><td>Refer to send() for the documentation </td></tr></table></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-8E998302-2F5E-35E0-B11C-0686D01CFF70"><a name="GUID-8E998302-2F5E-35E0-B11C-0686D01CFF70"><!-- --></a>
<a name="GUID-F580A280-7797-3D55-B1C3-1CACC0429830"><!-- --></a><h3 class="sectiontitle">sendmsg ( int, const struct msghdr *, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-A3742116-1D59-315C-9989-D2FC1E8E755C.html">ssize_t</a></td><td>sendmsg</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const struct <a class="xref xref apiRelation" href="GUID-6BC2607A-0238-3B53-A252-61E9D80673B1.html">msghdr</a> *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">
</p><p class="p">See also: fcntl() getsockopt() <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-93004357-1C15-3C11-8975-0A04067016B5">recv()</a> select() socket() write()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter"></td><td>Refer to send() for the documentation </td></tr></table></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-68D0173C-F5CC-3EDA-A255-E4F947097876"><a name="GUID-68D0173C-F5CC-3EDA-A255-E4F947097876"><!-- --></a>
<a name="GUID-30FEE1F1-186A-32BF-82E8-5EC50ED8B49C"><!-- --></a><h3 class="sectiontitle">setsockopt ( int, int, int, const void *, socklen_t )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>setsockopt</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>const void *</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-A059FC48-4777-3BE0-9F7E-E91967DFE49A.html">socklen_t</a></td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">
</p><p class="p">See also: ioctl() socket()</p>
<p class="p">Note:For multicast to work on Symbian OS the connection for the interface needs to be started first. On most of the desktop Operating Systems,the network interface is always running, so things like setsockopt() will always pass. But on Symbian, the interface is not always running (in order to save battery and/or data charges) so some options in setsockopt() will not work until the connection is started.</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter"></td><td>Refer to getsockopt() for the documentation </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-B457A201-5ED5-3A07-81BB-499439120929"><a name="GUID-B457A201-5ED5-3A07-81BB-499439120929"><!-- --></a>
<a name="GUID-45E5490B-7951-395D-9B88-0A95ACB50C73"><!-- --></a><h3 class="sectiontitle">shutdown ( int, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>shutdown</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="p">
<pre class="pre codeblock"> SHUT_RD further receives will be disallowed.
 SHUT_WR further sends will be disallowed.
 SHUT_RDWR
  further sends and receives will be disallowed.</pre>
 The shutdown system call causes all or part of a full-duplex connection on the socket associated with the file descriptor sockfd to be shut down. The how argument specifies the type of shutdown. Possible values are: SHUT_RD further receives will be disallowed. SHUT_WR further sends will be disallowed. SHUT_RDWR further sends and receives will be disallowed.</div>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
TInt shutdown_example()
{
   int sock_fd;
   sockaddr_in addr,ss;
   unsigned int len;   
   
   sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
       
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(INADDR_ANY);
   addr.sin_port = htons(5000);
   bind(sock_fd,(sockaddr*)&amp;addr;,sizeof(addr));
   shutdown(sock_fd, SHUT_RD)
   close(sock_fd);
}</pre>
</div>
<p class="p">See also: connect() socket()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The shutdown() function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-8BB63861-D498-3930-ACC2-488AAB0EE00E"><a name="GUID-8BB63861-D498-3930-ACC2-488AAB0EE00E"><!-- --></a>
<a name="GUID-4AFE560D-B0EA-3F77-9BFF-D3B4D3613E18"><!-- --></a><h3 class="sectiontitle">sockatmark ( int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>sockatmark</td><td>(</td><td>int</td><td><span class="parameter"></span></td><td>)</td><td></td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="p">To find out if the read pointer is currently pointing at the mark in the data stream, the sockatmark function is provided. If sockatmark returns 1, the next read will return data after the mark. Otherwise (assuming out of band data has arrived), the next read will provide data sent by the client prior to transmission of the out of band signal. The routine used in the remote login process to flush output on receipt of an interrupt or quit signal is shown below. It reads the normal data up to the mark (to discard it), then reads the out-of-band byte. <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
oob()
{
int out = FWRITE, mark;
char waste[BUFSIZ];
/* flush local terminal output */
ioctl(1, TIOCFLUSH, (char *)&amp;out;);
for (;;) {
if ((mark = sockatmark(rem)) &lt; 0) {
perror("sockatmark");
break;
}
if (mark)
break;
(void) read(rem, waste, sizeof (waste));
}
if (recv(rem, &amp;mark;, 1, MSG_OOB) &lt; 0) {
perror("recv");
...
}
...
}</pre>
</div>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;unistd.h&gt;
void SockAtMark()
{
   int sockfd;
   sockaddr_in selfAddr;
   sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
       
   selfAddr.sin_family = AF_INET;
   selfAddr.sin_addr.s_addr = INADDR_ANY;
   selfAddr.sin_port = htons(5000);
   bind(sockfd,(struct sockaddr*)&amp;selfAddr;, sizeof(selfAddr));
   sockatmark(sockfd);
   close(sockfd);
}</pre>
</div>
<p class="p">See also: <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-93004357-1C15-3C11-8975-0A04067016B5">recv()</a> <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-86640361-7309-3D49-8820-5DBB494AD9B2">send()</a> ioctl()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>Upon successful completion, the sockatmark function returns the value 1 if the read pointer is pointing at the OOB mark, 0 if it is not.Otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-E895DE9B-62A9-3E54-8410-0081F54DDC43"><a name="GUID-E895DE9B-62A9-3E54-8410-0081F54DDC43"><!-- --></a>
<a name="GUID-860EEF2B-BA20-37F7-9A5D-033314B39513"><!-- --></a><h3 class="sectiontitle">socket ( int, int, int )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C int</td><td>socket</td><td>(</td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter">,</span></td></tr><tr><td colspan="3"> </td><td>int</td><td><span class="parameter"></span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">The socket system call creates an endpoint for communication and returns a descriptor.</p>
<p class="p">The family argument specifies a communications domain within which communication will take place; this selects the protocol family which should be used. These families are defined in the include file #include &lt;<a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41">sys/socket.h</a>&gt; The currently understood formats are:</p>
<p class="p">PF_LOCALHost-internal protocols, formerly called PF_UNIX, PF_INETInternet version 4 protocols,</p>
<p class="p">The socket has the indicated style, which specifies the semantics of communication. Currently defined types are:</p>
<div class="p">
<pre class="pre codeblock">SOCK_STREAMStream socket,
SOCK_DGRAMDatagram socket,
SOCK_SEQPACKETSequenced packet stream</pre>
</div>
<p class="p">A SOCK_STREAM type provides sequenced, reliable, two-way connection based byte streams. An out-of-band data transmission mechanism may be supported. A SOCK_DGRAM socket supports datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length). A SOCK_SEQPACKET socket may provide a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length; a consumer may be required to read an entire packet with each read system call. This facility is protocol specific, and presently unimplemented.</p>
<p class="p">The protocol argument specifies a particular protocol to be used with the socket. Normally only a single protocol exists to support a particular socket type within a given protocol family. However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner. The protocol number to use is particular to the "communication domain" in which communication is to take place.</p>
<p class="p">Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes. A stream socket must be in a connected state before any data may be sent or received on it. A connection to another socket is created with a connect system call. Once connected, data may be transferred using read and write calls or some variant of the send and recv functions. (Some protocol families, such as the Internet family, support the notion of an "implied connect," which permits data to be sent piggybacked onto a connect operation by using the sendto system call.) When a session has been completed a close may be performed. Out-of-band data may also be transmitted as described in send and received as described in recv</p>
<p class="p">The communications protocols used to implement a SOCK_STREAM insure that data is not lost or duplicated. If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered broken and calls will indicate an error with -1 returns and with ETIMEDOUT as the specific code in the global variable errno. The protocols optionally keep sockets "warm" by forcing transmissions roughly every minute in the absence of other activity. An error is then indicated if no response can be elicited on an otherwise idle connection for an extended period (e.g. 5 minutes).</p>
<p class="p">SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets. The only difference is that read calls will return only the amount of data requested and any remaining in the arriving packet will be discarded.</p>
<p class="p">SOCK_DGRAM sockets allow sending of datagrams to correspondents named in send calls. Datagrams are generally received with recvfrom which returns the next datagram with its return address.</p>
<div class="p">Examples: <pre class="pre codeblock">#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#inlcude &lt;netinet/in.h&gt;
void SocketExample()
{
    int sock_fd;
    sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    close(sock_fd);
}</pre>
</div>
<p class="p">See also: accept() bind() connect() getpeername() getsockname() getsockopt() ioctl() listen() read() <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-93004357-1C15-3C11-8975-0A04067016B5">recv()</a> select() <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-86640361-7309-3D49-8820-5DBB494AD9B2">send()</a> <a class="xref" href="GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html#GUID-B457A201-5ED5-3A07-81BB-499439120929">shutdown()</a> write()</p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The socket() function returns valid socket descriptor if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</dd></dl></div>
<div class="section capability"><table class="capability"><tr><th class="capability">Capability</th></tr><tr><td class="capabilitycode">Deferred</td><td class="capabilityvalue"></td></tr></table></div></div>
</div>
</div></div><div class="footer"><hr /><div class="copy">© Nokia 2005.</div></div>
</div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></p></div></div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-70ED2366-90B0-30FA-BAFD-3DE3A1894A41.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:19:50 GMT -->
</html>