<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:22:12 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta name="DC.Type" content="cxxClass" />
<meta name="DC.Title" content="BaflUtils" />
<meta name="abstract" content="" />
<meta name="description" content="" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930" />
<title>BaflUtils</title>
<meta name="keywords" content="api" /><link rel="stylesheet" type="text/css" href="css/nokiacxxref.css" />
<link href="css/s60/style.css" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp3.html" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category-cover_cpp3.html" rel="stylesheet" type="text/css" /></head>
<body id="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930"><a name="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930"><!-- --></a><div class="body"><div class="contentLeft prTxt">
<h1 class="sectiontitle">BaflUtils Class Reference</h1>
<div class="state state apiQualifier apiQualifier cxxClassDeclarationFile section include"><p>#include 
            
                    &lt;bautils.h&gt;
                </p></div>
<div class="section signature"><table class="signature"><tr><td>class BaflUtils</td></tr></table></div><div class="section member-index"><table class="member-index"><thead><tr><th colspan="2">Public Member Functions</th></tr></thead><tbody><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-A24ACF1A-B688-3E70-9B90-864F59717D3E">AbbreviateFileName</a>(const <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;, <a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-78497FDB-793D-3CAF-8BE7-1EE64BE99E25">CheckFolder</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-E1A06B27-E252-3197-8531-7083FBF9CEEE">CheckWhetherFullNameRefersToFolder</a>(const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-F5C8F99D-DB58-37EC-99B8-64198DBB441B">CopyFile</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a>)</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-B71B8047-54A9-3957-80E6-AA839D40C9F6">CopyWithTruncation</a>(<a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-CDCFA2A5-EA8A-3B39-B90F-77AC41571E2D.html">TChar</a>)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-64E47A88-1907-3B67-B099-F0DA43F4BEA9">DeleteFile</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a>)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-AFDC3F9D-EE6B-368D-BE59-861E8C8F7C4E">DiskIsReadOnly</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a></td><td><a href="#GUID-63B31EB1-5AAA-33F7-A066-E9F7EE563AF3">DriveAndPathFromFullName</a>(const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-6D3238F0-7E9E-348F-953C-CFECBB8E9162">DriveIsReadOnlyInternal</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-15B11A74-695D-384A-BC0A-AC7E9854A830">EnsurePathExistsL</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-8FE95467-D48B-3E61-9028-29C0F15F567E.html">TPtrC</a></td><td><a href="#GUID-A9756B6F-1405-36E0-97B7-B062FD05726E">ExtractAppNameFromFullName</a>(const <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFullName</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-821BD717-539A-3A1B-BCD7-6D21184DC117">FileExists</a>(const RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-F2FF365C-48FD-35E1-BE1A-BDD11DF2E42F">FolderExists</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a></td><td><a href="#GUID-818C87CA-1F8F-3557-A0DB-4CE5F48AB7C8">FolderNameFromFullName</a>(const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-5D3426EE-C93C-378A-AA4B-18B73E1EC69B">GetDiskListL</a>(const RFs &amp;, <a class="xref xref apiRelation" href="GUID-9EC9CD13-91FB-38F7-9E55-F41C584AC5A6.html">CDesCArray</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-F5D49956-A82F-3233-AB15-05936A614486">GetDowngradePathL</a>(const RFs &amp;, const <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a>, <a class="xref xref apiRelation" href="GUID-FAEBF321-6B08-3041-A01F-B1E7282D0707.html">RArray</a>&lt; <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a> &gt; &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-5FDF8543-1D35-31B5-A7EA-6544DBB2F33E">GetEquivalentLanguageList</a>(<a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a>, <a class="xref xref apiRelation" href="GUID-8B163D5D-2159-34F7-8CB1-75BDC8C5ADFA.html">TLanguagePath</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-3A94FD95-D77C-3B9C-B265-B9AB4E3BD3DE">GetSystemDrive</a>(TDriveNumber &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a></td><td><a href="#GUID-64C74550-A491-3D0D-964F-CF1DDD701000">IdealLanguage</a>()</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-1779644B-E529-3FDC-BACF-04901F46C061">InitialiseHAL</a>(RFs &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-28C851E1-C863-31F0-B0D1-620D059FA06D">InitialiseLocale</a>(RFs &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-706F89C0-15EB-3F15-918C-C17F39C9C49F">InitialiseScreenCalibration</a>(RFs &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-42C78236-BF3E-3302-9B0B-1EC0AF31CAF0">IsFirstDriveForSocket</a>(TDriveUnit)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-FB3FB5A0-3A9B-3983-9FF8-D9B1F4E0660A">IsFolder</a>(const RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-50C543A0-6BA1-3783-925C-C45B83BF78E3">MostSignificantPartOfFullName</a>(const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-8F3F7542-AD7A-3713-AF23-B9FF04843954">NearestLanguageFile</a>(const RFs &amp;, <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-FA210246-02C0-3450-9CC2-09C11964257D">NearestLanguageFile</a>(const RFs &amp;, <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;, <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-7A0E1FC7-2543-3E38-B224-EC1B9208C2A3">NearestLanguageFileV2</a>(const RFs &amp;, <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;, <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-7D63FF81-C023-3F5A-91F6-9A1A7058E223">Parse</a>(const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-7471FED3-DE19-3A96-AC7C-47073CA9C420">PathExists</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-7A6A2A78-1049-3A50-A88B-7995CA5C450A">PersistHAL</a>()</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-EC5109B8-97DB-30B0-9E0D-79285236E0C0">PersistLocale</a>()</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-4C399716-FB1B-3578-87E4-08C8E14F0E4C">PersistScreenCalibration</a>(const TDigitizerCalibration &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-35DFD345-35EB-33A8-9C19-E8D1AF8C7FE3">ReleaseIdealLanguage</a>()</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-60C2C64F-36B3-341C-A370-0966AED01396">RemoveSystemDirectory</a>(CDir &amp;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-55C98788-6473-32BC-9941-F96D86AC27CF">RenameFile</a>(RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a>)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a></td><td><a href="#GUID-C0E3B5C2-7443-365E-AC95-1C58EBA6A4CE">RootFolderPath</a>(const <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TBuf</a>&lt; 1 &gt;)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-9CC7EFB9-BB87-3539-BF5B-15A5C15B76DB">SetIdealLanguage</a>(<a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a>)</td></tr><tr><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-FDB3D1BA-5F09-3894-A723-B8953E3F83BD">SortByTable</a>(CDir &amp;, <a class="xref xref apiRelation" href="GUID-C487D1B5-2985-3127-8DE2-C92E9D2441C4.html">CBaflFileSortTable</a> *)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><a href="#GUID-E4904C7D-9D05-3493-918B-74C88F1A493F">UidTypeMatches</a>(const <a class="xref xref apiRelation" href="GUID-B6D6B0AD-B15C-339A-8540-40540885089A.html">TUidType</a> &amp;, const <a class="xref xref apiRelation" href="GUID-B6D6B0AD-B15C-339A-8540-40540885089A.html">TUidType</a> &amp;)</td></tr><tr><td align="right" class="code">IMPORT_C void</td><td><a href="#GUID-967870B4-F883-3E38-AEB4-611FA5EAD62A">UpdateDiskListL</a>(const RFs &amp;, <a class="xref xref apiRelation" href="GUID-9EC9CD13-91FB-38F7-9E55-F41C584AC5A6.html">CDesCArray</a> &amp;, <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a>, TDriveNumber)</td></tr><tr class="bg"><td align="right" class="code">IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td><a href="#GUID-21994B08-C532-385E-BCBA-A4D7978E17C8">ValidateFolderNameTypedByUserL</a>(const RFs &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;, <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;)</td></tr></tbody></table></div><div class="section section apiDesc section apidesc"><h2 class="sectiontitle">Detailed Description</h2>
<p class="p">Provides simple-to-use file system utilities.</p>
<p class="p">The functions listed in "Copying, renaming, and deleting files" create and use a CFileMan object. They are useful for one-off calls, but for repeated use it is more efficient to use CFileMan directly.</p>
<p class="p">Note that there is a very similiar group of functions available in EikFileUtils, which may be easier to use in GUI applications, as they do not require a file server session to be passed.</p>
<p class="p">
</p><p class="p">See also: CFileMan EikFileUtils   </p>
</div>
<h2 class="sectiontitle">Member Function Documentation</h2><div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-A24ACF1A-B688-3E70-9B90-864F59717D3E"><a name="GUID-A24ACF1A-B688-3E70-9B90-864F59717D3E"><!-- --></a>
<a name="GUID-04547F45-3A65-3A52-8C44-43F911D9B4D6"><!-- --></a><h3 class="sectiontitle">AbbreviateFileName ( const TFileName &amp;, TDes &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>AbbreviateFileName</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;</td><td><span class="parameter">aOriginalFileName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;</td><td><span class="parameter">aAbbreviatedFileName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Abbreviates a file name.</p>
<p class="p">If aOriginalFileName is less than the maximum length of aAbbreviatedFileName, then the name is simply copied to aAbbreviatedFileName.</p>
<p class="p">If this is not so, then the left-most characters of aOriginalFileName are copied to aAbbreviatedFileName, up to aAbbreviatedFileName's maximum length-1. aAbbreviatedFileName's first character is set to be an ellipsis.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aOriginalFileName</td><td>Original file name  </td></tr><tr class="bg"><td class="parameter">aAbbreviatedFileName</td><td>On return, abbreviated file name  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-78497FDB-793D-3CAF-8BE7-1EE64BE99E25"><a name="GUID-78497FDB-793D-3CAF-8BE7-1EE64BE99E25"><!-- --></a>
<a name="GUID-B3A7A2EE-DDA1-38A7-9F9F-846B30876DA9"><!-- --></a><h3 class="sectiontitle">CheckFolder ( RFs &amp;, const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>CheckFolder</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFolderName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks that the specified folder can be opened.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aFolderName</td><td>Folder to check  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-E1A06B27-E252-3197-8531-7083FBF9CEEE"><a name="GUID-E1A06B27-E252-3197-8531-7083FBF9CEEE"><!-- --></a>
<a name="GUID-9FDD482C-FFA2-3841-8711-6ACA174BD429"><!-- --></a><h3 class="sectiontitle">CheckWhetherFullNameRefersToFolder ( const TDesC &amp;, TBool &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>CheckWhetherFullNameRefersToFolder</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;</td><td><span class="parameter">aIsFolder</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if a string is a valid folder name.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFullName</td><td>String to check  </td></tr><tr class="bg"><td class="parameter">aIsFolder</td><td>ETrue if aFullName is a valid folder name, otherwise EFalse  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes (probably because aFullName cannot be parsed). </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-F5C8F99D-DB58-37EC-99B8-64198DBB441B"><a name="GUID-F5C8F99D-DB58-37EC-99B8-64198DBB441B"><!-- --></a>
<a name="GUID-41168A2F-B22D-3AF5-86FE-FCC23571459D"><!-- --></a><h3 class="sectiontitle">CopyFile ( RFs &amp;, const TDesC &amp;, const TDesC &amp;, TUint )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>CopyFile</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aSourceFullName</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aTargetFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a></td><td><span class="parameter">aSwitch</span> = CFileMan::EOverWrite</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Copies one or more files.</p>
<p class="p">For more details, </p>
<p class="p">See also: CFileMan::Copy() </p>
<dl class="dl since">
<dt class="dt dlterm">Since</dt>
<dd class="dd">5.1 </dd>
</dl>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aSourceFullName</td><td>Path indicating the file(s) to be copied. Any path components that are not specified here will be taken from the session path.  </td></tr><tr><td class="parameter">aTargetFullName</td><td>Path indicating the directory into which the file(s) are to be copied  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-B71B8047-54A9-3957-80E6-AA839D40C9F6"><a name="GUID-B71B8047-54A9-3957-80E6-AA839D40C9F6"><!-- --></a>
<a name="GUID-4DF66CB6-40D0-34DA-91F3-89D471CC4BB6"><!-- --></a><h3 class="sectiontitle">CopyWithTruncation ( TDes &amp;, const TDesC &amp;, TChar )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>CopyWithTruncation</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-C04A9A0C-DBA7-37DA-B744-54FBF3D544CD.html">TDes</a> &amp;</td><td><span class="parameter">aDest</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aSrc</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-CDCFA2A5-EA8A-3B39-B90F-77AC41571E2D.html">TChar</a></td><td><span class="parameter">aTruncationSymbol</span> = 
							<a class="xref xref apiRelation" href="GUID-8B163D5D-2159-34F7-8CB1-75BDC8C5ADFA.html">KBaflCharTruncation</a>
</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-64E47A88-1907-3B67-B099-F0DA43F4BEA9"><a name="GUID-64E47A88-1907-3B67-B099-F0DA43F4BEA9"><!-- --></a>
<a name="GUID-50110CA4-BDC5-360F-9406-2029CC0C5B7A"><!-- --></a><h3 class="sectiontitle">DeleteFile ( RFs &amp;, const TDesC &amp;, TUint )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>DeleteFile</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aSourceFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a></td><td><span class="parameter">aSwitch</span> = 0</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Deletes one or more files.</p>
<p class="p">For more details, </p>
<p class="p">See also: CFileMan::Delete(). </p>
<dl class="dl since">
<dt class="dt dlterm">Since</dt>
<dd class="dd">5.1 </dd>
</dl>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aSourceFullName</td><td>Path indicating the file(s) to be deleted. May either be a full path, or relative to the session path. Use wildcards to specify more than one file.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-AFDC3F9D-EE6B-368D-BE59-861E8C8F7C4E"><a name="GUID-AFDC3F9D-EE6B-368D-BE59-861E8C8F7C4E"><!-- --></a>
<a name="GUID-BF7E3C06-3EA2-3020-8F64-6F367847F35B"><!-- --></a><h3 class="sectiontitle">DiskIsReadOnly ( RFs &amp;, const TDesC &amp;, TBool &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>DiskIsReadOnly</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;</td><td><span class="parameter">aIsReadOnly</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if the specified drive is read-only. Checks that the KMediaAttWriteProtected and EMediaRom flags are both set.</p>
<p class="p">
</p><p class="p">See also: <a class="xref" href="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html#GUID-6D3238F0-7E9E-348F-953C-CFECBB8E9162">BaflUtils::DriveIsReadOnlyInternal</a> </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aFullName</td><td>File name, including drive  </td></tr><tr><td class="parameter">aIsReadOnly</td><td>On return, ETrue if the drive is read-only, otherwise EFalse  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-63B31EB1-5AAA-33F7-A066-E9F7EE563AF3"><a name="GUID-63B31EB1-5AAA-33F7-A066-E9F7EE563AF3"><!-- --></a>
<a name="GUID-E6C84DC9-2ADA-3C4A-A287-4EDCA88F3538"><!-- --></a><h3 class="sectiontitle">DriveAndPathFromFullName ( const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a></td><td>DriveAndPathFromFullName</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Gets the drive letter and path from a file name.</p>
<p class="p">This is in the form: drive-letter:\path\. The drive letter is folded using class <a class="xref" href="GUID-02D39887-4F76-3C42-B9B0-61E7AB8553C3.html#GUID-02D39887-4F76-3C42-B9B0-61E7AB8553C3">TCharF</a>.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFullName</td><td>File name  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The drive and path </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-6D3238F0-7E9E-348F-953C-CFECBB8E9162"><a name="GUID-6D3238F0-7E9E-348F-953C-CFECBB8E9162"><!-- --></a>
<a name="GUID-0243AE12-A7C8-376B-8AFF-6E8B1DB38A24"><!-- --></a><h3 class="sectiontitle">DriveIsReadOnlyInternal ( RFs &amp;, const TDesC &amp;, TBool &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>DriveIsReadOnlyInternal</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;</td><td><span class="parameter">aIsReadOnlyInternal</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if the specified drive is read-only and is an internal drive i.e. non-removable. Checks that the KMediaAttWriteProtected and KDriveAttInternal flags are both set.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aFullName</td><td>File name, including drive  </td></tr><tr><td class="parameter">aIsReadOnlyInternal</td><td>On return, ETrue if the drive is read-only and internal, otherwise EFalse  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide errors codes </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-15B11A74-695D-384A-BC0A-AC7E9854A830"><a name="GUID-15B11A74-695D-384A-BC0A-AC7E9854A830"><!-- --></a>
<a name="GUID-E255116D-B278-3B69-AF6D-30ACA663740E"><!-- --></a><h3 class="sectiontitle">EnsurePathExistsL ( RFs &amp;, const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>EnsurePathExistsL</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFileName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-A9756B6F-1405-36E0-97B7-B062FD05726E"><a name="GUID-A9756B6F-1405-36E0-97B7-B062FD05726E"><!-- --></a>
<a name="GUID-1785AD99-B55D-30B7-81AF-4714D951BFA3"><!-- --></a><h3 class="sectiontitle">ExtractAppNameFromFullName ( const TFullName &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-8FE95467-D48B-3E61-9028-29C0F15F567E.html">TPtrC</a></td><td>ExtractAppNameFromFullName</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFullName</a> &amp;</td><td><span class="parameter">aName</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-821BD717-539A-3A1B-BCD7-6D21184DC117"><a name="GUID-821BD717-539A-3A1B-BCD7-6D21184DC117"><!-- --></a>
<a name="GUID-E3BB279C-E336-3B6E-8AC9-0AC7C7D185AA"><!-- --></a><h3 class="sectiontitle">FileExists ( const RFs &amp;, const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>FileExists</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFileName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-F2FF365C-48FD-35E1-BE1A-BDD11DF2E42F"><a name="GUID-F2FF365C-48FD-35E1-BE1A-BDD11DF2E42F"><!-- --></a>
<a name="GUID-2BF445CB-8554-38E4-8BA5-AE3EC57CF796"><!-- --></a><h3 class="sectiontitle">FolderExists ( RFs &amp;, const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>FolderExists</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFolderName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Tests whether a folder exists.</p>
<p class="p">The folder is specified in a path. The path can omit the drive letter, in which case the drive letter is taken from the session path.</p>
<p class="p">If the path is badly formed, for instance if it contains illegal characters, or any directory name consists of a single or double dot, or any directory name includes wildcard characters, the function returns EFalse.</p>
<p class="p">If a filename is included in the path, it is ignored (the existence of the file will not be checked). However if included, it must not be badly formed - this will cause the function to return EFalse. If no filename is specified, the path should end in a backslash.</p>
<p class="p">Examples of valid paths (returning ETrue): C:\; \; C:.txt; C:\; .dat</p>
<p class="p">Examples of invalid paths (returning EFalse): C:\; ..\; C:*card\; C:&gt;File.txt</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>A connected session with the file server.  </td></tr><tr class="bg"><td class="parameter">aFolderName</td><td>A path specifying the folder to test for.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>ETrue if the folder specified in aFolderName exists, EFalse if not. EFalse is also returned if the specified path is badly formed. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-818C87CA-1F8F-3557-A0DB-4CE5F48AB7C8"><a name="GUID-818C87CA-1F8F-3557-A0DB-4CE5F48AB7C8"><!-- --></a>
<a name="GUID-B1318B77-F01B-3329-8F08-32D0DCEF5EB2"><!-- --></a><h3 class="sectiontitle">FolderNameFromFullName ( const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a></td><td>FolderNameFromFullName</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Gets the folder name from a path.</p>
<p class="p">A valid full name should have a drive associated with it e.g ("a:\\" - "z:\\")("a:" - "z:")("c:\\system\data\file.txt") Invalid entry will have no drive and cause a panic EBafPanicBadOpenArg For example, if the path is "c:\documents\word\mydoc1", then "word" is returned. "c:" then "c:" is returned "c:\\" then "c:\" is returned "c:\\mydoc1.txt				then "c:" is returned</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFullName</td><td>A path.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>The folder name. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-5D3426EE-C93C-378A-AA4B-18B73E1EC69B"><a name="GUID-5D3426EE-C93C-378A-AA4B-18B73E1EC69B"><!-- --></a>
<a name="GUID-831425ED-B44A-3B27-BC0D-6A0055BFC3F1"><!-- --></a><h3 class="sectiontitle">GetDiskListL ( const RFs &amp;, CDesCArray &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>GetDiskListL</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-9EC9CD13-91FB-38F7-9E55-F41C584AC5A6.html">CDesCArray</a> &amp;</td><td><span class="parameter">aArray</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Retrieves a list of all drives on the system.</p>
<p class="p">The file server is interrogated for a list of the drive letters for all available drives.</p>
<p class="p">On emulator: The removable media is represented by drive X: .</p>
<p class="p">On hardware: The removable media is represented by drives D: E: F: and G: .</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>A connected session with the file server.  </td></tr><tr class="bg"><td class="parameter">aArray</td><td>On return, contains the drive letters that correspond to the available drives. The drive letters are uppercase and are in alphabetical order.  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-F5D49956-A82F-3233-AB15-05936A614486"><a name="GUID-F5D49956-A82F-3233-AB15-05936A614486"><!-- --></a>
<a name="GUID-6CB2DA0E-39CF-324C-8977-F44D3AA6CB00"><!-- --></a><h3 class="sectiontitle">GetDowngradePathL ( const RFs &amp;, const TLanguage, RArray&lt; TLanguage &gt; &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>GetDowngradePathL</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a></td><td><span class="parameter">aCurrentLanguage</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FAEBF321-6B08-3041-A01F-B1E7282D0707.html">RArray</a>&lt; <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a> &gt; &amp;</td><td><span class="parameter">aLanguageArray</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Gets the full language downgrade path for a particular locale.</p>
<p class="p">
</p><p class="p">See also: <a class="xref" href="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html#GUID-8F3F7542-AD7A-3713-AF23-B9FF04843954">BaflUtils::NearestLanguageFile()</a> </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>A connected session with the file server.  </td></tr><tr class="bg"><td class="parameter">aCurrentLanguage</td><td>The language of the locale for which the language downgrade path is required. This language will always be returned as the first language in aLanguageArray. To get the downgrade path for the language of the current locale, specify the language returned by User::Language().  </td></tr><tr><td class="parameter">aLanguageArray</td><td>On return, contains the language downgrade path.  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-5FDF8543-1D35-31B5-A7EA-6544DBB2F33E"><a name="GUID-5FDF8543-1D35-31B5-A7EA-6544DBB2F33E"><!-- --></a>
<a name="GUID-CC07BE90-94BE-301E-8F0A-6D9D2E2CEFB7"><!-- --></a><h3 class="sectiontitle">GetEquivalentLanguageList ( TLanguage, TLanguagePath &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>GetEquivalentLanguageList</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a></td><td><span class="parameter">aLang</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-8B163D5D-2159-34F7-8CB1-75BDC8C5ADFA.html">TLanguagePath</a> &amp;</td><td><span class="parameter">aEquivalents</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-3A94FD95-D77C-3B9C-B265-B9AB4E3BD3DE"><a name="GUID-3A94FD95-D77C-3B9C-B265-B9AB4E3BD3DE"><!-- --></a>
<a name="GUID-B7105B29-4DAB-3538-9E07-70C537DEBD41"><!-- --></a><h3 class="sectiontitle">GetSystemDrive ( TDriveNumber &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>GetSystemDrive</td><td>(</td><td>TDriveNumber &amp;</td><td><span class="parameter">aDriveNumber</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-64C74550-A491-3D0D-964F-CF1DDD701000"><a name="GUID-64C74550-A491-3D0D-964F-CF1DDD701000"><!-- --></a>
<h3 class="sectiontitle">IdealLanguage (  )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a></td><td>IdealLanguage</td><td>(</td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Get the ideal language of the thread. This interface is intended for the use of UIKON only.</p>
<p class="p">
</p><p class="p">See also: <a class="xref" href="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html#GUID-8F3F7542-AD7A-3713-AF23-B9FF04843954">BaflUtils::NearestLanguageFile()</a> </p>
</div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>Ideal language if set, ELangNone if not set </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-1779644B-E529-3FDC-BACF-04901F46C061"><a name="GUID-1779644B-E529-3FDC-BACF-04901F46C061"><!-- --></a>
<a name="GUID-BD3D39A5-0796-304B-98F8-E50F2F0A2A17"><!-- --></a><h3 class="sectiontitle">InitialiseHAL ( RFs &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>InitialiseHAL</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Initialise the Deprecated9.1 This function is empty HAL settings from. </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-28C851E1-C863-31F0-B0D1-620D059FA06D"><a name="GUID-28C851E1-C863-31F0-B0D1-620D059FA06D"><!-- --></a>
<a name="GUID-8D462A5D-4047-38FD-A360-4E8458041D6E"><!-- --></a><h3 class="sectiontitle">InitialiseLocale ( RFs &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>InitialiseLocale</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-706F89C0-15EB-3F15-918C-C17F39C9C49F"><a name="GUID-706F89C0-15EB-3F15-918C-C17F39C9C49F"><!-- --></a>
<a name="GUID-165B4EAC-C4B6-3100-9406-706EDCA54A2C"><!-- --></a><h3 class="sectiontitle">InitialiseScreenCalibration ( RFs &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>InitialiseScreenCalibration</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-42C78236-BF3E-3302-9B0B-1EC0AF31CAF0"><a name="GUID-42C78236-BF3E-3302-9B0B-1EC0AF31CAF0"><!-- --></a>
<a name="GUID-5A892FC0-BCBE-38A2-95DE-9B39E3DA5F23"><!-- --></a><h3 class="sectiontitle">IsFirstDriveForSocket ( TDriveUnit )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>IsFirstDriveForSocket</td><td>(</td><td>TDriveUnit</td><td><span class="parameter">aDriveUnit</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Tests whether the specified drive corresponds to the primary partition in a removable media slot.</p>
<p class="p">The function assumes that the D: drive corresponds to the primary partition on socket 0, and that the E: drive corresponds to the primary partition on socket 1 (a socket is a slot for removable media). This mapping may not always be the case because it is set up in the variant layer of the Symbian OS.</p>
<p class="p">This function assumes that the drive mappings are contiguous, starting from drive D: .</p>
<p class="p">On emulator: The removable media is represented by drive X: only.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aDriveUnit</td><td>The drive to check.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>ETrue if the drive is the primary partition in a removable media slot. ETrue is also returned if the drive is A, B or C:. EFalse is returned otherwise. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-FB3FB5A0-3A9B-3983-9FF8-D9B1F4E0660A"><a name="GUID-FB3FB5A0-3A9B-3983-9FF8-D9B1F4E0660A"><!-- --></a>
<a name="GUID-D2903924-2222-3961-AA5F-C42C2857F88B"><!-- --></a><h3 class="sectiontitle">IsFolder ( const RFs &amp;, const TDesC &amp;, TBool &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>IsFolder</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a> &amp;</td><td><span class="parameter">aIsFolder</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if the specified item is a folder.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aFullName</td><td>Name to check  </td></tr><tr><td class="parameter">aIsFolder</td><td>ETrue if aFullName is a folder, otherwise EFalse  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-50C543A0-6BA1-3783-925C-C45B83BF78E3"><a name="GUID-50C543A0-6BA1-3783-925C-C45B83BF78E3"><!-- --></a>
<a name="GUID-9ED709E7-F880-3BC7-BDB3-135B3E97BAAB"><!-- --></a><h3 class="sectiontitle">MostSignificantPartOfFullName ( const TDesC &amp;, TFileName &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>MostSignificantPartOfFullName</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;</td><td><span class="parameter">aMostSignificantPart</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Gets the folder name if the specified item is a valid folder name, otherwise gets the file name.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFullName</td><td>Item to parse  </td></tr><tr class="bg"><td class="parameter">aMostSignificantPart</td><td>Folder or file name  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-8F3F7542-AD7A-3713-AF23-B9FF04843954"><a name="GUID-8F3F7542-AD7A-3713-AF23-B9FF04843954"><!-- --></a>
<a name="GUID-BC05133B-2C69-302E-B2D4-11B4A88A8730"><!-- --></a><h3 class="sectiontitle">NearestLanguageFile ( const RFs &amp;, TFileName &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>NearestLanguageFile</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;</td><td><span class="parameter">aName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Searches for the file with the correct language extension for the language of the current locale, or failing this, the best matching file.</p>
<p class="p">
</p><p class="p">See also: <a class="xref" href="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html#GUID-FA210246-02C0-3450-9CC2-09C11964257D">BaflUtils::NearestLanguageFile(const RFs&amp; aFs,TFileName&amp; aName, TLanguage&amp; aLanguage)</a> </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session.  </td></tr><tr class="bg"><td class="parameter">aName</td><td>File name as it would be without a language-specific extension. On return, this is changed to the language-specific version. If no such file is found, the name is unchanged.  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-FA210246-02C0-3450-9CC2-09C11964257D"><a name="GUID-FA210246-02C0-3450-9CC2-09C11964257D"><!-- --></a>
<h3 class="sectiontitle">NearestLanguageFile ( const RFs &amp;, TFileName &amp;, TLanguage &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>NearestLanguageFile</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;</td><td><span class="parameter">aName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a> &amp;</td><td><span class="parameter">aLanguage</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">This function gets the list of languages that are 'equivalent' to the given language. We say language L1 is equivalent to language L2 if speakers of L2 can readily understand L1 without intentional study or extraordinary effort.</p>
<div class="p">The equivalence relationship is defined in a static table. Please refer to the definition of 'KEquivalentLists' for details. Each row in the table is formatted like this: <pre class="pre codeblock">L1, L2, L3, ..., Ln, ELangNone
@codeend
In which L2, ..., Ln are equivalents of L1, and ELangNone marks the end of an
entry. The list is ordered. Compared with L3, L2 is nearer to L1. When choosing
an equivalent of L1, L2 shall be preferred over L3, L3 shall be preferred 
over L4, and so on.  
L1 is always returned as the nearest equivalent of L1 itself.

BaflUtils::NearestLanguageFileV2 searches language specific resource files 
according to the 'equivalent' relationship returned by this function.
 
@param aLang The language whose equivalents needs to be found out.
@param aEquivalents On return, this array contains the ordered list of 
       languages that are equivalent to the given language. If there is no 
       entry for the given language in the table, this array will contain 
       two elements on return: the first is the given language itself 
       and the 2nd one is ELangNone. For any language that has equivalents 
       defined, content of he corresponding entry is returned.     
       
@see BaflUtils::NearestLanguageFileV2
*/ 
EXPORT_C void 
BaflUtils::GetEquivalentLanguageList(TLanguage aLang, TLanguagePath&amp; aEquivalents) 
	{
	aEquivalents[0] = aLang;
	aEquivalents[1] = ELangNone;
	const TInt len = sizeof(KEquivalentLists) / sizeof(KEquivalentLists[0]);
	for (TInt i = 0; i &lt; len; ++i)
		{
		const TLanguage *ptr = KEquivalentLists[i];
		if (ptr[0] == aLang)
			{
			TInt index = 1;
			while (ELangNone != *ptr)
				{
				aEquivalents[index++] = (TLanguage)*(++ptr);
				}
			aEquivalents[index] = ELangNone;
			break;
			} // end if ptr[0]
		} // end for i
	}

/**
NearestLanguageFileV2 is very similar to the existing 'NearestLanguageFile'
function. The only difference between NearestLanguageFile and
NearestLanguageFileV2 is the order in which language specific 
resource files are searched for. 
NearestLanguageFile searches language specific resource files in the 
order defined by the 'downgrade path' of the given language. Content of the 
downgrade path is dependent on the current active locale, and parts of 
it is runtime configurable.
NearestLanguageFileV2 searches for language specific resource files 
in the order defined by the 'language equivalence table', which is a  
static data table fixed at build time. There is one entry in the table for 
each language that has one or more equivalents.

@param aFs An active file server session.
@param aName Name of the language-neutral resource file name which consist of
an optional drive specification, followed by an optional path name,
followed by basename for filename, followed by a period and extension.
On return, in case of a match, this is replaced by the language-specific version
which consists of the last two characters of the extension plus any preceding
numeric characters being replaced by the language code. Remains unchanged when there's no match 
@param aLanguage On return, in case of a match, this is replaced by the corresponding language.
  In case of no match, it is set to ELangNone.  

@see TLanguage
@see BaflUtils::GetEquivalentLanguageList
 */
EXPORT_C void 
BaflUtils::NearestLanguageFileV2(const RFs&amp; aFs,TFileName&amp; aName, TLanguage&amp; aLanguage)
	{
	TNearestLanguageFileFinder finder(aFs);
	TBool goodSuffix=finder.SetFileName(aName);
	
	// Continue only if the suffix is good.
	if(goodSuffix)
		{
		// add preset customised resource drive to drive list  
		// Note that errors returned from AddCustomResourceDrive are ignored. This is because if 
		// a custom resource drive has not been found we still want to continue on with searching 
		// other drives according to our algorithm
		finder.AddCustomResourceDrive();
		
		GetEquivalentLanguageList(User::Language(), finder.iPath);
		if (!finder.FindLanguageAndDrive()
			&amp;&amp; KErrNone != finder.FindFirstLanguageFileAndDrive())
			finder.RepairFileName();
		aLanguage = finder.Language();
		}
	else
		{
		aLanguage = ELangNone;
		}
	}

// TLibAssocBase

EXPORT_C TLibAssocBase::TLibAssocBase(const RLibrary&amp; aLib,TAny* aPtr)
	: iLibrary(aLib),iPtr(aPtr)
/**
Constructs the object taking the specified DLL and a class instance.

@param aLib A reference to a DLL that has already been opened.
@param aPtr An untyped pointer to an object to be associated with the DLL.
            Typically, this object will have been created using
            the ordinal 1 function from that DLL. */	
	{}




EXPORT_C void TLibAssocBase::Set(const RLibrary&amp; aLib,TAny* aPtr)
/**
Implements TLibAssoc::Set().

@param aLib   A reference to a DLL that has already been opened.
@param aClass A pointer to an object to be associated with the DLL.
              Typically, this object will have been created using
              the ordinal 1 function from that DLL.

@see TLibAssoc::Set */
	{
	__ASSERT_ALWAYS(iLibrary.Handle()==KNullHandle&amp;&amp;iPtr==NULL,Panic(EBafPanicLibAssocAlreadySet));
	iLibrary=aLib;
	iPtr=aPtr;
	}




EXPORT_C void TLibAssocBase::DoUnload(TAny* aThis)
/**
Calls Close() on the associated DLL.

@param aThis An untyped pointer to a TLibAssoc type.
*/
	{
	TLibAssocBase&amp; l=*(TLibAssocBase*)aThis;
	l.iPtr=NULL;
	l.iLibrary.Close();
	}

//
// class BaflUtils
//
EXPORT_C void BaflUtils::CopyWithTruncation(TDes&amp; aDest,const TDesC&amp; aSrc,TChar aTruncationSymbol)
/** Copies a descriptor, abbreviating it to fit the destination descriptor.

If aSrc is less than the maximum length of aDest, then the string is simply 
copied to aDest.

If this is not so, then the left-most characters of aSrc are copied to aDest, 
up to aDest's maximum length-1. aDest's final character is set to be aTruncationSymbol.

@param aDest On return, the truncated string
@param aSrc The string to truncate
@param aTruncationSymbol The truncation character to add */
	{ // static
	TInt maxLength=aDest.MaxLength();
	if (aSrc.Length()&lt;=maxLength)
		aDest.Copy(aSrc);
	else
		{
		aDest.Copy(aSrc.Left(maxLength-1));
		aDest.Append(aTruncationSymbol);
		}
	}

EXPORT_C TBool BaflUtils::FileExists(const RFs&amp; aFileSession,const TDesC&amp; aFileName)
/** Checks if the specified file exists.
	
@param aFs File server session
@param aFileName File to check
@return ETrue if the file exists, otherwise EFalse */
	{ // static
	TEntry entry;
	return(aFileSession.Entry(aFileName,entry)==KErrNone);
	}

EXPORT_C TBool BaflUtils::PathExists(RFs&amp; aFs,const TDesC&amp; aPath)
/** Tests whether a path exists.

The path should contain a drive letter and a directory, or EFalse is returned. 
EFalse is also returned if it contains a filename or filename extension.

If the path is badly formed, for instance if it contains illegal characters, 
or any directory name consists of a single or double dot, or any directory 
name includes wildcard characters, the function returns EFalse.

@param aFs A connected session with the file server.
@param aPath The path to test for. It should end in a backslash.
@return ETrue if the path exists, EFalse if not. EFalse is also returned if the 
specified path is badly formed. */
	{ // static
	TParse parse;
	TInt retcode;
	retcode = parse.Set(aPath, NULL, NULL);
	if (retcode != KErrNone)
		return EFalse;
	if ((! parse.DrivePresent()) || (parse.NameOrExtPresent()))
		return EFalse;
	if (parse.Path().Length() == 0)
		return EFalse;
	TFileName dirName = parse.DriveAndPath();
	if (dirName.Length() &gt; KMaxFileName)
		return(EFalse);
    RDir dir;
    retcode = dir.Open(aFs,dirName,0);
	if (retcode == KErrNone)
		dir.Close();
	return (retcode == KErrNone);
	}

EXPORT_C void BaflUtils::EnsurePathExistsL(RFs&amp; aFileSession,const TDesC&amp; aFileName)
/** Makes one or more directories, if they do not already exist. 
	
Any valid path component in the specified path that does not already exist 
is created as a directory. If the specified path already exists, the function 
returns normally.

@param aFs File server session
@param aFileName Path to ensure exists
@see RFs::MkDirAll() */
	{ // static
	TInt error=aFileSession.MkDirAll(aFileName);
	if (error!=KErrAlreadyExists)
		User::LeaveIfError(error);
	}

EXPORT_C TPtrC BaflUtils::ExtractAppNameFromFullName(const TFullName &amp;aName)
/** Gets the application name from a full thread name.

@param aName Thread name
@return Application name
@see RThread */
	{
	// static - return the app name (after first :: before next ::, if any) from a full thread name
	TChar delimiter=':';
	TInt start=aName.Locate(delimiter);
	if (start&lt;0)
		start=0; // should never happen
	else if (aName.Length()&gt;start+2)
		start+=2;
	TPtrC rest=aName.Mid(start);
	TInt end=rest.Locate(delimiter);
	return end&lt;0 ? rest : rest.Left(end);
	}

LOCAL_C TBool IsLanguageExtended(const TLanguage aLanguage)
	{
	// For compatibility reasons, ELangNone is 0xFFFF. However, it's not an extended language.
	if ((aLanguage==ELangNone) || ((static_cast&lt;TUint&gt;(aLanguage))&lt;=KDialectMask))
		return EFalse;
	else
		return ETrue;
	}


LOCAL_C TLanguage BaseLanguage(const TLanguage aLanguage)
	{
	if (IsLanguageExtended(aLanguage))
		return static_cast&lt;TLanguage&gt;(aLanguage &amp; KDialectMask);
	else
		return aLanguage;
	}

LOCAL_C TLanguage NextLanguage(TLanguage aLanguage)
/** Returns the next best language to use after aLanguage,
based on Symbian's base table of language near-equivalence.
@internalAll */
	{
	switch (aLanguage)
		{
		case ELangAustralian:
		case ELangNewZealand:
		case ELangSouthAfricanEnglish:
		case ELangInternationalEnglish:
		case ELangAmerican:
		case ELangEnglish_Apac:
		case ELangEnglish_Taiwan:
		case ELangEnglish_HongKong:
		case ELangEnglish_Prc:
		case ELangEnglish_Japan:
		case ELangEnglish_Thailand:
			return ELangEnglish;
		case ELangCanadianEnglish:
			return ELangAmerican;	// 2-stage downgrade
		case ELangSwissFrench:
		case ELangBelgianFrench:
		case ELangInternationalFrench:
		case ELangCanadianFrench:
			return ELangFrench;
		case ELangSwissGerman:
		case ELangAustrian:
			return ELangGerman;
		case ELangInternationalSpanish:
		case ELangLatinAmericanSpanish:
			return ELangSpanish;
		case ELangSwissItalian:
			return ELangItalian;
		case ELangFinlandSwedish:
			return ELangSwedish;
		case ELangCyprusTurkish:
			return ELangTurkish;
		case ELangBelgianFlemish:
			return ELangDutch;
		case ELangHongKongChinese:
			return ELangTaiwanChinese;
		case ELangCyprusGreek:
			return ELangGreek;
		case ELangMalay_Apac:
			return ELangMalay;
		case ELangBrazilianPortuguese:
			return ELangPortuguese;
		default:
			return ELangNone;	
		}
	}


void AddLanguage(TLanguagePath&amp; aPath, TLanguage aNewLanguage)
/** Add language to the language path if there is space.
The first empty slot must have "ELangNone" in it. This will also be true
on exit. */	
	{
	TLanguage *p = aPath;
	const TLanguage *end = &amp;(aPath[KMaxDowngradeLanguages]);
	while (p != end)
		{
		if (*p == aNewLanguage)
			// language already in list
			break;
		if (*p == ELangNone)
			{
			// found the end of the list
			p[0] = aNewLanguage;
			p[1] = ELangNone;
			break;
			}
		++p;
		}
	return;
	}

void MakeLanguageDowngradePath(TLanguagePath&amp; aPath,
	TLanguage aCurrent, TLanguage aIdeal, const TLocale&amp; aLocale)
	{
	TInt j = 0;
	if( aIdeal != ELangNone)
		{
		aPath[j++]=aIdeal;	
		}
	aPath[j++] = aCurrent;
	aPath[j++] = ELangNone;

	if (aCurrent &amp; ~KDialectMask)
		AddLanguage(aPath, static_cast&lt;TLanguage&gt;(aCurrent &amp; KDialectMask));

	for (TInt i=0;i&lt;=2;i++)
		{
		AddLanguage(aPath, aLocale.LanguageDowngrade(i));
		AddLanguage(aPath, BaseLanguage(aLocale.LanguageDowngrade(i)));
		}

	while (ELangNone != (aCurrent = NextLanguage(BaseLanguage(aCurrent))))  
		AddLanguage(aPath, aCurrent);
	}

TInt RRealDirectoryScanner::Open(RFs&amp; aFs, const TDesC&amp; aMatchPattern)
	{
	return iDir.Open(aFs, aMatchPattern,
		KEntryAttReadOnly | KEntryAttHidden | KEntryAttSystem | KEntryAttArchive);
	}

TInt RRealDirectoryScanner::Next(TEntry&amp; aOut)
	{
	return iDir.Read(aOut);
	}

void RRealDirectoryScanner::Close()
	{
	iDir.Close();
	}

/**
Simply counts the number of numerical characters at the end of the name passed.

@internalComponent
@param			aFilename The filename to parse
				
@return			Count of the numeric digits at the end of the name passed, 
				e.g. x.r491 gives 3.
*/
TInt TNearestLanguageFileFinder::CountDigitsFromEnd(const TDesC&amp; aFilename)
	{
	TInt digitCount = 0;
	
	for (TInt idx = aFilename.Length()-1; idx&gt;=0 &amp;&amp; ISDIGIT (aFilename [idx]); --idx)
		{
		++digitCount;
		}
		
	return digitCount;
	}


/**
Counts the number of digits at the end of a filename.

@internalComponent
@param			aFilename The filename to parse
				
@return			Count of the numeric digits at the end of the suffix, 
				e.g. x.r491 gives 3.
				0 if no numeric end of suffix,
				KErrBadName for an invalid filename,
				KErrNotSupported if the filename (minus path) is less
				than or equal to KInvNameAndMinSuffixLength in length
*/
TInt TNearestLanguageFileFinder::CountDigitsFromEndInSuffix (const TDesC&amp; aFilename)
	{
	TInt digitCount = 0;
	TInt slashIdx = 0;
	TInt len = aFilename.Length ();
	
	// NOTE: We didn't use TChar here as they are too slow.
	// We also didn't use TParse as they are too large.
	
	// don't work on the path
	for (slashIdx=len-1; slashIdx &gt;= 0 &amp;&amp; aFilename[slashIdx] != '\\'; --slashIdx)
	{/*do nothing*/};
	
	// Get new length
	if (slashIdx&gt;=0) {len = len-slashIdx-1;}

	// Initial test to see if filename legal size.
	if (len &gt; KInvNameAndMinSuffixLength)
		{
		digitCount = CountDigitsFromEnd(aFilename);

		// Can't store something bigger or we'll panic!
		if (digitCount &gt; KMaxSuffixLength)
			{
			digitCount = KErrBadName;
			}
		else
		// numeric filename, e.g. "1234". 
		// No preceeding alpha character
		if (!(len-digitCount))
			{
			digitCount = KErrBadName;
			}
		}
	else
		{
		digitCount = KErrNotSupported;
		}
		
	return digitCount;
	}

RDirectoryScanner&amp; TNearestLanguageFileFinder::DirectoryScanner()
	{
	return iDirScanner;
	}

TBool TNearestLanguageFileFinder::FileExists(const TDesC&amp; aFileName) const
	{
	return BaflUtils::FileExists(iFs, aFileName);
	}

TBool TNearestLanguageFileFinder::FindDrive()
	{
	ASSERT(iFileName);
	TBool found=EFalse;
	TInt driveLength=iDrives.Length();
	for (TInt drive = 0; drive!=driveLength; ++drive)
		{
		(*iFileName)[0] = iDrives[drive];
		if (FileExists(*iFileName))
			{
			found=ETrue;
			break;
			}
		}
	return found;
	}

TBool TNearestLanguageFileFinder::AppendLanguageCode(TLanguage aLanguage)
	{
	TInt rest = static_cast&lt;TInt&gt;(aLanguage);
#ifdef _DEBUG
	_LIT(KErrorMessage, "Bafl");
#endif
	__ASSERT_DEBUG(0 &lt;= rest, User::Panic(KErrorMessage,KErrArgument));
	iFileName-&gt;SetLength(iBaseLength);
	const TInt remaining = iFileName-&gt;MaxLength() - iBaseLength;
	TInt soFar = 0;
	TBuf&lt;1&gt; num;
	num.Append('0');
	TBool appendLangSuccess = ETrue;
	TInt digitCount = 0;
	TInt digit = 0;
	while (rest)
		{
		if (remaining == soFar)
			{
			// no more room in descriptor- return rather than panic,
			// file cannot exist.
			iFileName-&gt;SetLength(iBaseLength);
			appendLangSuccess= EFalse;
			break;
			}
		// Convert the number to ASCII by consistantly getting the base 10 remainder to convert.
		// The number is updated minus the remainder for the next iteration.
		// eg (rest = 123) -&gt; (12, r3) -&gt; (1, r2) -&gt; (0, r1)
		// Then insert the ASCII representation of the remainder into the filename end
		// so it appears the correct way round.
		// eg (filename.r) -&gt; (filename.r3) -&gt; (filename.r23) -&gt; (filename.r123)
		digit = rest % 10;
		digitCount++;
		rest /= 10;
		num[0] = static_cast&lt;TText16&gt;(digit + '0');
		iFileName-&gt;Insert(iBaseLength, num);

		// Minimum suffix length is KInvNameAndMinSuffixLength
		// so we have to insert zeros to make this up.
		while (!rest &amp;&amp; digitCount &lt; KInvNameAndMinSuffixLength)
			{
			num[0] = static_cast&lt;TText16&gt;('0');
			iFileName-&gt;Insert(iBaseLength, num);
			++digitCount;
			}
			
		++soFar;
		}
		
	return appendLangSuccess;
	}


TBool TNearestLanguageFileFinder::FindLanguageAndDrive()
/** Search for files across all drives in all languages in the path plus the
language-neutral file. */
	{
	ASSERT(iFileName);
	// No point appending if the suffix is bad
	for (const TLanguage* currentLang = iPath; *currentLang != ELangNone; ++currentLang)
		{
		if (AppendLanguageCode(*currentLang) &amp;&amp; FindDrive())
			{
			iLanguage = *currentLang;
			return ETrue;
			}
		}
	// search for language-neutral file
	iFileName-&gt;SetLength(iBaseLength);
	iFileName-&gt;Append(iSuffix);
	return FindDrive();
	}

TInt TNearestLanguageFileFinder::LanguageNumberFromFile(const TDesC&amp; aFileName, const TDesC&amp; aStem)
	{
	TInt lang = 0;
	TInt multiplier = 1;
	TInt leadingZeroCount = 0;
	TInt languageNumber = KErrNotFound;
	const TText* firstChar = aFileName.Ptr();
	const TText* lastChar = firstChar + aFileName.Length() - 1;
	const TText* currentChar = lastChar;
	// string cannot contain only numbers, because it must have a ':' in it
	while ('0' &lt;= *currentChar &amp;&amp; *currentChar &lt;= '9')
		{
		if (*currentChar == '0')
			leadingZeroCount++;
		else
			{
			leadingZeroCount = 0;
			lang += multiplier * (*currentChar - '0');
			}
		multiplier *= 10;
		--currentChar;
		}
	TInt along=lastChar - currentChar;
	if (2 &lt;= along)
		{
		// We have at least 2 digits at the end.
		// trim of bad leading zeros
		TInt maxTrim = along - 2;
		if (maxTrim &lt; leadingZeroCount)
			{
			leadingZeroCount = maxTrim;
			}
		currentChar += leadingZeroCount;
		// we have at least 2 digits at the end but does the rest of it match the stem?
		TPtrC foundStem(firstChar, currentChar - firstChar + 1);
		//foundStem.CompareF(aStem.Right(foundStem.Length()))
		if (0 == foundStem.CompareF(aStem))
			{
			languageNumber=lang;
			}
		}
	return languageNumber;
	}

TInt TNearestLanguageFileFinder::FindFirstLanguageFile(RFs&amp; aFs)
	{
	ASSERT(iFileName);
	iFileName-&gt;SetLength(iBaseLength);
	TPtrC name(*iFileName);
	TParsePtrC nameToParse(name);
	TPtrC nameStem(nameToParse.NameAndExt());
	iFileName-&gt;Append('*');
	TInt bestLanguageMatch = KMaxTInt;
	RDirectoryScanner&amp; scanner = DirectoryScanner();
	TInt err = scanner.Open(aFs, *iFileName);
	if (err != KErrNone)
		{
		return err;
		}
	TEntry entry;
	while (KErrNone == scanner.Next(entry))
		{
		TInt lang = LanguageNumberFromFile(entry.iName, nameStem);
		if (0 &lt; lang &amp;&amp; lang &lt; bestLanguageMatch)
			{
			bestLanguageMatch = lang;
			}
		}
	scanner.Close();
	if (bestLanguageMatch != KMaxTInt)
		{
		iLanguage = static_cast&lt;TLanguage&gt;(bestLanguageMatch);
		AppendLanguageCode(static_cast&lt;TLanguage&gt;(bestLanguageMatch));
		return KErrNone;
		}
	return KErrNotFound;
	}

// Try each drive for any language files
// iFileName must have a directory specifier
TInt TNearestLanguageFileFinder::FindFirstLanguageFileAndDrive()
	{
	ASSERT(iFileName);
	TInt findFirstResult=KErrNotFound;
	TInt driveLength=iDrives.Length();
	for (TInt drive = 0; drive != driveLength; ++drive)
		{
		(*iFileName)[0] = iDrives[drive];
		TInt err = FindFirstLanguageFile(CONST_CAST(RFs&amp;,iFs));
		if (err == KErrNone || err == KErrNoMemory)
			{
			findFirstResult=err;
			break;
			}
		}
	return findFirstResult;
	}

/**
Invalid filenames are any filename whose length (minus path) must be greater
than KInvNameAndMinSuffixLength, and whose form is purely numerical, i.e. '1234' 
*/
TBool TNearestLanguageFileFinder::SetFileName(TFileName&amp; aFileName)
	{
	iDrives.Zero();
	iFileName = &amp;aFileName;
	iOriginalBaseLength = iFileName-&gt;Length();
	
	TInt suffixLength = CountDigitsFromEndInSuffix (aFileName);
	
	// No point trying for filenames thats are badly formed
	// or that are too large.
	if (suffixLength &gt;= 0 &amp;&amp; 
		KInvNameAndMinSuffixLength &lt; iOriginalBaseLength)
		{
		if (suffixLength &gt; 0)
			{
			// all of suffix to be replaced 
			iSuffix = iFileName-&gt;Right(suffixLength);
			iOriginalBaseLength -= suffixLength;
			iFileName-&gt;SetLength(iOriginalBaseLength);
			}
		else
			{ 
			// No numerical part to suffix
			TInt periodIdx = 0;
			
			// Search for the period within range KInvNameAndMinSuffixLength 
			// from the end. As this must work for all values of
			// KInvNameAndMinSuffixLength
			for (TInt i = iOriginalBaseLength-1; 
			     !periodIdx &amp;&amp; i &gt;= (iOriginalBaseLength-KInvNameAndMinSuffixLength-1);
			     --i)
				{
				if ((*iFileName) [i] == '.')
					{
					periodIdx = i;
					}
				}
			
			// Don't handle files ending in a period.
			// This is because the behaviour is different between Windows
			// and Symbian Fs. In Windows it strips the period off.
			//
			// However, and this shouldn't happen as it is not shown
			// (in the documentation) to be valid.
			// Just try our best.
			if (periodIdx == iOriginalBaseLength-1)
				{
				iSuffix.Zero();
				return EFalse;
				}
			else
			if (periodIdx)
				{
				// If there are KInvNameAndMinSuffixLength chars after the period
				// simply replace them.
				TInt right = iOriginalBaseLength-periodIdx-1;
				iSuffix = iFileName-&gt;Right(right);
				iOriginalBaseLength -= right;
				iFileName-&gt;SetLength(iOriginalBaseLength);					
				}
			else
				{
				// Make the suffix start from KInvNameAndMinSuffixLength 
				// from the right
				TInt right = KInvNameAndMinSuffixLength;
				iSuffix = iFileName-&gt;Right(right);
				iOriginalBaseLength -= right;
				iFileName-&gt;SetLength(iOriginalBaseLength);					
				}
			}
		}
	else
		{
		// bad or no suffix - treat the same
		iSuffix.Zero();
		return EFalse;
		}

	// For filenames with no drive letter prefix and also for filenames
	// shorter than the drive letter length, i.e. with no drive
	// information, insert it.
	// Handles if the user simply enters the drive, e.g. "c:".
	if (iOriginalBaseLength &lt; KMaxDriveName || (*iFileName)[1] != ':')
		{
		// Set up the default if none supplied and make room in the filename 
        // array to contain a drive specification. Set initial drive letter to -1
        // so the iFileName is repaired before exited 
		iInitialDriveLetter = -1;
		iFileName-&gt;Insert(0, _L("_:")); 
		iDrives.Append('Z');
		}
	else
		{
	   // Use the drive supplied inthe aName to NearestLanguageFile()
		iInitialDriveLetter = (*iFileName)[0];
		iDrives.Append(iInitialDriveLetter);
		}
	
	iBaseLength = iFileName-&gt;Length();
	
	return ETrue;
	}


TLanguage TNearestLanguageFileFinder::Language()
	{
	return iLanguage;
	}

TNearestLanguageFileFinder::TNearestLanguageFileFinder(
	const RFs&amp; aFs)
	: iFs(aFs), iFileName(0), iLanguage(ELangNone)
	{
	}

void TNearestLanguageFileFinder::RepairFileName()
	{
	ASSERT(iFileName);
	iFileName-&gt;SetLength(iBaseLength);
	if (iInitialDriveLetter == -1)
		iFileName-&gt;Delete(0, 2);
	else
		(*iFileName)[0] = static_cast&lt;TText&gt;(iInitialDriveLetter);
	iFileName-&gt;SetLength(iOriginalBaseLength);
	iFileName-&gt;Append(iSuffix);
	}


/**
Add the custom resource drive to the start of the iDrives string.

The custom resource drive is a preset writeable drive on which customised 
resource files may be present. This drive takes priority over the other 
drives when searching for language files.

@return KErrNone if iDrives string was successfully modified; KErrAlreadyExists 
if the drive is already present in the string; otherwise one of 
the other system-wide error codes (iDrives will be unmodified). 
*/
TInt TNearestLanguageFileFinder::AddCustomResourceDrive()
	{
	TInt drive = GetCustomResourceDriveNumber();
	if (drive&lt;0)
		return drive;
	
	// if drive not already in drive list
	if (iDrives.LocateF('A' + drive) &lt; 0)
		{
		// add it
		_LIT(KDrivePlaceholder, "_");
		iDrives.Insert(0, KDrivePlaceholder);
		iDrives[0] = 'A' + drive;
		return KErrNone;
		}
	else
		return KErrAlreadyExists;
	}


void TNearestLanguageFileFinder::AddAllDrives()
	{
	ASSERT(iDrives.Length() &lt; 2);
	if (iDrives.Length() == 0)
		{
		iDrives = KAllDrives;
		return;
		}
	TInt pos = KAllDrives().LocateF(iDrives[0]);
	if (pos &lt; 0)
		{
		iDrives = KAllDrives;
		return;
		}
	iDrives.Append(KAllDrives().Left(pos));
	iDrives.Append(KAllDrives().Mid(pos + 1));
	}


/**
Get the value of the custom resource drive.

The custom resource drive is a preset writeable drive on which customised language resource 
files can reside. The drive number is accessed via the HAL attribute ECustomResourceDrive. 
It is then returned if it has been defined as a valid drive no.
Otherwise for backward compatibility reasons an attempt is then made to access the system 
drive HAL attribute instead. This drive number is returned if it has been defined as a valid 
drive number.  
Otherwise if neither a valid ECustomResourceDrive or ESystemDrive exists then KErrNotFound 
is returned.
 
Note that the ESystemDrive HAL attribute has been deprecated. It is accessed here to cater 
for existing implementations which still expect it to be used.
 
@return The drive number (corresponding to a TDriveNumber value) if successful; 
KErrNotFound if neither a valid ECustomResourceDrive or a valid ESystemDrive HAL attribute 
is defined;  
 
@see HAL::ECustomResourceDrive
@see HAL::ESystemDrive
*/
TInt TNearestLanguageFileFinder::GetCustomResourceDriveNumber() const
	{
	TInt drive = KErrNotFound;
	
	// access custom resource drive attribute  
	if (HAL::Get(HAL::ECustomResourceDrive, drive) == KErrNone)
		{
		// check that drive is valid
		if (drive&gt;=EDriveA &amp;&amp; drive&lt;=EDriveZ)
			return drive;	 
		}
		    		    
	// access system drive attribute  
	// (Note that ESystemDrive is deprecated. It is checked here 
	// solely for backward compatibility reasons.)		
	if (HAL::Get(HAL::ESystemDrive, drive) == KErrNone)
		{
		// check that drive is valid
		if (drive&gt;=EDriveA &amp;&amp; drive&lt;=EDriveZ)
				return drive;
		}		
 
	return KErrNotFound;
	}



/** Get the value of the system drive.

The system drive can be set to one of the built-in read/write drives. Which 
drive is used is hardware-dependent. On some hardware, there may not be a 
system drive. The system drive is used as the drive on which localisable files 
are searched for. This enables a phone to be localised dynamically, using 
files not in the ROM.

@param aDriveNumber On return, contains the drive number of the system drive.
@return KErrNone is always returned.

@deprecated This method has been replaced by (and now internally calls) 
RFs:GetSystemDrive, which always returns a valid drive number.

@see BaflUtils::NearestLanguageFile
@see RFs::GetSystemDrive
*/
EXPORT_C TInt BaflUtils::GetSystemDrive(TDriveNumber&amp; aDriveNumber)
	{
	aDriveNumber = RFs::GetSystemDrive();
	return KErrNone;
	}


/** Set most appropriate extension language code for filename and set corresponding language.

Symbian uses numeric values to identify natural languages as specified by the TLanguage enumeration
defined in e32const.h. These values are used at the end of filename extensions to identify the
languages pertaining to files which have language specific variants such as resource files.
For instance filename.r01 and filename.r02 would be the English and French versions of the
resource file filename.rsc. Language codes can be between 2 to 5 digits in length.

Starting from Symbian OS v7.0 this function constructs and uses a language downgrade path which 
consists of up to sixteen TLanguage values the first of which is the ideal language followed by 
the language of the current locale. Up to the next three can be customised using 
TLocale::SetLanguageDowngrade(). The rest of the language downgrade path is based on a 
table of language near equivalence which is internal to Symbian.

This function searches the custom resource drive (if set, retrieved from HAL)
and then searches the optional drive specified in aName or 'Z:' if none is 
specified in aName. The custom resource drive is retrieved from the HAL 
attribute ECustomResourceDrive if set, if not set it will retrieve the legacy 
value set in the legacy HAL attribute ESystemDrive. No custom resource drive 
is searched if neither are set.  
Note - setting the custom resource drive will reduce the performance of this 
routine which will adversely affect device performance e.g. at boot up.
On NAND Flash based devices use of a composite Z: drive file system made up of multiple 
ROM images is the preferred mechanism for customising language resources on devices in 
Symbian OS 9.2 onwards, see Developer Library  Base Porting Guide  Porting: background 
information  NAND flash  NAND Flash image format. Thus use of the custom resource drive 
HAL attribute is effectively obsolete.
  
The last two characters of aName are removed along with any digits which appear before them.
Then language codes specified in the constructed language downgrade path are appended in turn to 
aName as a match is searched for in the file system. In case no match is found using the 
constructed language downgradepath then files in the specified directory are searched for a 
suitable extension with preference given to the one specified if present. In cases where a 
match takes place the aName and aLanguage arguments are updated otherwise aName is left 
unchanged and aLanguage is set to ELangNone.

Here are some examples of correct and incorrect function usage with different aName inputs, 
file system state and downgrade paths as follows: 

@code
Following files exist:
C:\\abc.rsc  - Language Neutral resource file.
C:\\abc.r01  - Resource file for the English language.
C:\\abc.r10  - Resource file for the American-English language.
C:\\abc.r160 - Resource file for the English as appropriate in Japan.

Constructed Downgrade Language Path cases:
- Case 1. (ELangAmerican -&gt; ELangEnglish -&gt; ELangNone).
- Case 2. (ELangEnglish_Japan -&gt; ELangEnglish -&gt; ELangNone).
- Case 3. Same as case 1, However "C:\\abc.r10" is deleted prior to the function call.
- Case 4. Same as case 1, However both "C:\\abc.r01" and "C:\\abc.r10" are deleted prior to the function call.</pre>
</div>
<div class="p">
<pre class="pre codeblock">Input aName . . . . Output aName. . . aLanguage . . . . . Description
--------------------------------------------------------------------------------------------------------------------
"C:\\abc.rsc" . . . "C:\\abc.r10" . . ELangAmerican . . . Match on first language (Case 1)
"C:\\abc.r10" . . . "C:\\abc.r10" . . ELangAmerican . . . Match, However it's not the intended use of 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . the function (Case 1)
"C:\\abc.r" . . . . "C:\\abc.r" . . . ELangNone . . . . . The no. of characters in the suffix is less than 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . KInvNameAndMinSuffixLength(2)(Case 1)
"C:\\abc.". . . . . "C:\\abc.". . . . ELangNone . . . . . Invalid Suffix: The filename ends with a period(Case 1)
"C:\\abc.r123456" . "C:\\abc.r123456" ELangNone . . . . . Invalid Suffix: The no. of digits in the suffix is greater 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . than KMaxSuffixLength(5) (Case 1)
"C:\\abc.10". . . . "C:\\abc.10 . . . ELangNone . . . . . Invalid Suffix: There's no proceeding alphabetical 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . characters in the suffix (Case 1)
"\\abc.rsc" . . . . "\\abc.rsc" . . . ELangNone . . . . . No drive so Z: search, no match (Case 1)
"C:\\abc.rsc" . . . "C:\\abc.r160". . ELangEnglish_Japan. Match for language file 3 digits long (Case 2)
"C:\\abc.rsc" . . . "C:\\abc.r01" . . ELangEnglish. . . . Match on second language (Case 3)
"C:\\abc.rsc" . . . "C:\\abc.rsc" . . ELangNone . . . . . No corresponding langauge file match found (Case 4)
---------------------------------------------------------------------------------------------------------------------</pre>
</div>
<p class="p">
</p><p class="p">See also: <a class="xref" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html#GUID-1698EDE4-92B4-3ADC-8531-3A83D2EB7076">TLanguage</a> <a class="xref" href="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html#GUID-F5D49956-A82F-3233-AB15-05936A614486">BaflUtils::GetDowngradePathL</a> <a class="xref" href="GUID-53299759-C2DD-3ABC-A055-9AFE7C5081C6.html#GUID-B5EBC36C-5A00-35AB-96CF-8AF4D6EC4A59">TLocale::SetLanguageDowngrade</a> </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session.  </td></tr><tr class="bg"><td class="parameter">aName</td><td>Optional drive specification, followed by optional path name, followed by basename for filename, followed by period and extension. On return, in case of a match, this is replaced by the language-specific version which consists of the last two characters of the extension plus any preceding numeric characters being replaced by the language code. Remains unchanged when there's no match  </td></tr><tr><td class="parameter">aLanguage</td><td>On return, in case of a match, this is replaced by the corresponding language. In case of no match it's set to ELangNone.  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-7A0E1FC7-2543-3E38-B224-EC1B9208C2A3"><a name="GUID-7A0E1FC7-2543-3E38-B224-EC1B9208C2A3"><!-- --></a>
<a name="GUID-EA0690FF-419D-353C-BBED-95000E21F843"><!-- --></a><h3 class="sectiontitle">NearestLanguageFileV2 ( const RFs &amp;, TFileName &amp;, TLanguage &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>NearestLanguageFileV2</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;</td><td><span class="parameter">aName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a> &amp;</td><td><span class="parameter">aLanguage</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-7D63FF81-C023-3F5A-91F6-9A1A7058E223"><a name="GUID-7D63FF81-C023-3F5A-91F6-9A1A7058E223"><!-- --></a>
<a name="GUID-993B5C38-CD9D-36D9-961C-CE1B7A6989BE"><!-- --></a><h3 class="sectiontitle">Parse ( const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>Parse</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aName</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if a specified file name can be parsed.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aName</td><td>Name to parse  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-7471FED3-DE19-3A96-AC7C-47073CA9C420"><a name="GUID-7471FED3-DE19-3A96-AC7C-47073CA9C420"><!-- --></a>
<a name="GUID-BA5911C2-98A8-3DC3-9598-784A5DF609FF"><!-- --></a><h3 class="sectiontitle">PathExists ( RFs &amp;, const TDesC &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>PathExists</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFileName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-7A6A2A78-1049-3A50-A88B-7995CA5C450A"><a name="GUID-7A6A2A78-1049-3A50-A88B-7995CA5C450A"><!-- --></a>
<h3 class="sectiontitle">PersistHAL (  )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>PersistHAL</td><td>(</td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Saves the HAL settings to file. This will start a new executable and saves HAL attributes to a file, little delay because of the creation of new process </p>
</div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if suceessful, otheriwse system wide error code. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-EC5109B8-97DB-30B0-9E0D-79285236E0C0"><a name="GUID-EC5109B8-97DB-30B0-9E0D-79285236E0C0"><!-- --></a>
<h3 class="sectiontitle">PersistLocale (  )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>PersistLocale</td><td>(</td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Saves the locale settings in Deprecated9.1 Persistence and initialisation of system locale data will be performed transparently by a separate executable (InilialiseLocale.exe) wich should be loaded as part of the system start procedure. <a class="xref" href="GUID-53299759-C2DD-3ABC-A055-9AFE7C5081C6.html#GUID-53299759-C2DD-3ABC-A055-9AFE7C5081C6">TLocale</a> and the currency symbol to file. </p>
</div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-4C399716-FB1B-3578-87E4-08C8E14F0E4C"><a name="GUID-4C399716-FB1B-3578-87E4-08C8E14F0E4C"><!-- --></a>
<a name="GUID-EB3142E3-5116-39C5-94F9-F95CD0754D2C"><!-- --></a><h3 class="sectiontitle">PersistScreenCalibration ( const TDigitizerCalibration &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>PersistScreenCalibration</td><td>(</td><td>const TDigitizerCalibration &amp;</td><td><span class="parameter">aScreenCalibration</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-35DFD345-35EB-33A8-9C19-E8D1AF8C7FE3"><a name="GUID-35DFD345-35EB-33A8-9C19-E8D1AF8C7FE3"><!-- --></a>
<h3 class="sectiontitle">ReleaseIdealLanguage (  )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>ReleaseIdealLanguage</td><td>(</td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Releases the ideal language store if it has been allocated. This interface is intended for the use of UIKON only.</p>
</div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-60C2C64F-36B3-341C-A370-0966AED01396"><a name="GUID-60C2C64F-36B3-341C-A370-0966AED01396"><!-- --></a>
<a name="GUID-F7D9160B-9A83-39C6-B9A8-422AC35A8AA6"><!-- --></a><h3 class="sectiontitle">RemoveSystemDirectory ( CDir &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>RemoveSystemDirectory</td><td>(</td><td>CDir &amp;</td><td><span class="parameter">aDir</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Removes "System" from a list of directory entries.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aDir</td><td>Array of directory entries.  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-55C98788-6473-32BC-9941-F96D86AC27CF"><a name="GUID-55C98788-6473-32BC-9941-F96D86AC27CF"><!-- --></a>
<a name="GUID-FDEF6BCE-36AD-3001-AE27-CF8548DAF84B"><!-- --></a><h3 class="sectiontitle">RenameFile ( RFs &amp;, const TDesC &amp;, const TDesC &amp;, TUint )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>RenameFile</td><td>(</td><td>RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aOldFullName</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aNewFullName</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a></td><td><span class="parameter">aSwitch</span> = CFileMan::EOverWrite</td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Renames or moves one or more files or directories.</p>
<p class="p">It can be used to move one or more files by specifying different destination and source directories. For more details, </p>
<p class="p">See also: CFileMan::Rename(). </p>
<dl class="dl since">
<dt class="dt dlterm">Since</dt>
<dd class="dd">5.1 </dd>
</dl>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aOldFullName</td><td>Path specifying the file(s) to be renamed.  </td></tr><tr><td class="parameter">aNewFullName</td><td>Path specifying the new name for the files and/or the new directory. Any directories specified in this path that do not exist will be created.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-C0E3B5C2-7443-365E-AC95-1C58EBA6A4CE"><a name="GUID-C0E3B5C2-7443-365E-AC95-1C58EBA6A4CE"><!-- --></a>
<a name="GUID-E7FF8704-2978-3D7D-8E87-9B2716FA0E80"><!-- --></a><h3 class="sectiontitle">RootFolderPath ( const TBuf&lt; 1 &gt; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a></td><td>RootFolderPath</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TBuf</a>&lt; 1 &gt;</td><td><span class="parameter">aDriveLetter</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Gets the root folder for the specified drive.</p>
<p class="p">If aDriveLetter is an alphabet(lowercase or uppercase) then it will return the TFileName which is simply the drive letter plus ":\" If this is not the case, the function will panic with panic code EBafPanicBadOpenArg</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aDriveLetter</td><td>Drive letter  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>Root folder </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-9CC7EFB9-BB87-3539-BF5B-15A5C15B76DB"><a name="GUID-9CC7EFB9-BB87-3539-BF5B-15A5C15B76DB"><!-- --></a>
<a name="GUID-371ED649-2ECA-3CCD-9C59-C765D26E9A96"><!-- --></a><h3 class="sectiontitle">SetIdealLanguage ( TLanguage )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>SetIdealLanguage</td><td>(</td><td><a class="xref xref apiRelation" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html">TLanguage</a></td><td><span class="parameter">aLanguage</span></td><td>)</td><td>[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Set the ideal language for the thread. This interface is intended for the use of UIKON only.</p>
<p class="p">
</p><p class="p">See also: <a class="xref" href="GUID-03C9B091-7CDD-3462-8C0C-82762F81B26F.html#GUID-1698EDE4-92B4-3ADC-8531-3A83D2EB7076">TLanguage</a> <a class="xref" href="GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html#GUID-8F3F7542-AD7A-3713-AF23-B9FF04843954">BaflUtils::NearestLanguageFile()</a> </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aLanguage</td><td>Ideal language.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone, if successful; KErrNoMemory if there is not enough memory </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-FDB3D1BA-5F09-3894-A723-B8953E3F83BD"><a name="GUID-FDB3D1BA-5F09-3894-A723-B8953E3F83BD"><!-- --></a>
<a name="GUID-A0945031-1D01-3AD3-A63C-5929C6580373"><!-- --></a><h3 class="sectiontitle">SortByTable ( CDir &amp;, CBaflFileSortTable * )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>SortByTable</td><td>(</td><td>CDir &amp;</td><td><span class="parameter">aDir</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-C487D1B5-2985-3127-8DE2-C92E9D2441C4.html">CBaflFileSortTable</a> *</td><td><span class="parameter">aTable</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Sorts files by UID.</p>
<p class="p">The caller supplies a table which specifies the order in which files are to be sorted. The files whose UID3 is the first UID in the table appear first. The files whose UID3 is the UID specified second appear next, and so on. Files whose UID3 is not specified in the table, and directories, appear at the end of the list, with directories preceding the files, and with files sorted in ascending order of UID3.</p>
<p class="p">This function is used for customising how lists of application files are sorted.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aDir</td><td>The array of files and directories to sort.  </td></tr><tr class="bg"><td class="parameter">aTable</td><td>A sort order table containing the UIDs to use in the sort.  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise one of the standard error codes. </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-E4904C7D-9D05-3493-918B-74C88F1A493F"><a name="GUID-E4904C7D-9D05-3493-918B-74C88F1A493F"><!-- --></a>
<a name="GUID-26E888BC-0631-3CFB-820D-6BCDC17D321B"><!-- --></a><h3 class="sectiontitle">UidTypeMatches ( const TUidType &amp;, const TUidType &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td>UidTypeMatches</td><td>(</td><td>const <a class="xref xref apiRelation" href="GUID-B6D6B0AD-B15C-339A-8540-40540885089A.html">TUidType</a> &amp;</td><td><span class="parameter">aFileUid</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-B6D6B0AD-B15C-339A-8540-40540885089A.html">TUidType</a> &amp;</td><td><span class="parameter">aMatchUid</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Tests whether two UID types match.</p>
<p class="p">A match is made if each UID in aMatchUid is either identical to the corresponding one in aFileUid, or is KNullUid.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFileUid</td><td>The UID type to match  </td></tr><tr class="bg"><td class="parameter">aMatchUid</td><td>The UID type to match against  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>ETrue if the UIDs match, otherwise EFalse </dd></dl></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-967870B4-F883-3E38-AEB4-611FA5EAD62A"><a name="GUID-967870B4-F883-3E38-AEB4-611FA5EAD62A"><!-- --></a>
<a name="GUID-C7330DFB-3E45-391A-83B0-6ABE9A16E0AF"><!-- --></a><h3 class="sectiontitle">UpdateDiskListL ( const RFs &amp;, CDesCArray &amp;, TBool, TDriveNumber )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C void</td><td>UpdateDiskListL</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-9EC9CD13-91FB-38F7-9E55-F41C584AC5A6.html">CDesCArray</a> &amp;</td><td><span class="parameter">aArray</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TBool</a></td><td><span class="parameter">aIncludeRom</span>,</td></tr><tr><td colspan="3"> </td><td>TDriveNumber</td><td><span class="parameter">aDriveNumber</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Retrieves a list of all drives present on the system.</p>
<p class="p">The file server is interrogated for a list of the drive letters for all available drives. The drive letter that corresponds to aDriveNumber is added to the list regardless of whether it is present, or is corrupt. Also, the C: drive is forced onto the list, even if corrupt or not present.</p>
<p class="p">On emulator: The removable media is represented by drive X: and is forced onto the list unless removed (F5,F4).</p>
<p class="p">On hardware: The removable media is represented by drives D: E: F: and G: and is forced onto the list regardless of whether it is present, or is corrupt.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>A connected session with the file server.  </td></tr><tr class="bg"><td class="parameter">aArray</td><td>On return, contains the drive letters that correspond to the available drives. The drive letters are uppercase and are in alphabetical order.  </td></tr><tr><td class="parameter">aIncludeRom</td><td>Specify ETrue if the ROM drive should be included in the list, EFalse if not.  </td></tr><tr class="bg"><td class="parameter">aDriveNumber</td><td>The drive to force into the list, e.g. the drive in the default path.  </td></tr></table></div>
</div>
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-21994B08-C532-385E-BCBA-A4D7978E17C8"><a name="GUID-21994B08-C532-385E-BCBA-A4D7978E17C8"><!-- --></a>
<a name="GUID-D7E14294-EF05-3B55-B9E8-5C30CFF674D8"><!-- --></a><h3 class="sectiontitle">ValidateFolderNameTypedByUserL ( const RFs &amp;, const TDesC &amp;, const TDesC &amp;, TFileName &amp; )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>IMPORT_C <a class="xref xref apiRelation" href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a></td><td>ValidateFolderNameTypedByUserL</td><td>(</td><td>const RFs &amp;</td><td><span class="parameter">aFs</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aFolderNameTypedByUser</span>,</td></tr><tr><td colspan="3"> </td><td>const <a class="xref xref apiRelation" href="GUID-440FF2B4-353B-3097-A2BA-5887D10B8B23.html">TDesC</a> &amp;</td><td><span class="parameter">aCurrentPath</span>,</td></tr><tr><td colspan="3"> </td><td><a class="xref xref apiRelation" href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html">TFileName</a> &amp;</td><td><span class="parameter">aNewFolderFullName</span></td></tr><tr><td colspan="2"> </td><td>)</td><td colspan="2">[static]</td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">Checks if a folder name (without drive or path) is valid and returns the full name of the folder.</p>
<p class="p">
</p></div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters"><table class="parameters"><tr><th>Parameters</th></tr><tr><td class="parameter">aFs</td><td>File server session  </td></tr><tr class="bg"><td class="parameter">aFolderNameTypedByUser</td><td>Folder name to check  </td></tr><tr><td class="parameter">aCurrentPath</td><td>Path to which to add the folder  </td></tr><tr class="bg"><td class="parameter">aNewFolderFullName</td><td>aFolderNameTypedByUser appended to aCurrentPath  </td></tr></table></div>
<div class="ph ph apiDefNote cxxFunctionReturnDesc section returnsdoc"><dl class="returnsdoc"><dt class="dlterm">Return Value</dt><dd>KErrNone if successful, otherwise another of the system-wide error codes </dd></dl></div>
</div>
</div>
</div></div><div class="footer"><hr /><div class="copy">© Nokia 2005.</div></div>
</div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5F9CAA3E-D8BF-3488-9797-3B9FB4452930.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:22:12 GMT -->
</html>