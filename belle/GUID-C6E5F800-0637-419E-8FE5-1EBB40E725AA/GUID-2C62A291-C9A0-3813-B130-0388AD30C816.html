<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">

<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2C62A291-C9A0-3813-B130-0388AD30C816.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:18:35 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta name="DC.Type" content="cxxFile" />
<meta name="DC.Title" content="es_panic.html" />
<meta name="abstract" content="" />
<meta name="description" content="" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="GUID-2C62A291-C9A0-3813-B130-0388AD30C816" />
<title>es_panic.h</title>
<meta name="keywords" content="api" /><link rel="stylesheet" type="text/css" href="css/nokiacxxref.css" />
<link href="css/s60/style.css" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp3.html" rel="stylesheet" type="text/css" />
<link href="PLUGINS_ROOT/com.nokia.forum.library/css/category-cover_cpp3.html" rel="stylesheet" type="text/css" /></head>
<body id="GUID-2C62A291-C9A0-3813-B130-0388AD30C816"><a name="GUID-2C62A291-C9A0-3813-B130-0388AD30C816"><!-- --></a><div class="body"><div class="contentLeft prTxt">
<h1 class="sectiontitle">es_panic.h File Reference</h1>
<div class="body refbody apiDetail apiClassifierDetail cxxFileDetail"><p class="shortdesc">
<div class="section section apiDesc section apidesc">
</div>
<div class="topic reference apiRef apiOperation cxxFunction nested1" id="GUID-F6F26215-F227-3270-BAC9-B6207E2648FB"><a name="GUID-F6F26215-F227-3270-BAC9-B6207E2648FB"><!-- --></a>
<a name="GUID-5FE8DC71-4B35-37B1-A28F-7B2EC799E365"><!-- --></a><h3 class="sectiontitle">_LIT ( KESockClientPanic, "ESock_client" )</h3>
<div class="body refbody apiDetail apiOperationDetail cxxFunctionDetail section functiondetail"><div class="section signature"><table class="signature"><tr><td>_LIT</td><td>(</td><td>KESockClientPanic</td><td><span class="parameter">,</span></td></tr><tr><td colspan="2"> </td><td>"ESock_client"</td><td><span class="parameter"></span></td></tr><tr><td colspan="1"> </td><td>)</td><td colspan="2"></td></tr></table></div><div class="section section apiDesc section apidesc">
<p class="p">The panic category for panics experienced by ESOCK clients (was "eSock panic" before Symbian OS version 9.1) </p>
<p class="p">See also: <a class="xref" href="GUID-2C62A291-C9A0-3813-B130-0388AD30C816.html#GUID-9712D88B-F0D7-337C-8BC9-9CB8EC2B3479">TESockPanic</a> </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxFunctionParameters section parameters">
</div>
</div>
<div class="topic reference apiRef apiValue cxxEnumeration nested1" id="GUID-9712D88B-F0D7-337C-8BC9-9CB8EC2B3479"><a name="GUID-9712D88B-F0D7-337C-8BC9-9CB8EC2B3479"><!-- --></a>
<h3 class="sectiontitle">Enum TESockPanic</h3>
<div class="body refbody apiDetail apiValueDetail cxxEnumerationDetail section enumerationdetail"><div class="section section apiDesc section apidesc">
<p class="p">The panic numbers for panics panics experienced by ESOCK clients </p>
<p class="p">See also: KESockClientPanic </p>
</div>
<div class="ph ph apiDefItem apiDefItem cxxEnumerators section enumerators"><table class="enumerators"><thead><tr><th>Enumerator</th><th>Value</th><th>Description</th></tr></thead><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-1AE62CD3-A512-3DF5-8692-DA48D5DE3B08"><span class="enumerator">ESockBadHandle</span></a></td><td>0</td><td>
<p class="p">An invalid RSubSession handle was used. For example a <a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0">RSocket</a> call before the socket was Open()ed. </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-BA2B9619-AAD3-3532-98BC-AAAC0EE0ADCF"><span class="enumerator">EBadCancel</span></a></td><td>1</td><td>
<p class="p">(No longer in use) </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-31F3A949-FE91-34F4-A5EA-38E7AF27C153"><span class="enumerator">EConnectingAlready</span></a></td><td>2</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-5ED66E79-50F6-383A-AA04-7D70842D1319">RSocket::Connect()</a> used before a previous connect request on the same socket has completed. Wait for the first to complete or CancelConnect() it. </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-89FBF95D-1071-3388-B26D-724CB7FB3BD3"><span class="enumerator">EReadingAlready</span></a></td><td>3</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-7A676556-0829-3615-8FAE-68DA04D45D7F">RSocket::Read()</a>, Recv(), RecvFrom(), or RecvOneOrMore() used before a previous read request on the same socket has completed. Wait for the first to complete or CancelRead()/CancelRecv() it. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-6F272A32-1FF3-37C7-BC11-52483D7065C9"><span class="enumerator">EWritingAlready</span></a></td><td>4</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-4B210F89-EBF1-32FD-956B-56797F8BAD16">RSocket::Send()</a>, SendTo(), or Write() used before a previous write request on the same socket has completed. Wait for the first to complete or CancelWrite()/CancelSend() it. </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-BA79A866-C1E9-3DEE-8620-481E058EFDD4"><span class="enumerator">ECloseTwice</span></a></td><td>5</td><td>
<p class="p">(No longer in use) </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-18957385-9432-3EE8-A13A-5E9BC60B3709"><span class="enumerator">EShutDownTwice</span></a></td><td>6</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-0BC9EAE2-BFA8-34A6-BCA8-A889A4194618">RSocket::Shutdown()</a> used before a previous shutdown request on the same socket has completed. Wait for the first to complete. This applies also when the shutdown type differs, eg Shutdown(EStopInput) must complete before Shutdown(EStopOutput) can be issued. </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-38ECFBFD-3972-3365-8BC9-DDADF8418044"><span class="enumerator">EAcceptTwice</span></a></td><td>7</td><td>
<p class="p">The socket passed to <a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-8279E9C3-CBDB-3ABC-9F80-3DAD0667DA69">RSocket::Accept()</a> must be a blank socket opened by the argumentless <a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-EEA35BD1-52D0-3620-8188-3BB09C37587D">RSocket::Open()</a> overload; a socket opened with a protocol or already Accept()ed is not blank. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-9B23FC6C-2A06-3385-A8C4-626DB0A163C3"><span class="enumerator">ETwoIoctls</span></a></td><td>8</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-1C20A32A-838C-3919-A2C8-1544D8E98941">RSocket::Ioctl()</a> used before a previous IOCtl request on the same socket has completed. Wait for the first to complete or CancelIoctl() it. </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-43B0D2BD-7E7A-3481-AA56-AEA8A0E86B95"><span class="enumerator">ECantSendToOnConnection</span></a></td><td>9</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-93EBB1D5-5D95-3F84-88B2-3B14BDCFF027">RSocket::SendTo()</a> used with a socket of a protocol that is connection-oriented (such as TCP/IP) </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-BDF5A1F2-FD23-3303-9898-087A34136A65"><span class="enumerator">EListenNeedsConnection</span></a></td><td>10</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-683B4000-A877-33CC-A97A-9F79FCCB04DA">RSocket::Listen()</a> used with a socket of a protocol that is not connection-oriented (such as UDP/IP) </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-D8697F78-DA65-3FAA-AC30-0D559B985838"><span class="enumerator">EAlreadyListening</span></a></td><td>11</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-683B4000-A877-33CC-A97A-9F79FCCB04DA">RSocket::Listen()</a> used on a socket which is already Listen()ing. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-87BE5133-3145-358D-BA52-3B56B4E6B0D6"><span class="enumerator">ENotListening</span></a></td><td>12</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-8279E9C3-CBDB-3ABC-9F80-3DAD0667DA69">RSocket::Accept()</a> used on a socket which has not had Listen() called. </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-AD08F26F-D586-3187-AF6C-A686C164B5B6"><span class="enumerator">EBadAccept</span></a></td><td>13</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-8279E9C3-CBDB-3ABC-9F80-3DAD0667DA69">RSocket::Accept()</a> used with a socket which proves invalid when the passive-open completes. For example the blank socket passed to Accept() was closed before a connection to the listening server socket was made. CancelAccept() must be used before closing the blank socket. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-6B5A33CC-59F0-3F37-82CA-9C9C4E86ED7D"><span class="enumerator">EBadDescriptor</span></a></td><td>14</td><td>
<div class="p">A descriptor argument was corrupt when used by the socket server, which for asynchronous requests may only be when they complete. A common cause of this is allowing a buffer to go out of scope when using data transfer functions. For example: <pre class="pre codeblock">		void CMailTransferObject::SendText(HBufC8* aData)
			{
			iMailSocket.Write(aData-&gt;Des(), iStatus);
			}</pre>
 Here the coder has overlooked the fact that <a class="xref" href="GUID-2A528453-0279-3E47-838C-F8A8D29B88F1.html#GUID-445DE828-ADBA-3591-AAE2-5E5935FCA1B9">HBufC8::Des()</a> returns a <a class="xref" href="GUID-C0D29B11-1535-3D11-B318-B18D30A6120B.html#GUID-C0D29B11-1535-3D11-B318-B18D30A6120B">TPtr8</a> object, which being a temporary will go out of scope when Write() returns. However because ESOCK runs at high scheduler priority and protocols are commonly able to accept data immediately the request will usually have been completed before Write() returns. The panic might only occur for this mail application when it sends a large amount of data or the network is unusually slow. In this example the code should simply have dereferenced the HBufC8* as all that Write() requires is a const <a class="xref" href="GUID-FB97E0A3-352A-316F-97C6-69E4741A8120.html#GUID-FB97E0A3-352A-316F-97C6-69E4741A8120">TDesC8</a>. </div>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-20C668EB-03B7-38CF-8564-CAC269F59D12"><span class="enumerator">ETwice</span></a></td><td>15</td><td>
<p class="p">A request was made of a <a class="xref" href="GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD.html#GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD">RHostResolver</a>, <a class="xref" href="GUID-DDD32F28-BA89-3CA1-93B0-355CDD9CD92D.html#GUID-DDD32F28-BA89-3CA1-93B0-355CDD9CD92D">RServiceResolver</a>, or <a class="xref" href="GUID-7489739B-3608-3F9F-BB02-DE65D7AA53A2.html#GUID-7489739B-3608-3F9F-BB02-DE65D7AA53A2">RNetDatabase</a> when it was still processing a previous request. Usually this would be with an explicitly asynchronous request and you must either cancel it or wait for it to complete. If occurs with multiple threads issuing synchronous requests then you must implement appropriate synchronisation between the threads to avoid this simultaneous use. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-BFEDC203-8ADD-304C-BC62-6F82E615CDCB"><span class="enumerator">EBadQueyComplete</span></a></td><td>16</td><td>
<p class="p">(No longer in use) </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-9C930FAB-9777-34B9-97F4-7F55DFFC765A"><span class="enumerator">ENullSocket</span></a></td><td>17</td><td>
<p class="p">An improper request was made of a blank socket, ie one created through the argumentless Open() method and not yet opened as a passive connection through Accept() on a Listen()ing socket. Improper requests include any which require a specific underlying technology, such as Shutdown() - all that need be done to clean-up a blank socket is Close()ing it. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-A78F09A2-5CBC-3AAA-ACE2-D3C43375F7FF"><span class="enumerator">EMbufManagerNotLoaded</span></a></td><td>18</td><td>
<p class="p">(No longer in use) </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-8115B1EF-FADA-3499-8938-E5AB345CBA07"><span class="enumerator">ENoResolveFirst</span></a></td><td>19</td><td>
<p class="p">
<a class="xref" href="GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD.html#GUID-60B333A8-FA83-378E-A498-38647D9E4412">RHostResolver::Next()</a> was called without a preceding resolution request such as <a class="xref" href="GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD.html#GUID-E348D10F-C62C-36A5-A20E-A903CA51250C">RHostResolver::GetByName()</a> </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-54EDC82A-217C-379C-809C-3F4B6ACB300A"><span class="enumerator">ECannotConnect</span></a></td><td>20</td><td>
<p class="p">Attempted to Connect() on an <a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0">RSocket</a> in a programmatically invalid state, such as having been used for a pending Accept(). </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-6A004C36-5B08-30AC-BDEB-3978FF640DF9"><span class="enumerator">ENoQueryFirst</span></a></td><td>21</td><td>
<p class="p">
<a class="xref" href="GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD.html#GUID-FD4A202B-56AF-394F-9E84-F204E8C6D4F1">RHostResolver::QueryGetNext()</a> was called without a preceding <a class="xref" href="GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD.html#GUID-625C85FE-6AD2-3681-B9C4-5A5D137A073B">RHostResolver::Query()</a>. </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-21E1853D-4B95-333E-BAC6-1800BED6E22D"><span class="enumerator">EPermissionDenied</span></a></td><td>22</td><td>
<p class="p">(No longer in use) </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-C6FC77D2-C5C4-33BF-956D-4BE1579D1BBB"><span class="enumerator">EBadRConnection</span></a></td><td>23</td><td>
<p class="p">
<a class="xref" href="GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-EEA35BD1-52D0-3620-8188-3BB09C37587D">RSocket::Open()</a> or <a class="xref" href="GUID-B16CAD6D-85B1-3482-AAC0-9BADEDB6ABDD.html#GUID-3E1B3176-9676-34CC-B4A0-2C208D708892">RHostResolver::Open()</a> used with a <a class="xref" href="GUID-BED8A733-2ED7-31AD-A911-C1F4707C67FD.html#GUID-BED8A733-2ED7-31AD-A911-C1F4707C67FD">RConnection</a> or <a class="xref" href="GUID-0AFDA357-EE44-3788-9CAB-162B874134BF.html#GUID-0AFDA357-EE44-3788-9CAB-162B874134BF">RSubConnection</a> opened upon a different <a class="xref" href="GUID-EF29C1D7-B1E5-370F-AE37-66231A6BE449.html#GUID-EF29C1D7-B1E5-370F-AE37-66231A6BE449">RSocketServ</a> to that supplied to the current Open(). </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-F141C4C2-F9C0-3273-BD45-5935A7E0D821"><span class="enumerator">EInvalidName</span></a></td><td>24</td><td>
<p class="p">
<a class="xref" href="GUID-BED8A733-2ED7-31AD-A911-C1F4707C67FD.html#GUID-3E70958E-6B3D-3D7B-AF21-3B0F7E85B5A1">RConnection::Open(RSocketServ&amp;, TName&amp;)</a> used with an invalid TName (perhaps never initialised from <a class="xref" href="GUID-BED8A733-2ED7-31AD-A911-C1F4707C67FD.html#GUID-C90F2144-08AB-3AD9-9621-CE7DBACFAB23">RConnection::Name()</a> or that source connection was subsequently closed) </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-AB60D091-7A14-369D-AE1E-BF876BEADAC1"><span class="enumerator">EBadRequest</span></a></td><td>25</td><td>
<p class="p">An extension interface has issued a bad request </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-EFE9C4D2-7842-37C8-82E5-82489AC48773"><span class="enumerator">EBadDescriptorRead</span></a></td><td>26</td><td>
<p class="p">The descriptor passed by the client could not be read from by the server. </p>
<p class="p">See also: <a class="xref" href="GUID-2C62A291-C9A0-3813-B130-0388AD30C816.html#GUID-6B5A33CC-59F0-3F37-82CA-9C9C4E86ED7D">EBadDescriptor</a> </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-FC7C9556-9220-38D2-90BA-C1D0B9E4DA6A"><span class="enumerator">EBadDescriptorWrite</span></a></td><td>27</td><td>
<p class="p">The descriptor passed by the client could not be written to by the server. </p>
<p class="p">See also: <a class="xref" href="GUID-2C62A291-C9A0-3813-B130-0388AD30C816.html#GUID-6B5A33CC-59F0-3F37-82CA-9C9C4E86ED7D">EBadDescriptor</a> </p>
</td></tr><tr><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-7074DAE2-DD35-3B6D-8241-0D8CBA6D997A"><span class="enumerator">EBadDescriptorLength</span></a></td><td>28</td><td>
<p class="p">The descriptor passed by the client had an invalid length when read by the server. </p>
<p class="p">See also: <a class="xref" href="GUID-2C62A291-C9A0-3813-B130-0388AD30C816.html#GUID-6B5A33CC-59F0-3F37-82CA-9C9C4E86ED7D">EBadDescriptor</a> </p>
</td></tr><tr class="bg"><td class="ph ph apiDefItem apiDefItem cxxEnumerator"><a name="GUID-04B77F40-F2B6-321D-8ABC-C3ADE456D953"><span class="enumerator">ENotNullSocket</span></a></td><td>29</td><td>
<p class="p">Open on an already opened socket </p>
</td></tr></table></div>
</div>
</div>
</div></p></div><div class="footer"><hr /><div class="copy">© Nokia 2005.</div></div>
</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-2C62A291-C9A0-3813-B130-0388AD30C816.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:18:35 GMT -->
</html>