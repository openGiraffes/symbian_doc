
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-DB6AF6D3-38B6-51EF-A830-388961A3BF04.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:54:48 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="task" /><meta name="DC.Title" content="How to Write a Serial Protocol Module: Tutorial" /><meta name="abstract" content="This topic gives a summary of the APIs that must be implemented for a new Serial Protocol Module." /><meta name="description" content="This topic gives a summary of the APIs that must be implemented for a new Serial Protocol Module." /><meta name="DC.Relation" scheme="URI" content="GUID-0A61CB48-B8EA-5516-B24E-65898CDF2566" /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-8F2D6AC8-8357-55C7-970B-CD2684BA9B04" /><meta name="DC.Relation" scheme="URI" content="GUID-9B83CDD4-FC94-51A0-AC67-CD04BCAFEF08" /><meta name="DC.Relation" scheme="URI" content="GUID-ED2F48EA-8C31-5729-B312-E925B7EC3B24" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-DB6AF6D3-38B6-51EF-A830-388961A3BF04" /><meta name="DC.Language" content="en" /><title>How to Write a Serial Protocol Module: Tutorial </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-DB6AF6D3-38B6-51EF-A830-388961A3BF04">How to Write a Serial Protocol Module: Tutorial</h1><div><p>This topic gives a summary of the APIs that must be implemented for a new Serial Protocol Module. </p><h3>Steps</h3><ol id="GUID-68872B97-1FC9-58A3-86D3-D7C815CCF215"><a name="GUID-68872B97-1FC9-58A3-86D3-D7C815CCF215"><!-- --></a><li id="GUID-18B80EE7-46D0-58D3-8C2E-361C34AE4EE6"><a name="GUID-18B80EE7-46D0-58D3-8C2E-361C34AE4EE6"><!-- --></a><p></p>Create a new DLL project with a <code>.csy</code> extension and a <em>UID</em> 2 of <code class="codeph">0x10000049</code>.  </li> <li id="GUID-369B15AD-FC60-5B79-B4E8-3EBD8D8B240E"><a name="GUID-369B15AD-FC60-5B79-B4E8-3EBD8D8B240E"><!-- --></a><p></p>Create a class which derives from the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html"><code class="apiname">CPort</code></a> class. This class implements the Serial service provider. Requests are delivered by the Serial Communications Server to the <code class="codeph">CPort</code> class using pure virtual functions. These functions include:  <ol type="i" id="GUID-394FEAFC-CEC3-522C-9E3D-943CC8023B4E"><a name="GUID-394FEAFC-CEC3-522C-9E3D-943CC8023B4E"><!-- --></a><li id="GUID-0C9B671E-EE13-51E7-86D4-C41859A6AD32"><a name="GUID-0C9B671E-EE13-51E7-86D4-C41859A6AD32"><!-- --></a><p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html#GUID-6794366E-3E5F-3ABA-B650-56968B261E89"><code class="apiname">CPort::StartRead()</code></a>, which must be implemented to handle client requests to read data from the port </p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html#GUID-F35F3290-A99A-3FF2-AAFA-240F23D422E4"><code class="apiname">CPort::IPCWrite()</code></a> can be used to send the data to the client  </li> <li id="GUID-74799819-3C48-543A-BBD1-C9E0109E0FE5"><a name="GUID-74799819-3C48-543A-BBD1-C9E0109E0FE5"><!-- --></a><p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html#GUID-99D433D7-6AFC-3A1D-B53A-AB875CF21D17"><code class="apiname">CPort::StartWrite()</code></a>, which must be implemented to handle client requests to write data to the port </p> <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html#GUID-479BBBC4-BB04-3C59-A09B-68957FE69A7E"><code class="apiname">CPort::IPCRead()</code></a> can be used to get the data from the client  </li> </ol> </li> <li id="GUID-DCECA07A-DAA4-5509-AE91-BF57FE06F2C2"><a name="GUID-DCECA07A-DAA4-5509-AE91-BF57FE06F2C2"><!-- --></a><p></p>Create a class which derives from the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D8C11F99-7452-35BB-B53E-440968D4C1A3.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D8C11F99-7452-35BB-B53E-440968D4C1A3.html"><code class="apiname">CSerial</code></a> class. This class implements the Serial protocol factory. The <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D8C11F99-7452-35BB-B53E-440968D4C1A3.html#GUID-59F200BD-B75D-3D3C-AE01-FD6B85525B9C"><code class="apiname">CSerial::NewPortL()</code></a> function must return a new instance of the Serial service provider. The <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D8C11F99-7452-35BB-B53E-440968D4C1A3.html#GUID-B53A32A7-8AB0-31D2-ACAA-69DA0EF2DD23"><code class="apiname">CSerial::Info()</code></a> function must return a complete <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-A6E4627A-A3AE-3B64-9E5C-710EE15C5595.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-A6E4627A-A3AE-3B64-9E5C-710EE15C5595.html"><code class="apiname">TSerialInfo</code></a> record with information for the Serial Protocol Module.  </li> </ol> <div><h3 class="section-title">Results</h3><p>The flexibility of the Comms Architecture allows a Serial protocol module to use the Socket API to use a protocol stack and the protocol stack then uses the Serial Communications Server API ( <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-6B3CA99B-ABF2-32EA-935D-23AE5AE2C306.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-6B3CA99B-ABF2-32EA-935D-23AE5AE2C306.html"><code class="apiname">RCommServ</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-3B4E8ED5-72F7-3E51-B188-3C1045526DDF.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-3B4E8ED5-72F7-3E51-B188-3C1045526DDF.html"><code class="apiname">RComm</code></a> APIs) to use a serial protocol. In some cases this re-entrant configuration causes a deadlock. </p> <p>A Serial protocol module can avoid deadlock when the following conditions are met: </p> <ul><li id="GUID-C65EE183-6B11-5654-AD1C-21DD7BD9ED57"><a name="GUID-C65EE183-6B11-5654-AD1C-21DD7BD9ED57"><!-- --></a><p>The serial protocol module never uses code which causes an <code class="codeph">RComm</code> request on the same serial protocol module </p> </li> <li id="GUID-C13CEC2A-0203-5A38-AA82-092C2614D63C"><a name="GUID-C13CEC2A-0203-5A38-AA82-092C2614D63C"><!-- --></a><p>The serial protocol module must be in a different thread to the other serial protocol module. </p> </li> </ul> <p>Other tips: </p> <ul><li id="GUID-4FA03E52-C9A2-52B1-804B-76784D43D270"><a name="GUID-4FA03E52-C9A2-52B1-804B-76784D43D270"><!-- --></a><p>Always call <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-EF29C1D7-B1E5-370F-AE37-66231A6BE449.html#GUID-68A206F1-3E5C-3B74-9E83-0EE2E0D4F448"><code class="apiname">RSocketServ::StartProtocol()</code></a> which is asynchronous before calling <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-D4F08503-F1EF-3531-9C3C-4AF24A6255F0.html#GUID-3491CE2A-A94D-34E0-B0DD-D476EE3334D7"><code class="apiname">RSocket::Open()</code></a> which is synchronous, but may cause an <code class="codeph">RComm</code> class to be instantiated. </p> </li> <li id="GUID-88A8DD6F-8620-596A-AB8E-37C7B4890DD8"><a name="GUID-88A8DD6F-8620-596A-AB8E-37C7B4890DD8"><!-- --></a><p>The Serial protocol module must correctly implement the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-5CEF7907-E485-3626-8587-53CAC2A06544.html#GUID-6C3DE0B7-5B94-3998-A0E5-B17124986A33"><code class="apiname">CPort::Destruct()</code></a> function. A standard C++ destructor must run synchronously, so <code class="codeph">CPort::Destruct()</code> allows the Serial protocol module to complete asynchronous operations during the close of the port. For example, a Serial protocol module that needs to close an <code class="codeph">RComm</code> object must do this asynchronously. </p> </li> </ul> </div> </div><h3>Related concepts</h3><ul><li><a href="GUID-0A61CB48-B8EA-5516-B24E-65898CDF2566.html"> How
                to Configure Multithreaded C32 Serial Comms: Tutorial</a></li></ul></div></div><div class="footer"><p class="metadata">Last updated October 9th, 2009</p><hr /><div class="copy">Â© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-DB6AF6D3-38B6-51EF-A830-388961A3BF04.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:54:48 GMT -->
</html>