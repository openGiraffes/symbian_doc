
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:00:29 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="How to use the resizable buffer descriptor - RBuf" /><meta name="abstract" content="Use this descriptor to hold a string or binary data." /><meta name="description" content="Use this descriptor to hold a string or binary data." /><meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7" /><meta name="DC.Relation" scheme="URI" content="GUID-E3D2A6ED-8192-563D-8966-DD96B3AF1783" /><meta name="DC.Relation" scheme="URI" content="GUID-0DF9E318-BE97-531E-AB39-A7B5E8787C87" /><meta name="DC.Relation" scheme="URI" content="GUID-A63025D1-7FD4-5120-8A1F-537D6B70103D" /><meta name="DC.Relation" scheme="URI" content="GUID-DBF88873-21B1-5493-8EBF-C9071D314A09" /><meta name="DC.Relation" scheme="URI" content="GUID-11EEFB3D-0414-5BEB-9D78-56A4B9154008" /><meta name="DC.Relation" scheme="URI" content="GUID-E8BEE049-6814-543B-8A88-889E434A5D92" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A" /><meta name="DC.Language" content="en" /><title>How to
use the resizable buffer descriptor - RBuf </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A">How to
use the resizable buffer descriptor - RBuf</h1><div><p>Use this descriptor to hold a string or binary data.</p>
<p>A resizable buffer descriptor is an RBuf type. Use the
member functions of the base classes: TDes and TDesC to
change the data in the descriptor. See <a href="GUID-C85B4EA2-0184-52AF-B097-152E4A023CEF.html">Abstract
base descriptor classes</a>. </p>
<p>This buffer of the descriptor is put on the heap. The buffer is the place
where the data is put. This is useful if you do not know the maximum size
of the data until run time. </p>
<p>The resizable buffer descriptors are similar to what are called <a href="GUID-2762FDF6-F76D-5268-AE2D-4ABA807CFFEE.html">Heap
descriptors</a>, or HBufC types, but the API provided
by <code class="codeph">RBuf</code> is easier to use. The <code class="codeph">RBuf</code> API also
makes it easier to change the maximum size of the buffer containing the data,
a task often referred to as reallocating the buffer. </p>
<p>The general guidelines are: use HBufC descriptors to
contain data that rarely changes; use RBuf descriptors
to contain data that changes frequently. However, in practice, <code class="codeph">RBuf</code> types
are equally suitable for both cases, and you should <em>always consider</em> using
an <code class="codeph">RBuf</code> in preference to an <code class="codeph">HBufC</code>. </p>
<p>For cases where your code uses APIs that return an <code class="codeph">HBufC</code> type,
you can convert this to an <code class="codeph">RBuf</code>. In effect, <code class="codeph">RBuf</code> can
act as a wrapper around the <code class="codeph">HBufC</code>; access and manipulation
of the data is then done through the member functions of RBuf and
its base classes TDes and TDesC </p>
<p>Some key points about resizable buffer descriptors: </p>
<ul>
<li id="GUID-C9051973-DFA3-57E6-8AD2-E6E1B49B0A74"><a name="GUID-C9051973-DFA3-57E6-8AD2-E6E1B49B0A74"><!-- --></a><p>For text data, it is
usual to construct an <code class="codeph">RBuf</code> type and allow the appropriate
variant, either a <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-955061A8-A83E-39E5-8745-8FAC7DEA7BCC.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-955061A8-A83E-39E5-8745-8FAC7DEA7BCC.html"><code class="apiname">RBuf8</code></a> or a <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html"><code class="apiname">RBuf16</code></a> to
be selected at build time. </p> </li>
<li id="GUID-93CD2C60-ABB6-5063-8CCA-B63B09139A3F"><a name="GUID-93CD2C60-ABB6-5063-8CCA-B63B09139A3F"><!-- --></a><p>For binary data, an
explicit <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-955061A8-A83E-39E5-8745-8FAC7DEA7BCC.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-955061A8-A83E-39E5-8745-8FAC7DEA7BCC.html"><code class="apiname">RBuf8</code></a> is used. </p> </li>
<li id="GUID-82B1C228-51A3-5FED-9797-206805BD3DA5"><a name="GUID-82B1C228-51A3-5FED-9797-206805BD3DA5"><!-- --></a><p>It is rare to use an
explicit <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html"><code class="apiname">RBuf16</code></a>. </p> </li>
<li id="GUID-2F339945-4741-59A1-AEAA-B405379E25DB"><a name="GUID-2F339945-4741-59A1-AEAA-B405379E25DB"><!-- --></a><p>Data can be changed
through <code class="codeph">RBuf</code> as well as replaced using its assignment operators.
Like all descriptors, <code class="codeph">RBuf</code> is derived from: </p> <ul>
<li id="GUID-7145D7BB-ABCC-5BF8-B367-6D8F9C308AF9"><a name="GUID-7145D7BB-ABCC-5BF8-B367-6D8F9C308AF9"><!-- --></a><p>the TDes class,
through which the data can be manipulated </p> </li>
<li id="GUID-18DF3A17-15E7-54C7-8E3D-1A968AD46D14"><a name="GUID-18DF3A17-15E7-54C7-8E3D-1A968AD46D14"><!-- --></a><p>the TDesC class,
through which information about the data (such as its length) can be retrieved. </p> </li>
</ul> </li>
<li id="GUID-F2EE3065-3D20-5D2B-9887-2C2181FB0195"><a name="GUID-F2EE3065-3D20-5D2B-9887-2C2181FB0195"><!-- --></a><p>You can pass an <code class="codeph">RBuf</code> to
a function that takes a <code class="codeph">TDesC&amp;</code> parameter, and a <code class="codeph">TDes&amp;</code> parameter. </p> </li>
<li id="GUID-83C851DA-BC8C-543D-9987-656FA19832C2"><a name="GUID-83C851DA-BC8C-543D-9987-656FA19832C2"><!-- --></a><p>Memory that has already
been allocated by your code can be transferred to an <code class="codeph">RBuf</code>.
This allows any data that may be in that location to be managed through the
descriptor. </p> </li>
<li id="GUID-6C6B51EE-486C-5ED1-A343-F6777DB5D130"><a name="GUID-6C6B51EE-486C-5ED1-A343-F6777DB5D130"><!-- --></a><p>Ownership of an existing <code class="codeph">HBufC</code> can
be transferred to an <code class="codeph">RBuf</code>. This allows the data contained
within the <code class="codeph">HBufC</code> to be managed through the <code class="codeph">RBuf</code> API. </p> </li>
</ul>
<p>Although the following notes refer to the build independent types, they
are equally valid for the explicit 8-bit and 16-bit types. </p>
<ul>
<li id="GUID-9506E27E-3079-52A9-A993-4DD1DE1BB50B"><a name="GUID-9506E27E-3079-52A9-A993-4DD1DE1BB50B"><!-- --></a><p> <a href="#GUID-A72C3172-7185-5D87-B4CB-6266AC6146A3">Creating an RBuf</a> </p> </li>
<li id="GUID-C7A121AA-401B-5524-A171-E84352170D71"><a name="GUID-C7A121AA-401B-5524-A171-E84352170D71"><!-- --></a><p> <a href="#GUID-2B23F296-D414-5ABD-82CA-DDCEE2F48459">Re-allocating the memory buffer</a> </p> </li>
<li id="GUID-AC98AE5C-AF3F-5105-BDFF-958D080C92E1"><a name="GUID-AC98AE5C-AF3F-5105-BDFF-958D080C92E1"><!-- --></a><p> <a href="#GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4">Freeing the memory buffer</a> </p> </li>
<li id="GUID-883D98FB-E588-5BCB-A0C0-A64465BFDDA7"><a name="GUID-883D98FB-E588-5BCB-A0C0-A64465BFDDA7"><!-- --></a><p> <a href="#GUID-7ECF515D-D538-5F6C-B2A0-88C1B4E3505C">Cleanup rules</a> </p> </li>
<li id="GUID-94E02925-DDB7-5C8E-9B5B-E98DA78D65D4"><a name="GUID-94E02925-DDB7-5C8E-9B5B-E98DA78D65D4"><!-- --></a><p> <a href="#GUID-6732B0A9-4E6E-50A8-9C4F-ADB2BB8FBAEF">Replacing and modifying data</a> </p> </li>
</ul>
<div id="GUID-A72C3172-7185-5D87-B4CB-6266AC6146A3"><h3 class="section-title">Creating an
RBuf</h3> <p>An RBuf object behaves like a handle to
a resource. In this case, the resource is the buffer that contains the data.
While this might seem to be an implementation issue, you need to understand
that much of the interface provided by the <code class="codeph">RBuf</code> class itself
is involved in allocating, freeing and resizing this buffer. </p> <p>An <code class="codeph">RBuf</code> object
can: </p> <ul>
<li id="GUID-38116609-9E75-57B4-9F34-FEC8AD3AA285"><a name="GUID-38116609-9E75-57B4-9F34-FEC8AD3AA285"><!-- --></a><p>be placed on the program
stack. </p> </li>
<li id="GUID-FD4007BC-6EA8-5DC0-B61E-59B2BA17B5C2"><a name="GUID-FD4007BC-6EA8-5DC0-B61E-59B2BA17B5C2"><!-- --></a><p>be a member of another
'C' type class. </p> </li>
</ul> <p>An <code class="codeph">RBuf</code> object cannot be a member of a 'T' type
class. </p> <p>See also <a href="GUID-2458916B-55B2-5E08-A825-4EBDB3503E67.html">Class
types</a>. </p> <p>The default constructor does not allocate a buffer,
and means that, by default, the object represents no data. In descriptor terminology,
its length is zero and its maximum length is zero. </p> <p>Before an <code class="codeph">RBuf</code> can
hold any data, you need to create the buffer. </p> <ul>
<li id="GUID-8BD20341-B902-5BD2-B121-3596432F4CC9"><a name="GUID-8BD20341-B902-5BD2-B121-3596432F4CC9"><!-- --></a><p> <a href="#GUID-A15FC714-C2D3-51F9-A336-4043F9F6DA1C">Simple construction</a> </p> </li>
<li id="GUID-7EFD2DA7-C50D-54E8-9343-FC26F07387CD"><a name="GUID-7EFD2DA7-C50D-54E8-9343-FC26F07387CD"><!-- --></a><p> <a href="#GUID-82460E76-D738-51BD-AC7F-29C2CA54C597">More advanced construction</a> </p> </li>
<li id="GUID-3A9847B8-8741-5543-B5B2-D7FEB1EB3C4A"><a name="GUID-3A9847B8-8741-5543-B5B2-D7FEB1EB3C4A"><!-- --></a><p> <a href="#GUID-19A5BFF9-0B7E-54C1-BC27-2F69B65FAC47">Creating an RBuf from an existing descriptor</a> </p> </li>
<li id="GUID-BDE8E0A0-0FF6-5BF2-B276-9B9750DDA383"><a name="GUID-BDE8E0A0-0FF6-5BF2-B276-9B9750DDA383"><!-- --></a><p> <a href="#GUID-2C934B0F-97D7-5118-A6C4-7CE375F6E0F7">Creating an RBuf by transferring ownership of a pre-existing buffer</a> </p> </li>
</ul> <p id="GUID-A15FC714-C2D3-51F9-A336-4043F9F6DA1C"><a name="GUID-A15FC714-C2D3-51F9-A336-4043F9F6DA1C"><!-- --></a><strong>Simple construction</strong> </p> <p>The
simplest way to create the buffer is to use the <code class="codeph">Create()</code> or
the <code class="codeph">CreateL()</code> member functions of RBuf [See <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-E5E4895B-4BA2-3EB1-AB7E-D676374F12E2"><code class="apiname">RBuf16::Create()</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-AE30A4E2-0F85-32F3-A4A7-3A8FF8A5B856"><code class="apiname">RBuf16::CreateL()</code></a>]. </p> <p>For example, the following code fragment constructs a resizable
buffer descriptor that can hold up to 15 data items. In descriptor terminology,
this means that the maximum length is set to 15. The current length of the
descriptor is set to zero, i.e. it contains no data. </p> <pre class="codeblock">RBuf buf;
...
buf.CreateL(15);
...</pre> <p>Note that <code class="codeph">CreateL()</code> is similar to <code class="codeph">Create()</code>,
but leaves if memory cannot be allocated. </p> <p id="GUID-82460E76-D738-51BD-AC7F-29C2CA54C597"><a name="GUID-82460E76-D738-51BD-AC7F-29C2CA54C597"><!-- --></a><strong>More advanced construction</strong> </p> <p>A
variation on the simple creation technique is to use the <code class="codeph">CreateMax()</code> or
the <code class="codeph">CreateMaxL()</code> member functions of RBuf [See <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-E5E4895B-4BA2-3EB1-AB7E-D676374F12E2"><code class="apiname">RBuf16::Create()</code></a> and <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-BEFF9C91-DA64-3032-96E8-F5054405DC74.html#GUID-AE30A4E2-0F85-32F3-A4A7-3A8FF8A5B856"><code class="apiname">RBuf16::CreateL()</code></a>]. </p> <p>These functions not only allocate the buffer, but set the current
length of the data to be the same as the maximum length. For example: </p> <pre class="codeblock">RBuf buf;
...
buf.CreateMaxL(15);
...</pre> <p>No data has been assigned to the descriptor, and in effect
it contains "arbitrary" data. However, this can be useful in cases where the
descriptor needs to have a current length before calling another function.
For example, you might want a buffer of 16 bytes initialised to binary zeroes: </p> <pre class="codeblock">RBuf8 buf;
...
buf.CreateMaxL(15);
buf.Fillz();
...</pre> <p> <code class="codeph">FillZ()</code> provided by the <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-445B19E5-E2EE-32E2-8D6C-C7D6A9B3C507.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-445B19E5-E2EE-32E2-8D6C-C7D6A9B3C507.html"><code class="apiname">TDes8</code></a> base
class, sets the data to binary zeroes for the length of the descriptor, 15
bytes in this example. Note that we have explicitly used the 8-bit variant
here. </p> <p>There are other ways of achieving this, but this is an economical
technique. </p> <p id="GUID-19A5BFF9-0B7E-54C1-BC27-2F69B65FAC47"><a name="GUID-19A5BFF9-0B7E-54C1-BC27-2F69B65FAC47"><!-- --></a><strong>Creating an RBuf from an
existing descriptor</strong> </p> <p>A common requirement is to create an RBuf and
to copy the data from an existing descriptor of any type. <code class="codeph">RBuf</code> provides
variants of <code class="codeph">Create()</code> and <code class="codeph">CreateL()</code> to do
this. </p> <p>In the following code fragment, a <a href="GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html#GUID-C6E5F800-0637-419E-8FE5-1EBB40E725AA/GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html"><code class="apiname">TBuf</code></a> descriptor
is passed to a function, which then passes it to this <code class="codeph">CreateL()</code> variant.
The source descriptor has a maximum length of 15, which means that the <code class="codeph">RBuf</code> buffer
is allocated so that the <code class="codeph">RBuf</code> maximum length is also 15. </p> <p>The
content of the source descriptor is copied into the <code class="codeph">RBuf</code>,
and the length of the <code class="codeph">RBuf</code> (i.e. the length of data that
the descriptor represents) is set to be the same as that of the source descriptor
- in this case 11. </p> <pre class="codeblock">_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource);
    ...
    }
</pre> <p>The following code fragment constructs a resizable buffer
descriptor and copies data from a source descriptor. The length of data copied
is limited by the value of the second parameter. If this is less than the
length of the source descriptor, then only this length of data is copied.
The buffer allocated is large enough to contain data of length specified by
this second parameter. </p> <p>This is often used in cases where the length
of the source data is not easily predictable, and it is important to limit
the size of the <code class="codeph">RBuf</code> buffer created. </p> <p>There are two
possibilities in this code fragment : </p> <ul>
<li id="GUID-90C4F9FE-BE4B-52B1-96F6-89803743D065"><a name="GUID-90C4F9FE-BE4B-52B1-96F6-89803743D065"><!-- --></a><p>if the length of <code class="codeph">aSource</code> is
20, then the maximum length of <code class="codeph">buf</code> is limited to 10, only
half the data in <code class="codeph">aSource</code> is copied, and the length of <code class="codeph">buf</code> is
set to 10. </p> </li>
<li id="GUID-1FF37B48-27C9-5B60-8443-46633F609548"><a name="GUID-1FF37B48-27C9-5B60-8443-46633F609548"><!-- --></a><p>if the length of <code class="codeph">aSource</code> is
8, then the maximum length of <code class="codeph">buf</code> is still set to 10; all
8 items are copied, and the length of <code class="codeph">buf</code> is set to 8. </p> </li>
</ul> <pre class="codeblock">void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;
    ...
    buf.CreateL(aSource,10);
    ...
    }
</pre> <p id="GUID-2C934B0F-97D7-5118-A6C4-7CE375F6E0F7"><a name="GUID-2C934B0F-97D7-5118-A6C4-7CE375F6E0F7"><!-- --></a><strong>Creating an RBuf by transferring
ownership of a pre-existing buffer</strong> </p> <p>An important technique is to
create an RBuf and transfer ownership of existing allocated
memory to it. This allows any data in that block of memory to be managed through
the <code class="codeph">RBuf</code>. </p> <p>There are three main cases to consider: </p> <ul>
<li id="GUID-E5C30864-1E72-54EC-B321-3A5F27D5A590"><a name="GUID-E5C30864-1E72-54EC-B321-3A5F27D5A590"><!-- --></a><p>transferring ownership
of a preexisting heap descriptor, an HBufC type. </p> </li>
<li id="GUID-9E7CC922-7B86-5044-A5D7-CFCB76617312"><a name="GUID-9E7CC922-7B86-5044-A5D7-CFCB76617312"><!-- --></a><p>transferring ownership
of allocated memory </p> </li>
<li id="GUID-45EDF081-0E89-50EE-96D7-4E2FF28993B3"><a name="GUID-45EDF081-0E89-50EE-96D7-4E2FF28993B3"><!-- --></a><p>transferring ownership
of the buffer owned by a different <code class="codeph">RBuf</code>. </p> </li>
</ul> <p id="GUID-11BEB9E8-CE72-5DF8-869E-2C2FF9E43A35"><a name="GUID-11BEB9E8-CE72-5DF8-869E-2C2FF9E43A35"><!-- --></a><strong> Transferring ownership
of an HBufC</strong> </p> <p>This is a mechanism you would use if an existing API
returned an HBufC, and you wanted to deal with its data
through an RBuf instead. </p> <p>The following code fragment
shows how this could be done. Note that the <code class="codeph">HBufC</code> pointer
is passed to the <code class="codeph">RBuf</code> constructor. </p> <p>Following construction,
ownership of the heap descriptor has been passed to the <code class="codeph">RBuf</code> object.
In descriptor terminology, the maximum length of the <code class="codeph">RBuf</code> is
15, and its length is 11, reflecting the state of the original <code class="codeph">HBufC</code> object. </p> <p>You
can now manipulate any data that may have been assigned to the original <code class="codeph">HBufC</code>,
through the functions in the <code class="codeph">RBuf</code> base classes. </p> <pre class="codeblock">HBufC* hptr;
_LIT(KSampleText,"Hello World");
...
hptr = HBufC::NewL(15);    // Creates a heap descriptor which can hold up
...                        // to 15 data items. The current length is zero.
*hptr = KSampleText;     // Assigns some data to the heap descriptor.
...                        // The current length of the heap descriptor is now 11.
RBuf buf(hptr);            // Ownership of the heap descriptor is passed
...                        // to the RBuf during construction of the RBuf.
</pre> <p>There is an alternative technique that allows you to assign
ownership of the <code class="codeph">HBufC</code> <em>after</em> construction of the <code class="codeph">RBuf</code> using
the <code class="codeph">Assign()</code> function. This allows you to reuse the same <code class="codeph">RBuf</code> object.
For example: </p> <pre class="codeblock">HBufC* hptr;
_LIT(KSampleText,"Hello World");
...
hptr = HBufC::NewL(15);    // Creates a heap descriptor which can hold up
...                        // to 15 data items. The current length is zero.
*hptr = KSampleText;     // Assigns some data to the heap descriptor.
...                        // The current length of the heap descriptor is now 11.
RBuf buf;
...
buf.Assign(hptr);        // Ownership of the heap descriptor is passed
...                        // to the RBuf after construction of the RBuf.
</pre> <p>Once ownership has been transferred, you must not access the
data through the original <code class="codeph">HBufC</code> pointer. </p> <p>There is
no mechanism for reversing the transfer of ownership. The freeing of the buffer
can only be done through the <code class="codeph">RBuf</code>. See <a href="#GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4">Freeing the buffer</a>. </p> <p><strong>Transferring
ownership of allocated memory</strong> </p> <p>In the following code fragment, <code class="codeph">ptr</code> is
assumed to contain the address of memory previously allocated. The code fragment
shows how ownership of this memory can be transferred to the <code class="codeph">RBuf</code>. </p> <pre class="codeblock">TUint16* ptr;
TInt length(32);
...                // Assume memory of length 32 has been allocated
                // and its address stored in ptr.

RBuf buf;
...
buf.Assign(ptr,length);
...                // The memory passed to the descriptor becomes the
                // descriptor's buffer. In descriptor terminology,
                // the maximum length of the RBuf is 32; its length
                // is zero, meaning that the descriptor represents
                // no data.
</pre> <p><strong> Transferring
ownership of the buffer owned by a different RBuf</strong> </p> <p>In the following
code fragment, an <code class="codeph">RBuf</code> is created, a buffer created for it,
and then ownership is transferred to another <code class="codeph">RBuf</code>. </p> <pre class="codeblock">RBuf bufSource;
RBuf bufTarget;
...
bufSource.CreateL(15);    // Creates memory buffer for the descriptor
                        // that can hold up to 15 data items. In descriptor
                        // terminology, the maximum length is set to 15 and
                        // the current length is set to 0.

bufTarget.Assign(bufSource); // Transfers ownership of the memory buffer
                             // to the bufTarget descriptor.
...</pre> </div>
<div id="GUID-2B23F296-D414-5ABD-82CA-DDCEE2F48459"><h3 class="section-title">Re-allocating
the memory buffer</h3> <p>You can change the size of the memory buffer,
by using the <code class="codeph">ReAlloc()</code> or <code class="codeph">ReAllocL()</code> member
functions of <code class="codeph">RBuf</code>. </p> <p>It does not matter how the original
buffer was allocated, whether directly via <code class="codeph">Create()</code>, <code class="codeph">CreateL()</code>, <code class="codeph">CreateMax()</code> or <code class="codeph">CReateMaxL()</code>, or by transfer of ownership of an existing buffer (and this includes transfer
from an <code class="codeph">HBufC</code>). You do this if you intend to increase (or
significantly decrease) the amount of data that the descriptor is to represent.
Remember that the amount of memory allocated to the buffer is not automatically
changed in response to changes in the amount of data. </p> <p>In the following
code fragment, an <code class="codeph">RBuf</code> is created by copying from an existing
descriptor. It is then reallocated so that its maximum length is doubled.
Error conditions, such as out-of-memory conditions are ignored. </p> <pre class="codeblock">_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;
    Tint max;

    buf.CreateL(aSource);    // max size is 15, length is 11.
    max = buf.MaxLength() * 2;    
    buf.ReallocL(max);        // max size is now 30, but length is still 11.
    ...
    }
</pre> </div>
<div id="GUID-A6368F43-9A67-5583-B279-FE68B8CADEC4"><h3 class="section-title">Freeing the
buffer</h3> <p>You can free the memory buffer by calling <code class="codeph">ReAlloc()</code> or <code class="codeph">ReAllocL()</code> and
passing a zero value. </p> <pre class="codeblock">_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource);    // max size is 15, length is 11.
    buf.ReallocL(0);        // max size is now 0, length is 0, the memory
                            // buffer has been freed, and data
                            // has been thrown away.
    ...
    }
</pre> <p>You can also use the <code class="codeph">Close()</code> member function
of <code class="codeph">RBuf</code>. For example: </p> <pre class="codeblock">_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource);    // max size is 15, length is 11.
    buf.Close();            // max size is now 0, length is 0, the memory
                            // buffer has been freed, and data
                            // has been thrown away.
    ...
    }
</pre> </div>
<div id="GUID-7ECF515D-D538-5F6C-B2A0-88C1B4E3505C"><h3 class="section-title">Cleanup rules</h3> <ul>
<li id="GUID-38476044-1EB5-5488-93A0-CB2C7D2D38B4"><a name="GUID-38476044-1EB5-5488-93A0-CB2C7D2D38B4"><!-- --></a><p>To avoid memory leaks
when the <code class="codeph">RBuf</code> object is placed on the stack, you should use
the following programming pattern: </p> <pre class="codeblock">{
RBuf buf;
buf.CleanupClosePushL();
...                                 // Use the RBuf
CleanupStack::PopAndDestroy()    //remove from cleanup stack
                                // and free the buffer to avoid memory 
}</pre> <p>The <code class="codeph">CleanupClosePushL()</code> function puts a
cleanup item onto the cleanup stack. The effect of this is to cause the class's Close() function
to be called in the event of a leave occurring. In its turn, <code class="codeph">Close()</code> simply
frees off the buffer. </p> </li>
<li id="GUID-E285FB76-1079-5F34-8CC5-CE1A5AC39E70"><a name="GUID-E285FB76-1079-5F34-8CC5-CE1A5AC39E70"><!-- --></a><p>If an <code class="codeph">RBuf</code> is
a member of a class, then that class's destructor must remember to call either
: <code class="codeph">ReAllocL(0)</code> or <code class="codeph">Close()</code>. </p> </li>
<li id="GUID-4B09CAD1-6E16-5FB6-9574-277CE75A48C7"><a name="GUID-4B09CAD1-6E16-5FB6-9574-277CE75A48C7"><!-- --></a><p>An <code class="codeph">RBuf</code> can
be reused, but you must remember to call either : <code class="codeph">ReAllocL(0)</code> or <code class="codeph">Close()</code> before
you assign other memory or another <code class="codeph">HBufC</code>. Failure to do this
will result in a memory leak. </p> </li>
<li id="GUID-433E518F-A96F-5EB8-A2BF-DC4D213A2CF0"><a name="GUID-433E518F-A96F-5EB8-A2BF-DC4D213A2CF0"><!-- --></a><p>You should not use an <code class="codeph">RBuf</code> as
a member of a 'T' type class. See <a href="GUID-2458916B-55B2-5E08-A825-4EBDB3503E67.html">Class
types</a>. </p> </li>
</ul> </div>
<div id="GUID-6732B0A9-4E6E-50A8-9C4F-ADB2BB8FBAEF"><h3 class="section-title">Replacing and
modifying data</h3> <p>Data in an <code class="codeph">RBuf</code> descriptor can
be replaced. It can also be modified using the standard functionality provided
by the TDes base class. </p> <pre class="codeblock">_LIT(KSampleText,"Hello World");
...
TBuf&lt;15&gt; sampletext(KSampleText);
FuncL(sampletext);
...
void FuncL(TDesC&amp; aSource)
    {
    RBuf buf;

    buf.CreateL(aSource.MaxLength());    // Create the RBuf.
    buf = aSource;                        // Copy "Hello World" using the assignment
                                        // operator.

    buf.Delete(1,1);                    // Delete the 1st character.
    ...
    buf.Close();
    }
</pre> </div>
</div></div></div><div class="footer"><p class="metadata">Last updated December 13th, 2010</p><hr /><div class="copy">© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-4AC3CC42-6E8D-584A-AA39-84B5E0F3C16A.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 04:00:29 GMT -->
</html>