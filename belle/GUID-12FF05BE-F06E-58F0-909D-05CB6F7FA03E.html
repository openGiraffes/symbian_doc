
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-12FF05BE-F06E-58F0-909D-05CB6F7FA03E.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:49:12 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="copyright" content="(C) Copyright 2012" /><meta name="DC.rights.owner" content="(C) Copyright 2012" /><meta name="DC.Type" content="concept" /><meta name="DC.Title" content="Code Efficiency" /><meta name="DC.Relation" scheme="URI" content="GUID-86C9DACB-DCCF-43F6-BCEE-91144F4EADC8_overview-GUID-2CA5C27E-A526-4B26-941B-85F0B32E1FFA" /><meta name="DC.Relation" scheme="URI" content="GUID-C3206E31-251C-4AFC-90C2-04B38CCF8E18" /><meta name="DC.Relation" scheme="URI" content="GUID-C50A3F22-FF47-4074-9A8B-E1E8EFDF65EA" /><meta name="DC.Format" content="XHTML" /><meta name="DC.Identifier" content="GUID-12FF05BE-F06E-58F0-909D-05CB6F7FA03E" /><meta name="DC.Language" content="en" /><title>Code Efficiency </title><link href="css/s60/style.css" rel="stylesheet" type="text/css" /><link href="PLUGINS_ROOT/com.nokia.forum.library/css/category_cpp5.html" rel="stylesheet" type="text/css" /></head><body><div class="body"><div class="contentLeft prTxt"><h1 class="pageHeading" id="GUID-12FF05BE-F06E-58F0-909D-05CB6F7FA03E">Code Efficiency</h1><div><p>Attention paid to making code efficient in speed and particularly in resource use is always worthwhile. This topic suggests some methods that should become familiar to Symbian developers for this platform. </p> <div><h3 class="section-title">Stack usage</h3> <p>Each thread in an application has a limited standard stack space of 8Kb, which should be carefully managed. Therefore: </p> <ul><li id="GUID-C8B30A14-5135-5594-A440-C8B4F78E4F0B"><a name="GUID-C8B30A14-5135-5594-A440-C8B4F78E4F0B"><!-- --></a><p>avoid copy-by-value, except for basic types </p> </li> <li id="GUID-03380EB3-E1A7-573C-9CD5-9E7055885341"><a name="GUID-03380EB3-E1A7-573C-9CD5-9E7055885341"><!-- --></a><p>create any large object or array on the heap rather than the stack </p> </li> <li id="GUID-F72CAEC5-FF15-59E9-8452-1324BBB61C7D"><a name="GUID-F72CAEC5-FF15-59E9-8452-1324BBB61C7D"><!-- --></a><p>minimise the lifetime of automatic variables by appropriately scoping them </p> </li> </ul> <p>The last point can be illustrated with the following example: </p> <pre class="codeblock">void ABadFunction()
    {
    TBigObject Object1;
    TBigObject Object2;
    TBigObject Object3;
    
    GetTwoObjectValues(Object1,Object2);
    Object3=SumObjects(Object1,Object2);
    FunctionWithUnknownStackOverhead(Object3);
    }</pre> <p>In the above code, <code class="codeph">Object1</code> and <code class="codeph">Object2</code> persist, using stack space, throughout the lifetime of the call to <code class="codeph">FunctionWithUnknownStackOverhead()</code>, although they are not required by that time. They should be removed from the stack before the call is made. This can be achieved as follows: </p> <pre class="codeblock">void ABetterFunction()
    {
    TBigObject Object1;

    GetTotalObjectValues(Object1);    
    FunctionWithUnknownStackOverhead(Object1);
    }

void GetTotalObjectValues(TBigObject &amp;aObject)
    {
    TBigObject Object1;
    TBigObject Object2;

    GetTwoObjectValues(Object1,Object2);
    aObject=SumObjects(Object1,Object2);
    }</pre> <p>By splitting the code into two functions, you ensure that the stack is used no more than required. </p> </div> <div><h3 class="section-title">Function overloads</h3> <p>If a function definition has default arguments, and if that function often gets called with the caller assuming the default arguments, consider providing an overloaded function that doesn't have the additional arguments. This is because every time the compiler supplies a default parameter, it generates additional code where the function is called. </p> <p>For example, if you have </p> <pre class="codeblock">void FunctionOne(TInt aInt=0);</pre> <p>which often gets called in code by the line </p> <pre class="codeblock">FunctionOne();</pre> <p>then consider supplying </p> <pre class="codeblock">void FunctionOne();</pre> <p>the contents of which might be: </p> <pre class="codeblock">void FunctionOne()
    {
    FunctionOne(0);
    }</pre> </div> <div><h3 class="section-title">Pointers and references</h3> <p>Using a reference as a function argument may be more efficient than using a pointer. This is because the compiler has to preserve the value of the null pointer through all conversions. </p> <p>Imagine a class <code class="codeph">CXxx</code> which derives from a mixin class <code class="codeph">MYyy</code>, as in </p> <pre class="codeblock">class CXxx : public CBase,public MYyy {...};</pre> <p>Then, to pass a pointer to a <code class="codeph">CXxx</code> to a function taking a <code class="codeph">MYyy</code>, the compiler has to add <code class="codeph">sizeof(CBase)</code> to the pointer, except when that pointer is <code class="codeph">NULL</code>. If <code class="codeph">cp</code> is a <code class="codeph">CXxx*</code>, and <code class="codeph">Func()</code> a function taking an <code class="codeph">MYyy*</code>, then what happens in a call like <code class="codeph">Func(cp)</code> is something like this: </p> <pre class="codeblock">Func((MYyy* aM)(cp==NULL ? NULL : (TUint8*)cp+sizeof(CBase)));</pre> <p>Null references are not possible, so no test for <code class="codeph">NULL</code> is necessary when they are used. On ARM, converting from <code class="codeph">CXxx*</code> to <code class="codeph">MYyy*</code> takes 8 instructions, whereas the <code class="codeph">CXxx&amp;</code> to <code class="codeph">MYyy&amp;</code> conversion takes only two. </p> </div> <div><h3 class="section-title">Floating point maths</h3> <p>Floating point maths is sufficiently slow that it is worth looking to see if an alternative algorithm using only integer maths is available. </p> <p>For example, given two <code class="codeph">TInts</code>, <code class="codeph">aTop</code>, and <code class="codeph">aBottom</code>, instead of: </p> <pre class="codeblock">TReal a = (TReal)aTop;
TReal b = (TReal)aBottom;
TReal c = a/b+0.5;
TReal result;
Math::Round(result,c,0);
return (TInt)result;</pre> <p>you should use </p> <pre class="codeblock">return((2*aTop+aBottom)/(2*aBottom));</pre> </div> <div><h3 class="section-title">Inline functions</h3> <p>Inline functions are intended to speed up code by avoiding the expense of a function call, but retain its modularity by disguising operations as functions. Before using them, however, there are two issues that you should check: </p> <ul><li id="GUID-5381813A-ACF4-57FE-B70E-CCB4AA6AF5BC"><a name="GUID-5381813A-ACF4-57FE-B70E-CCB4AA6AF5BC"><!-- --></a><p>code compactness: limited memory resources may mean that the speed cost of a function call is preferable to large bodies of inline code </p> </li> <li id="GUID-58841335-10A8-5E09-B7D6-DB011B95FDA1"><a name="GUID-58841335-10A8-5E09-B7D6-DB011B95FDA1"><!-- --></a><p>binary compatibility: changing the implementation of an inline function can break binary compatibility. This is important if your code is going to be used by other Symbian developers. </p> </li> </ul> <p>The most common cases where inline functions are acceptable are: </p> <ul><li id="GUID-61970E70-8C53-5CCA-A214-4CEF87817FA8"><a name="GUID-61970E70-8C53-5CCA-A214-4CEF87817FA8"><!-- --></a><p>getter and setters for one- or two-machine word quantities: for example, </p> </li> </ul> <pre class="codeblock">inline ConEnv() const { return iConEnv; };</pre> <ul><li id="GUID-261BCAD0-CCD0-502A-9DC3-E8FC5E2217C7"><a name="GUID-261BCAD0-CCD0-502A-9DC3-E8FC5E2217C7"><!-- --></a><p>trivial constructors for <code class="codeph">T</code> classes: </p> </li> </ul> <pre class="codeblock">inline TPoint::TPoint(TInt aX, TInt aY) { iX=aX; iY=aY; }; </pre> <ul><li id="GUID-672214E8-5B5F-5879-BEFF-FF3E50B3280B"><a name="GUID-672214E8-5B5F-5879-BEFF-FF3E50B3280B"><!-- --></a><p>in the thin-template idiom: see <a href="GUID-497930CE-4D61-50EE-A63B-3656158EE29C.html">Thin templates</a> </p> </li> <li id="GUID-D1627362-04CD-55FD-AB66-3DD8A4FFCABD"><a name="GUID-D1627362-04CD-55FD-AB66-3DD8A4FFCABD"><!-- --></a><p>certain other operators and functions, possibly templated, whose definition, not subject to change, is to map one operation onto another, for example, </p> </li> </ul> <pre class="codeblock">template &lt;class T&gt; inline T Min(T aLeft,T aRight)
{ return(aLeft&lt;aRight ? aLeft : aRight); }</pre> </div> <div><h3 class="section-title">No test for NULL pointer when deleting object</h3> <p>C++ specifies that <code class="codeph">delete 0</code> does nothing, so that you need never write code such as </p> <pre class="codeblock">if (iX)
    delete iX;</pre> </div> </div></div></div><div class="footer"><p class="metadata">Last updated October 8th, 2009</p><hr /><div class="copy">Â© Nokia 2012.</div></div></body>
<!-- Mirrored from devlib.symbian.slions.net/belle/GUID-12FF05BE-F06E-58F0-909D-05CB6F7FA03E.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 27 Mar 2020 03:49:12 GMT -->
</html>